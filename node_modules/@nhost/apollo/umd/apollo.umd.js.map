{"version":3,"file":"apollo.umd.js","sources":["../../../node_modules/.pnpm/graphql-ws@5.7.0_graphql@15.7.2/node_modules/graphql-ws/lib/utils.mjs","../../../node_modules/.pnpm/graphql-ws@5.7.0_graphql@15.7.2/node_modules/graphql-ws/lib/common.mjs","../../../node_modules/.pnpm/graphql-ws@5.7.0_graphql@15.7.2/node_modules/graphql-ws/lib/client.mjs","../src/ws.ts","../src/index.ts"],"sourcesContent":["// Extremely small optimisation, reduces runtime prototype traversal\nconst baseHasOwnProperty = Object.prototype.hasOwnProperty;\n/** @private */\nexport function isObject(val) {\n    return typeof val === 'object' && val !== null;\n}\n/** @private */\nexport function isAsyncIterable(val) {\n    return typeof Object(val)[Symbol.asyncIterator] === 'function';\n}\n/** @private */\nexport function isAsyncGenerator(val) {\n    return (isObject(val) &&\n        typeof Object(val)[Symbol.asyncIterator] === 'function' &&\n        typeof val.return === 'function'\n    // for lazy ones, we only need the return anyway\n    // typeof val.throw === 'function' &&\n    // typeof val.next === 'function'\n    );\n}\n/** @private */\nexport function areGraphQLErrors(obj) {\n    return (Array.isArray(obj) &&\n        // must be at least one error\n        obj.length > 0 &&\n        // error has at least a message\n        obj.every((ob) => 'message' in ob));\n}\n/** @private */\nexport function hasOwnProperty(obj, prop) {\n    return baseHasOwnProperty.call(obj, prop);\n}\n/** @private */\nexport function hasOwnObjectProperty(obj, prop) {\n    return baseHasOwnProperty.call(obj, prop) && isObject(obj[prop]);\n}\n/** @private */\nexport function hasOwnArrayProperty(obj, prop) {\n    return baseHasOwnProperty.call(obj, prop) && Array.isArray(obj[prop]);\n}\n/** @private */\nexport function hasOwnStringProperty(obj, prop) {\n    return baseHasOwnProperty.call(obj, prop) && typeof obj[prop] === 'string';\n}\n/**\n * Limits the WebSocket close event reason to not exceed a length of one frame.\n * Reference: https://datatracker.ietf.org/doc/html/rfc6455#section-5.2.\n *\n * @private\n */\nexport function limitCloseReason(reason, whenTooLong) {\n    return reason.length < 124 ? reason : whenTooLong;\n}\n","/**\n *\n * common\n *\n */\nimport { isObject, areGraphQLErrors, hasOwnProperty, hasOwnObjectProperty, hasOwnStringProperty, } from './utils.mjs';\n/**\n * The WebSocket sub-protocol used for the [GraphQL over WebSocket Protocol](/PROTOCOL.md).\n *\n * @category Common\n */\nexport const GRAPHQL_TRANSPORT_WS_PROTOCOL = 'graphql-transport-ws';\n/**\n * The deprecated subprotocol used by [subscriptions-transport-ws](https://github.com/apollographql/subscriptions-transport-ws).\n *\n * @private\n */\nexport const DEPRECATED_GRAPHQL_WS_PROTOCOL = 'graphql-ws';\n/**\n * `graphql-ws` expected and standard close codes of the [GraphQL over WebSocket Protocol](/PROTOCOL.md).\n *\n * @category Common\n */\nexport var CloseCode;\n(function (CloseCode) {\n    CloseCode[CloseCode[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n    CloseCode[CloseCode[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n    CloseCode[CloseCode[\"BadRequest\"] = 4400] = \"BadRequest\";\n    CloseCode[CloseCode[\"BadResponse\"] = 4004] = \"BadResponse\";\n    /** Tried subscribing before connect ack */\n    CloseCode[CloseCode[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n    CloseCode[CloseCode[\"Forbidden\"] = 4403] = \"Forbidden\";\n    CloseCode[CloseCode[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n    CloseCode[CloseCode[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n    CloseCode[CloseCode[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n    /** Subscriber distinction is very important */\n    CloseCode[CloseCode[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n    CloseCode[CloseCode[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n})(CloseCode || (CloseCode = {}));\n/**\n * Types of messages allowed to be sent by the client/server over the WS protocol.\n *\n * @category Common\n */\nexport var MessageType;\n(function (MessageType) {\n    MessageType[\"ConnectionInit\"] = \"connection_init\";\n    MessageType[\"ConnectionAck\"] = \"connection_ack\";\n    MessageType[\"Ping\"] = \"ping\";\n    MessageType[\"Pong\"] = \"pong\";\n    MessageType[\"Subscribe\"] = \"subscribe\";\n    MessageType[\"Next\"] = \"next\";\n    MessageType[\"Error\"] = \"error\";\n    MessageType[\"Complete\"] = \"complete\";\n})(MessageType || (MessageType = {}));\n/**\n * Checks if the provided value is a message.\n *\n * @category Common\n */\nexport function isMessage(val) {\n    if (isObject(val)) {\n        // all messages must have the `type` prop\n        if (!hasOwnStringProperty(val, 'type')) {\n            return false;\n        }\n        // validate other properties depending on the `type`\n        switch (val.type) {\n            case MessageType.ConnectionInit:\n                // the connection init message can have optional payload object\n                return (!hasOwnProperty(val, 'payload') ||\n                    val.payload === undefined ||\n                    isObject(val.payload));\n            case MessageType.ConnectionAck:\n            case MessageType.Ping:\n            case MessageType.Pong:\n                // the connection ack, ping and pong messages can have optional payload object too\n                return (!hasOwnProperty(val, 'payload') ||\n                    val.payload === undefined ||\n                    isObject(val.payload));\n            case MessageType.Subscribe:\n                return (hasOwnStringProperty(val, 'id') &&\n                    hasOwnObjectProperty(val, 'payload') &&\n                    (!hasOwnProperty(val.payload, 'operationName') ||\n                        val.payload.operationName === undefined ||\n                        val.payload.operationName === null ||\n                        typeof val.payload.operationName === 'string') &&\n                    hasOwnStringProperty(val.payload, 'query') &&\n                    (!hasOwnProperty(val.payload, 'variables') ||\n                        val.payload.variables === undefined ||\n                        val.payload.variables === null ||\n                        hasOwnObjectProperty(val.payload, 'variables')) &&\n                    (!hasOwnProperty(val.payload, 'extensions') ||\n                        val.payload.extensions === undefined ||\n                        val.payload.extensions === null ||\n                        hasOwnObjectProperty(val.payload, 'extensions')));\n            case MessageType.Next:\n                return (hasOwnStringProperty(val, 'id') &&\n                    hasOwnObjectProperty(val, 'payload'));\n            case MessageType.Error:\n                return hasOwnStringProperty(val, 'id') && areGraphQLErrors(val.payload);\n            case MessageType.Complete:\n                return hasOwnStringProperty(val, 'id');\n            default:\n                return false;\n        }\n    }\n    return false;\n}\n/**\n * Parses the raw websocket message data to a valid message.\n *\n * @category Common\n */\nexport function parseMessage(data, reviver) {\n    if (isMessage(data)) {\n        return data;\n    }\n    if (typeof data !== 'string') {\n        throw new Error('Message not parsable');\n    }\n    const message = JSON.parse(data, reviver);\n    if (!isMessage(message)) {\n        throw new Error('Invalid message');\n    }\n    return message;\n}\n/**\n * Stringifies a valid message ready to be sent through the socket.\n *\n * @category Common\n */\nexport function stringifyMessage(msg, replacer) {\n    if (!isMessage(msg)) {\n        throw new Error('Cannot stringify invalid message');\n    }\n    return JSON.stringify(msg, replacer);\n}\n","/**\n *\n * client\n *\n */\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, parseMessage, stringifyMessage, } from './common.mjs';\nimport { isObject, limitCloseReason } from './utils.mjs';\n/** This file is the entry point for browsers, re-export common elements. */\nexport * from './common.mjs';\n/**\n * Creates a disposable GraphQL over WebSocket client.\n *\n * @category Client\n */\nexport function createClient(options) {\n    const { url, connectionParams, lazy = true, onNonLazyError = console.error, lazyCloseTimeout = 0, keepAlive = 0, disablePong, connectionAckWaitTimeout = 0, retryAttempts = 5, retryWait = async function randomisedExponentialBackoff(retries) {\n        let retryDelay = 1000; // start with 1s delay\n        for (let i = 0; i < retries; i++) {\n            retryDelay *= 2;\n        }\n        await new Promise((resolve) => setTimeout(resolve, retryDelay +\n            // add random timeout from 300ms to 3s\n            Math.floor(Math.random() * (3000 - 300) + 300)));\n    }, isFatalConnectionProblem = (errOrCloseEvent) => \n    // non `CloseEvent`s are fatal by default\n    !isLikeCloseEvent(errOrCloseEvent), on, webSocketImpl, \n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }, jsonMessageReplacer: replacer, jsonMessageReviver: reviver, } = options;\n    let ws;\n    if (webSocketImpl) {\n        if (!isWebSocket(webSocketImpl)) {\n            throw new Error('Invalid WebSocket implementation provided');\n        }\n        ws = webSocketImpl;\n    }\n    else if (typeof WebSocket !== 'undefined') {\n        ws = WebSocket;\n    }\n    else if (typeof global !== 'undefined') {\n        ws =\n            global.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                global.MozWebSocket;\n    }\n    else if (typeof window !== 'undefined') {\n        ws =\n            window.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                window.MozWebSocket;\n    }\n    if (!ws)\n        throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n    const WebSocketImpl = ws;\n    // websocket status emitter, subscriptions are handled differently\n    const emitter = (() => {\n        const message = (() => {\n            const listeners = {};\n            return {\n                on(id, listener) {\n                    listeners[id] = listener;\n                    return () => {\n                        delete listeners[id];\n                    };\n                },\n                emit(message) {\n                    var _a;\n                    if ('id' in message)\n                        (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n                },\n            };\n        })();\n        const listeners = {\n            connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n            opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n            connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n            ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n            pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n            message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n            closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n            error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : [],\n        };\n        return {\n            onMessage: message.on,\n            on(event, listener) {\n                const l = listeners[event];\n                l.push(listener);\n                return () => {\n                    l.splice(l.indexOf(listener), 1);\n                };\n            },\n            emit(event, ...args) {\n                // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n                for (const listener of [...listeners[event]]) {\n                    // @ts-expect-error: The args should fit\n                    listener(...args);\n                }\n            },\n        };\n    })();\n    // invokes the callback either when an error or closed event is emitted,\n    // first one that gets called prevails, other emissions are ignored\n    function errorOrClosed(cb) {\n        const listening = [\n            // errors are fatal and more critical than close events, throw them first\n            emitter.on('error', (err) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(err);\n            }),\n            // closes can be graceful and not fatal, throw them second (if error didnt throw)\n            emitter.on('closed', (event) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(event);\n            }),\n        ];\n    }\n    let connecting, locks = 0, retrying = false, retries = 0, disposed = false;\n    async function connect() {\n        const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : (connecting = new Promise((connected, denied) => (async () => {\n            if (retrying) {\n                await retryWait(retries);\n                // subscriptions might complete while waiting for retry\n                if (!locks) {\n                    connecting = undefined;\n                    return denied({ code: 1000, reason: 'All Subscriptions Gone' });\n                }\n                retries++;\n            }\n            emitter.emit('connecting');\n            const socket = new WebSocketImpl(typeof url === 'function' ? await url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);\n            let connectionAckTimeout, queuedPing;\n            function enqueuePing() {\n                if (isFinite(keepAlive) && keepAlive > 0) {\n                    clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n                    queuedPing = setTimeout(() => {\n                        if (socket.readyState === WebSocketImpl.OPEN) {\n                            socket.send(stringifyMessage({ type: MessageType.Ping }));\n                            emitter.emit('ping', false, undefined);\n                        }\n                    }, keepAlive);\n                }\n            }\n            errorOrClosed((errOrEvent) => {\n                connecting = undefined;\n                clearTimeout(connectionAckTimeout);\n                clearTimeout(queuedPing);\n                denied(errOrEvent);\n                if (isLikeCloseEvent(errOrEvent) && errOrEvent.code === 4499) {\n                    socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n                    socket.onerror = null;\n                    socket.onclose = null;\n                }\n            });\n            socket.onerror = (err) => emitter.emit('error', err);\n            socket.onclose = (event) => emitter.emit('closed', event);\n            socket.onopen = async () => {\n                try {\n                    emitter.emit('opened', socket);\n                    const payload = typeof connectionParams === 'function'\n                        ? await connectionParams()\n                        : connectionParams;\n                    // connectionParams might take too long causing the server to kick off the client\n                    // the necessary error/close event is already reported - simply stop execution\n                    if (socket.readyState !== WebSocketImpl.OPEN)\n                        return;\n                    socket.send(stringifyMessage(payload\n                        ? {\n                            type: MessageType.ConnectionInit,\n                            payload,\n                        }\n                        : {\n                            type: MessageType.ConnectionInit,\n                            // payload is completely absent if not provided\n                        }, replacer));\n                    if (isFinite(connectionAckWaitTimeout) &&\n                        connectionAckWaitTimeout > 0) {\n                        connectionAckTimeout = setTimeout(() => {\n                            socket.close(CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n                        }, connectionAckWaitTimeout);\n                    }\n                    enqueuePing(); // enqueue ping (noop if disabled)\n                }\n                catch (err) {\n                    emitter.emit('error', err);\n                    socket.close(CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n                }\n            };\n            let acknowledged = false;\n            socket.onmessage = ({ data }) => {\n                try {\n                    const message = parseMessage(data, reviver);\n                    emitter.emit('message', message);\n                    if (message.type === 'ping' || message.type === 'pong') {\n                        emitter.emit(message.type, true, message.payload); // received\n                        if (message.type === 'pong') {\n                            enqueuePing(); // enqueue next ping (noop if disabled)\n                        }\n                        else if (!disablePong) {\n                            // respond with pong on ping\n                            socket.send(stringifyMessage(message.payload\n                                ? {\n                                    type: MessageType.Pong,\n                                    payload: message.payload,\n                                }\n                                : {\n                                    type: MessageType.Pong,\n                                    // payload is completely absent if not provided\n                                }));\n                            emitter.emit('pong', false, message.payload);\n                        }\n                        return; // ping and pongs can be received whenever\n                    }\n                    if (acknowledged)\n                        return; // already connected and acknowledged\n                    if (message.type !== MessageType.ConnectionAck)\n                        throw new Error(`First message cannot be of type ${message.type}`);\n                    clearTimeout(connectionAckTimeout);\n                    acknowledged = true;\n                    emitter.emit('connected', socket, message.payload); // connected = socket opened + acknowledged\n                    retrying = false; // future lazy connects are not retries\n                    retries = 0; // reset the retries on connect\n                    connected([\n                        socket,\n                        new Promise((_, reject) => errorOrClosed(reject)),\n                    ]);\n                }\n                catch (err) {\n                    socket.onmessage = null; // stop reading messages as soon as reading breaks once\n                    emitter.emit('error', err);\n                    socket.close(CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n                }\n            };\n        })())));\n        // if the provided socket is in a closing state, wait for the throw on close\n        if (socket.readyState === WebSocketImpl.CLOSING)\n            await throwOnClose;\n        let release = () => {\n            // releases this connection\n        };\n        const released = new Promise((resolve) => (release = resolve));\n        return [\n            socket,\n            release,\n            Promise.race([\n                // wait for\n                released.then(() => {\n                    if (!locks) {\n                        // and if no more locks are present, complete the connection\n                        const complete = () => socket.close(1000, 'Normal Closure');\n                        if (isFinite(lazyCloseTimeout) && lazyCloseTimeout > 0) {\n                            // if the keepalive is set, allow for the specified calmdown time and\n                            // then complete. but only if no lock got created in the meantime and\n                            // if the socket is still open\n                            setTimeout(() => {\n                                if (!locks && socket.readyState === WebSocketImpl.OPEN)\n                                    complete();\n                            }, lazyCloseTimeout);\n                        }\n                        else {\n                            // otherwise complete immediately\n                            complete();\n                        }\n                    }\n                }),\n                // or\n                throwOnClose,\n            ]),\n        ];\n    }\n    /**\n     * Checks the `connect` problem and evaluates if the client should retry.\n     */\n    function shouldRetryConnectOrThrow(errOrCloseEvent) {\n        // some close codes are worth reporting immediately\n        if (isLikeCloseEvent(errOrCloseEvent) &&\n            (isFatalInternalCloseCode(errOrCloseEvent.code) ||\n                [\n                    CloseCode.InternalServerError,\n                    CloseCode.InternalClientError,\n                    CloseCode.BadRequest,\n                    CloseCode.BadResponse,\n                    CloseCode.Unauthorized,\n                    // CloseCode.Forbidden, might grant access out after retry\n                    CloseCode.SubprotocolNotAcceptable,\n                    // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n                    // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n                    CloseCode.SubscriberAlreadyExists,\n                    CloseCode.TooManyInitialisationRequests,\n                    // 4499, // Terminated, probably because the socket froze, we want to retry\n                ].includes(errOrCloseEvent.code)))\n            throw errOrCloseEvent;\n        // client was disposed, no retries should proceed regardless\n        if (disposed)\n            return false;\n        // normal closure (possibly all subscriptions have completed)\n        // if no locks were acquired in the meantime, shouldnt try again\n        if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000)\n            return locks > 0;\n        // retries are not allowed or we tried to many times, report error\n        if (!retryAttempts || retries >= retryAttempts)\n            throw errOrCloseEvent;\n        // throw fatal connection problems immediately\n        if (isFatalConnectionProblem(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // looks good, start retrying\n        return (retrying = true);\n    }\n    // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n    if (!lazy) {\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const [, , throwOnClose] = await connect();\n                    await throwOnClose; // will always throw because releaser is not used\n                }\n                catch (errOrCloseEvent) {\n                    try {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                            return;\n                    }\n                    catch (errOrCloseEvent) {\n                        // report thrown error, no further retries\n                        return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n                    }\n                }\n            }\n        })();\n    }\n    return {\n        on: emitter.on,\n        subscribe(payload, sink) {\n            const id = generateID();\n            let done = false, errored = false, releaser = () => {\n                // for handling completions before connect\n                locks--;\n                done = true;\n            };\n            (async () => {\n                locks++;\n                for (;;) {\n                    try {\n                        const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n                        // if done while waiting for connect, release the connection lock right away\n                        if (done)\n                            return release();\n                        const unlisten = emitter.onMessage(id, (message) => {\n                            switch (message.type) {\n                                case MessageType.Next: {\n                                    sink.next(message.payload);\n                                    return;\n                                }\n                                case MessageType.Error: {\n                                    (errored = true), (done = true);\n                                    sink.error(message.payload);\n                                    releaser();\n                                    return;\n                                }\n                                case MessageType.Complete: {\n                                    done = true;\n                                    releaser(); // release completes the sink\n                                    return;\n                                }\n                            }\n                        });\n                        socket.send(stringifyMessage({\n                            id,\n                            type: MessageType.Subscribe,\n                            payload,\n                        }, replacer));\n                        releaser = () => {\n                            if (!done && socket.readyState === WebSocketImpl.OPEN)\n                                // if not completed already and socket is open, send complete message to server on release\n                                socket.send(stringifyMessage({\n                                    id,\n                                    type: MessageType.Complete,\n                                }, replacer));\n                            locks--;\n                            done = true;\n                            release();\n                        };\n                        // either the releaser will be called, connection completed and\n                        // the promise resolved or the socket closed and the promise rejected.\n                        // whatever happens though, we want to stop listening for messages\n                        await waitForReleaseOrThrowOnClose.finally(unlisten);\n                        return; // completed, shouldnt try again\n                    }\n                    catch (errOrCloseEvent) {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                            return;\n                    }\n                }\n            })()\n                .then(() => {\n                // delivering either an error or a complete terminates the sequence\n                if (!errored)\n                    sink.complete();\n            }) // resolves on release or normal closure\n                .catch((err) => {\n                sink.error(err);\n            }); // rejects on close events and errors\n            return () => {\n                // dispose only of active subscriptions\n                if (!done)\n                    releaser();\n            };\n        },\n        async dispose() {\n            disposed = true;\n            if (connecting) {\n                // if there is a connection, close it\n                const [socket] = await connecting;\n                socket.close(1000, 'Normal Closure');\n            }\n        },\n        terminate() {\n            if (connecting) {\n                // only if there is a connection\n                emitter.emit('closed', {\n                    code: 4499,\n                    reason: 'Terminated',\n                    wasClean: false,\n                });\n            }\n        },\n    };\n}\nfunction isLikeCloseEvent(val) {\n    return isObject(val) && 'code' in val && 'reason' in val;\n}\nfunction isFatalInternalCloseCode(code) {\n    if ([\n        1000,\n        1001,\n        1006,\n        1005,\n        1012,\n        1013,\n        1013, // Bad Gateway\n    ].includes(code))\n        return false;\n    // all other internal errors are fatal\n    return code >= 1000 && code <= 1999;\n}\nfunction isWebSocket(val) {\n    return (typeof val === 'function' &&\n        'constructor' in val &&\n        'CLOSED' in val &&\n        'CLOSING' in val &&\n        'CONNECTING' in val &&\n        'OPEN' in val);\n}\n","// * See https://github.com/enisdenjo/graphql-ws#graceful-restart\nimport { Client, ClientOptions, createClient } from 'graphql-ws'\n\nexport interface RestartableClient extends Client {\n  restart(): void\n  started(): boolean\n}\n\nexport function createRestartableClient(options: ClientOptions): RestartableClient {\n  let restartRequested = false\n  let restart = () => {\n    restartRequested = true\n  }\n  let _started = false\n  const started = () => _started\n\n  const client = createClient({\n    ...options,\n    on: {\n      ...options.on,\n      connected: () => {\n        _started = true\n      },\n      opened: (originalSocket) => {\n        const socket = originalSocket as WebSocket\n        options.on?.opened?.(socket)\n\n        restart = () => {\n          if (socket.readyState === WebSocket.OPEN) {\n            // if the socket is still open for the restart, do the restart\n            socket.close(4205, 'Client Restart')\n          } else {\n            // otherwise the socket might've closed, indicate that you want\n            // a restart on the next opened event\n            restartRequested = true\n          }\n        }\n\n        // just in case you were eager to restart\n        if (restartRequested) {\n          restartRequested = false\n          restart()\n        }\n      }\n    }\n  })\n\n  return {\n    ...client,\n    restart: () => restart(),\n    started\n  }\n}\n","import {\n  ApolloClient,\n  ApolloClientOptions,\n  createHttpLink,\n  from,\n  InMemoryCache,\n  RequestHandler,\n  split,\n  WatchQueryFetchPolicy\n} from '@apollo/client/core'\nimport { setContext } from '@apollo/client/link/context'\nimport { GraphQLWsLink } from '@apollo/client/link/subscriptions'\nimport { getMainDefinition } from '@apollo/client/utilities'\nimport { NhostClient } from '@nhost/nhost-js'\n\nimport { createRestartableClient } from './ws'\nconst isBrowser = typeof window !== 'undefined'\n\nexport type NhostApolloClientOptions = {\n  nhost?: NhostClient\n  graphqlUrl?: string\n  headers?: any\n  publicRole?: string\n  fetchPolicy?: WatchQueryFetchPolicy\n  connectToDevTools?: boolean\n  cache?: InMemoryCache\n  onError?: RequestHandler\n}\n\nexport const createApolloClient = ({\n  nhost,\n  graphqlUrl,\n  headers = {},\n  publicRole = 'public',\n  fetchPolicy,\n  cache = new InMemoryCache(),\n  connectToDevTools = isBrowser && process.env.NODE_ENV === 'development',\n  onError\n}: NhostApolloClientOptions): ApolloClient<any> => {\n  let backendUrl = graphqlUrl || nhost?.graphql.getUrl()\n  if (!backendUrl) {\n    throw Error(\"Can't initialize the Apollo Client: no backend Url has been provided\")\n  }\n  const interpreter = nhost?.auth.client.interpreter\n\n  let token: string | null = null\n\n  const getAuthHeaders = () => {\n    // add headers\n    const resHeaders = {\n      ...headers,\n      'Sec-WebSocket-Protocol': 'graphql-ws'\n    }\n\n    // add auth headers if signed in\n    // or add 'public' role if not signed in\n    if (token) {\n      resHeaders.authorization = `Bearer ${token}`\n    } else {\n      // ? Not sure it changes anything for Hasura\n      resHeaders.role = publicRole\n    }\n\n    return resHeaders\n  }\n\n  const uri = backendUrl\n\n  const wsClient =\n    isBrowser &&\n    createRestartableClient({\n      url: uri.startsWith('https') ? uri.replace(/^https/, 'wss') : uri.replace(/^http/, 'ws'),\n      connectionParams: () => ({\n        headers: {\n          ...headers,\n          ...getAuthHeaders()\n        }\n      })\n    })\n  const wsLink = wsClient && new GraphQLWsLink(wsClient)\n\n  const httpLink = setContext((_, { headers }) => {\n    return {\n      headers: {\n        ...headers,\n        ...getAuthHeaders()\n      }\n    }\n  }).concat(\n    createHttpLink({\n      uri\n    })\n  )\n\n  const link = wsLink\n    ? split(\n        ({ query }) => {\n          const mainDefinition = getMainDefinition(query)\n\n          const { kind } = mainDefinition\n          let operation\n          if ('operation' in mainDefinition) {\n            operation = mainDefinition.operation\n          }\n\n          return kind === 'OperationDefinition' && operation === 'subscription'\n        },\n        wsLink,\n        httpLink\n      )\n    : httpLink\n\n  const apolloClientOptions: ApolloClientOptions<any> = {\n    cache: cache || new InMemoryCache(),\n    ssrMode: !isBrowser,\n    defaultOptions: {\n      watchQuery: {\n        fetchPolicy\n      }\n    },\n    connectToDevTools\n  }\n\n  // add link\n  apolloClientOptions.link = typeof onError === 'function' ? from([onError, link]) : from([link])\n\n  const client = new ApolloClient(apolloClientOptions)\n\n  interpreter?.onTransition(async (state, event) => {\n    if (['SIGNOUT', 'SIGNED_IN', 'TOKEN_CHANGED'].includes(event.type)) {\n      const newToken = state.context.accessToken.value\n      token = newToken\n      if (event.type === 'SIGNOUT') {\n        try {\n          await client.resetStore()\n        } catch (error) {\n          console.error('Error resetting Apollo client cache')\n          console.error(error)\n        }\n      } else {\n        if (isBrowser && wsClient && wsClient.started()) {\n          wsClient.restart()\n        }\n      }\n    }\n  })\n\n  return client\n}\n"],"names":["InMemoryCache","GraphQLWsLink","setContext","createHttpLink","split","getMainDefinition","from","ApolloClient"],"mappings":"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"}