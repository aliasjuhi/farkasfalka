{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n *\n * server\n *\n */\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n    i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\nimport { parse, validate as graphqlValidate, execute as graphqlExecute, subscribe as graphqlSubscribe, getOperationAST, GraphQLError } from 'graphql';\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, stringifyMessage, parseMessage } from './common.mjs';\nimport { isObject, isAsyncGenerator, isAsyncIterable, areGraphQLErrors } from './utils.mjs';\n/**\n * Makes a Protocol complient WebSocket GraphQL server. The server\n * is actually an API which is to be used with your favourite WebSocket\n * server library!\n *\n * Read more about the Protocol in the PROTOCOL.md documentation file.\n *\n * @category Server\n */\nexport function makeServer(options) {\n  var schema = options.schema,\n    context = options.context,\n    roots = options.roots,\n    validate = options.validate,\n    execute = options.execute,\n    subscribe = options.subscribe,\n    _options$connectionIn = options.connectionInitWaitTimeout,\n    connectionInitWaitTimeout = _options$connectionIn === void 0 ? 3000 : _options$connectionIn,\n    onConnect = options.onConnect,\n    onDisconnect = options.onDisconnect,\n    onClose = options.onClose,\n    onSubscribe = options.onSubscribe,\n    onOperation = options.onOperation,\n    onNext = options.onNext,\n    onError = options.onError,\n    onComplete = options.onComplete,\n    reviver = options.jsonMessageReviver,\n    replacer = options.jsonMessageReplacer;\n  return {\n    opened: function opened(socket, extra) {\n      var ctx = {\n        connectionInitReceived: false,\n        acknowledged: false,\n        subscriptions: {},\n        extra: extra\n      };\n      if (socket.protocol !== GRAPHQL_TRANSPORT_WS_PROTOCOL) {\n        socket.close(CloseCode.SubprotocolNotAcceptable, 'Subprotocol not acceptable');\n        return /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(code, reason) {\n            return _regeneratorRuntime().wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.next = 2;\n                    return onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason);\n                  case 2:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee);\n          }));\n          return function (_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n      }\n      // kick the client off (close socket) if the connection has\n      // not been initialised after the specified wait timeout\n      var connectionInitWait = connectionInitWaitTimeout > 0 && isFinite(connectionInitWaitTimeout) ? setTimeout(function () {\n        if (!ctx.connectionInitReceived) socket.close(CloseCode.ConnectionInitialisationTimeout, 'Connection initialisation timeout');\n      }, connectionInitWaitTimeout) : null;\n      socket.onMessage( /*#__PURE__*/function () {\n        var _onMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(data) {\n          var e_1, _a, _b, message, permittedOrPayload, _message, id, payload, emit, execArgs, maybeExecArgsOrErrors, args, validationErrors, operationAST, operationResult, maybeResult, operationResult_1, operationResult_1_1, result, subscription;\n          return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  _context5.prev = 0;\n                  message = parseMessage(data, reviver);\n                  _context5.next = 7;\n                  break;\n                case 4:\n                  _context5.prev = 4;\n                  _context5.t0 = _context5[\"catch\"](0);\n                  return _context5.abrupt(\"return\", socket.close(CloseCode.BadRequest, 'Invalid message received'));\n                case 7:\n                  _context5.t1 = message.type;\n                  _context5.next = _context5.t1 === MessageType.ConnectionInit ? 10 : _context5.t1 === MessageType.Ping ? 23 : _context5.t1 === MessageType.Pong ? 30 : _context5.t1 === MessageType.Subscribe ? 33 : _context5.t1 === MessageType.Complete ? 147 : 153;\n                  break;\n                case 10:\n                  if (!ctx.connectionInitReceived) {\n                    _context5.next = 12;\n                    break;\n                  }\n                  return _context5.abrupt(\"return\", socket.close(CloseCode.TooManyInitialisationRequests, 'Too many initialisation requests'));\n                case 12:\n                  // @ts-expect-error: I can write\n                  ctx.connectionInitReceived = true;\n                  if (isObject(message.payload))\n                    // @ts-expect-error: I can write\n                    ctx.connectionParams = message.payload;\n                  _context5.next = 16;\n                  return onConnect === null || onConnect === void 0 ? void 0 : onConnect(ctx);\n                case 16:\n                  permittedOrPayload = _context5.sent;\n                  if (!(permittedOrPayload === false)) {\n                    _context5.next = 19;\n                    break;\n                  }\n                  return _context5.abrupt(\"return\", socket.close(CloseCode.Forbidden, 'Forbidden'));\n                case 19:\n                  _context5.next = 21;\n                  return socket.send(stringifyMessage(isObject(permittedOrPayload) ? {\n                    type: MessageType.ConnectionAck,\n                    payload: permittedOrPayload\n                  } : {\n                    type: MessageType.ConnectionAck\n                    // payload is completely absent if not provided\n                  }, replacer));\n                case 21:\n                  // @ts-expect-error: I can write\n                  ctx.acknowledged = true;\n                  return _context5.abrupt(\"return\");\n                case 23:\n                  if (!socket.onPing) {\n                    _context5.next = 27;\n                    break;\n                  }\n                  _context5.next = 26;\n                  return socket.onPing(message.payload);\n                case 26:\n                  return _context5.abrupt(\"return\", _context5.sent);\n                case 27:\n                  _context5.next = 29;\n                  return socket.send(stringifyMessage(message.payload ? {\n                    type: MessageType.Pong,\n                    payload: message.payload\n                  } : {\n                    type: MessageType.Pong\n                    // payload is completely absent if not provided\n                  }));\n                case 29:\n                  return _context5.abrupt(\"return\");\n                case 30:\n                  _context5.next = 32;\n                  return (_b = socket.onPong) === null || _b === void 0 ? void 0 : _b.call(socket, message.payload);\n                case 32:\n                  return _context5.abrupt(\"return\", _context5.sent);\n                case 33:\n                  if (ctx.acknowledged) {\n                    _context5.next = 35;\n                    break;\n                  }\n                  return _context5.abrupt(\"return\", socket.close(CloseCode.Unauthorized, 'Unauthorized'));\n                case 35:\n                  _message = message, id = _message.id, payload = _message.payload;\n                  if (!(id in ctx.subscriptions)) {\n                    _context5.next = 38;\n                    break;\n                  }\n                  return _context5.abrupt(\"return\", socket.close(CloseCode.SubscriberAlreadyExists, \"Subscriber for \".concat(id, \" already exists\")));\n                case 38:\n                  // if this turns out to be a streaming operation, the subscription value\n                  // will change to an `AsyncIterable`, otherwise it will stay as is\n                  ctx.subscriptions[id] = null;\n                  emit = {\n                    next: function () {\n                      var _next = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(result, args) {\n                        var nextMessage, maybeResult;\n                        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                          while (1) {\n                            switch (_context2.prev = _context2.next) {\n                              case 0:\n                                nextMessage = {\n                                  id: id,\n                                  type: MessageType.Next,\n                                  payload: result\n                                };\n                                _context2.next = 3;\n                                return onNext === null || onNext === void 0 ? void 0 : onNext(ctx, nextMessage, args, result);\n                              case 3:\n                                maybeResult = _context2.sent;\n                                if (maybeResult) nextMessage = Object.assign(Object.assign({}, nextMessage), {\n                                  payload: maybeResult\n                                });\n                                _context2.next = 7;\n                                return socket.send(stringifyMessage(nextMessage, replacer));\n                              case 7:\n                              case \"end\":\n                                return _context2.stop();\n                            }\n                          }\n                        }, _callee2);\n                      }));\n                      function next(_x4, _x5) {\n                        return _next.apply(this, arguments);\n                      }\n                      return next;\n                    }(),\n                    error: function () {\n                      var _error = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(errors) {\n                        var errorMessage, maybeErrors;\n                        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                          while (1) {\n                            switch (_context3.prev = _context3.next) {\n                              case 0:\n                                errorMessage = {\n                                  id: id,\n                                  type: MessageType.Error,\n                                  payload: errors\n                                };\n                                _context3.next = 3;\n                                return onError === null || onError === void 0 ? void 0 : onError(ctx, errorMessage, errors);\n                              case 3:\n                                maybeErrors = _context3.sent;\n                                if (maybeErrors) errorMessage = Object.assign(Object.assign({}, errorMessage), {\n                                  payload: maybeErrors\n                                });\n                                _context3.next = 7;\n                                return socket.send(stringifyMessage(errorMessage, replacer));\n                              case 7:\n                              case \"end\":\n                                return _context3.stop();\n                            }\n                          }\n                        }, _callee3);\n                      }));\n                      function error(_x6) {\n                        return _error.apply(this, arguments);\n                      }\n                      return error;\n                    }(),\n                    complete: function () {\n                      var _complete = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(notifyClient) {\n                        var completeMessage;\n                        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                          while (1) {\n                            switch (_context4.prev = _context4.next) {\n                              case 0:\n                                completeMessage = {\n                                  id: id,\n                                  type: MessageType.Complete\n                                };\n                                _context4.next = 3;\n                                return onComplete === null || onComplete === void 0 ? void 0 : onComplete(ctx, completeMessage);\n                              case 3:\n                                if (!notifyClient) {\n                                  _context4.next = 6;\n                                  break;\n                                }\n                                _context4.next = 6;\n                                return socket.send(stringifyMessage(completeMessage, replacer));\n                              case 6:\n                              case \"end\":\n                                return _context4.stop();\n                            }\n                          }\n                        }, _callee4);\n                      }));\n                      function complete(_x7) {\n                        return _complete.apply(this, arguments);\n                      }\n                      return complete;\n                    }()\n                  };\n                  _context5.prev = 40;\n                  _context5.next = 43;\n                  return onSubscribe === null || onSubscribe === void 0 ? void 0 : onSubscribe(ctx, message);\n                case 43:\n                  maybeExecArgsOrErrors = _context5.sent;\n                  if (!maybeExecArgsOrErrors) {\n                    _context5.next = 56;\n                    break;\n                  }\n                  if (!areGraphQLErrors(maybeExecArgsOrErrors)) {\n                    _context5.next = 51;\n                    break;\n                  }\n                  _context5.next = 48;\n                  return emit.error(maybeExecArgsOrErrors);\n                case 48:\n                  return _context5.abrupt(\"return\", _context5.sent);\n                case 51:\n                  if (!Array.isArray(maybeExecArgsOrErrors)) {\n                    _context5.next = 53;\n                    break;\n                  }\n                  throw new Error('Invalid return value from onSubscribe hook, expected an array of GraphQLError objects');\n                case 53:\n                  // not errors, is exec args\n                  execArgs = maybeExecArgsOrErrors;\n                  _context5.next = 76;\n                  break;\n                case 56:\n                  if (schema) {\n                    _context5.next = 58;\n                    break;\n                  }\n                  throw new Error('The GraphQL schema is not provided');\n                case 58:\n                  args = {\n                    operationName: payload.operationName,\n                    document: parse(payload.query),\n                    variableValues: payload.variables\n                  };\n                  _context5.t2 = Object;\n                  _context5.t3 = Object.assign({}, args);\n                  if (!(typeof schema === 'function')) {\n                    _context5.next = 67;\n                    break;\n                  }\n                  _context5.next = 64;\n                  return schema(ctx, message, args);\n                case 64:\n                  _context5.t4 = _context5.sent;\n                  _context5.next = 68;\n                  break;\n                case 67:\n                  _context5.t4 = schema;\n                case 68:\n                  _context5.t5 = _context5.t4;\n                  _context5.t6 = {\n                    schema: _context5.t5\n                  };\n                  execArgs = _context5.t2.assign.call(_context5.t2, _context5.t3, _context5.t6);\n                  validationErrors = (validate !== null && validate !== void 0 ? validate : graphqlValidate)(execArgs.schema, execArgs.document);\n                  if (!(validationErrors.length > 0)) {\n                    _context5.next = 76;\n                    break;\n                  }\n                  _context5.next = 75;\n                  return emit.error(validationErrors);\n                case 75:\n                  return _context5.abrupt(\"return\", _context5.sent);\n                case 76:\n                  operationAST = getOperationAST(execArgs.document, execArgs.operationName);\n                  if (operationAST) {\n                    _context5.next = 81;\n                    break;\n                  }\n                  _context5.next = 80;\n                  return emit.error([new GraphQLError('Unable to identify operation')]);\n                case 80:\n                  return _context5.abrupt(\"return\", _context5.sent);\n                case 81:\n                  // if `onSubscribe` didnt specify a rootValue, inject one\n                  if (!('rootValue' in execArgs)) execArgs.rootValue = roots === null || roots === void 0 ? void 0 : roots[operationAST.operation];\n                  // if `onSubscribe` didn't specify a context, inject one\n                  if ('contextValue' in execArgs) {\n                    _context5.next = 91;\n                    break;\n                  }\n                  if (!(typeof context === 'function')) {\n                    _context5.next = 89;\n                    break;\n                  }\n                  _context5.next = 86;\n                  return context(ctx, message, execArgs);\n                case 86:\n                  _context5.t7 = _context5.sent;\n                  _context5.next = 90;\n                  break;\n                case 89:\n                  _context5.t7 = context;\n                case 90:\n                  execArgs.contextValue = _context5.t7;\n                case 91:\n                  if (!(operationAST.operation === 'subscription')) {\n                    _context5.next = 97;\n                    break;\n                  }\n                  _context5.next = 94;\n                  return (subscribe !== null && subscribe !== void 0 ? subscribe : graphqlSubscribe)(execArgs);\n                case 94:\n                  operationResult = _context5.sent;\n                  _context5.next = 100;\n                  break;\n                case 97:\n                  _context5.next = 99;\n                  return (execute !== null && execute !== void 0 ? execute : graphqlExecute)(execArgs);\n                case 99:\n                  operationResult = _context5.sent;\n                case 100:\n                  _context5.next = 102;\n                  return onOperation === null || onOperation === void 0 ? void 0 : onOperation(ctx, message, execArgs, operationResult);\n                case 102:\n                  maybeResult = _context5.sent;\n                  if (maybeResult) operationResult = maybeResult;\n                  if (!isAsyncIterable(operationResult)) {\n                    _context5.next = 138;\n                    break;\n                  }\n                  if (id in ctx.subscriptions) {\n                    _context5.next = 109;\n                    break;\n                  }\n                  // subscription was completed/canceled before the operation settled\n                  if (isAsyncGenerator(operationResult)) operationResult.return(undefined);\n                  _context5.next = 136;\n                  break;\n                case 109:\n                  ctx.subscriptions[id] = operationResult;\n                  _context5.prev = 110;\n                  operationResult_1 = __asyncValues(operationResult);\n                case 112:\n                  _context5.next = 114;\n                  return operationResult_1.next();\n                case 114:\n                  operationResult_1_1 = _context5.sent;\n                  if (operationResult_1_1.done) {\n                    _context5.next = 121;\n                    break;\n                  }\n                  result = operationResult_1_1.value;\n                  _context5.next = 119;\n                  return emit.next(result, execArgs);\n                case 119:\n                  _context5.next = 112;\n                  break;\n                case 121:\n                  _context5.next = 126;\n                  break;\n                case 123:\n                  _context5.prev = 123;\n                  _context5.t8 = _context5[\"catch\"](110);\n                  e_1 = {\n                    error: _context5.t8\n                  };\n                case 126:\n                  _context5.prev = 126;\n                  _context5.prev = 127;\n                  if (!(operationResult_1_1 && !operationResult_1_1.done && (_a = operationResult_1.return))) {\n                    _context5.next = 131;\n                    break;\n                  }\n                  _context5.next = 131;\n                  return _a.call(operationResult_1);\n                case 131:\n                  _context5.prev = 131;\n                  if (!e_1) {\n                    _context5.next = 134;\n                    break;\n                  }\n                  throw e_1.error;\n                case 134:\n                  return _context5.finish(131);\n                case 135:\n                  return _context5.finish(126);\n                case 136:\n                  _context5.next = 141;\n                  break;\n                case 138:\n                  if (!(id in ctx.subscriptions)) {\n                    _context5.next = 141;\n                    break;\n                  }\n                  _context5.next = 141;\n                  return emit.next(operationResult, execArgs);\n                case 141:\n                  _context5.next = 143;\n                  return emit.complete(id in ctx.subscriptions);\n                case 143:\n                  _context5.prev = 143;\n                  // whatever happens to the subscription, we finally want to get rid of the reservation\n                  delete ctx.subscriptions[id];\n                  return _context5.finish(143);\n                case 146:\n                  return _context5.abrupt(\"return\");\n                case 147:\n                  subscription = ctx.subscriptions[message.id];\n                  delete ctx.subscriptions[message.id]; // deleting the subscription means no further activity should take place\n                  if (!isAsyncGenerator(subscription)) {\n                    _context5.next = 152;\n                    break;\n                  }\n                  _context5.next = 152;\n                  return subscription.return(undefined);\n                case 152:\n                  return _context5.abrupt(\"return\");\n                case 153:\n                  throw new Error(\"Unexpected message of type \".concat(message.type, \" received\"));\n                case 154:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, null, [[0, 4], [40,, 143, 146], [110, 123, 126, 136], [127,, 131, 135]]);\n        }));\n        function onMessage(_x3) {\n          return _onMessage.apply(this, arguments);\n        }\n        return onMessage;\n      }());\n      // wait for close, cleanup and the disconnect callback\n      return /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(code, reason) {\n          var _i, _Object$values, sub;\n          return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  if (connectionInitWait) clearTimeout(connectionInitWait);\n                  _i = 0, _Object$values = Object.values(ctx.subscriptions);\n                case 2:\n                  if (!(_i < _Object$values.length)) {\n                    _context6.next = 10;\n                    break;\n                  }\n                  sub = _Object$values[_i];\n                  if (!isAsyncGenerator(sub)) {\n                    _context6.next = 7;\n                    break;\n                  }\n                  _context6.next = 7;\n                  return sub.return(undefined);\n                case 7:\n                  _i++;\n                  _context6.next = 2;\n                  break;\n                case 10:\n                  if (!ctx.acknowledged) {\n                    _context6.next = 13;\n                    break;\n                  }\n                  _context6.next = 13;\n                  return onDisconnect === null || onDisconnect === void 0 ? void 0 : onDisconnect(ctx, code, reason);\n                case 13:\n                  _context6.next = 15;\n                  return onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason);\n                case 15:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6);\n        }));\n        return function (_x8, _x9) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n    }\n  };\n}\n/**\n * Helper utility for choosing the \"graphql-transport-ws\" subprotocol from\n * a set of WebSocket subprotocols.\n *\n * Accepts a set of already extracted WebSocket subprotocols or the raw\n * Sec-WebSocket-Protocol header value. In either case, if the right\n * protocol appears, it will be returned.\n *\n * By specification, the server should not provide a value with Sec-WebSocket-Protocol\n * if it does not agree with client's subprotocols. The client has a responsibility\n * to handle the connection afterwards.\n *\n * @category Server\n */\nexport function handleProtocols(protocols) {\n  switch (true) {\n    case protocols instanceof Set && protocols.has(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n    case Array.isArray(protocols) && protocols.includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n    case typeof protocols === 'string' && protocols.split(',').map(function (p) {\n      return p.trim();\n    }).includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n      return GRAPHQL_TRANSPORT_WS_PROTOCOL;\n    default:\n      return false;\n  }\n}","map":{"version":3,"names":["__asyncValues","o","Symbol","asyncIterator","TypeError","m","i","call","__values","iterator","verb","n","v","Promise","resolve","reject","settle","done","value","d","then","parse","validate","graphqlValidate","execute","graphqlExecute","subscribe","graphqlSubscribe","getOperationAST","GraphQLError","GRAPHQL_TRANSPORT_WS_PROTOCOL","CloseCode","MessageType","stringifyMessage","parseMessage","isObject","isAsyncGenerator","isAsyncIterable","areGraphQLErrors","makeServer","options","schema","context","roots","connectionInitWaitTimeout","onConnect","onDisconnect","onClose","onSubscribe","onOperation","onNext","onError","onComplete","reviver","jsonMessageReviver","replacer","jsonMessageReplacer","opened","socket","extra","ctx","connectionInitReceived","acknowledged","subscriptions","protocol","close","SubprotocolNotAcceptable","code","reason","connectionInitWait","isFinite","setTimeout","ConnectionInitialisationTimeout","onMessage","data","message","BadRequest","type","ConnectionInit","Ping","Pong","Subscribe","Complete","TooManyInitialisationRequests","payload","connectionParams","permittedOrPayload","Forbidden","send","ConnectionAck","onPing","_b","onPong","Unauthorized","id","SubscriberAlreadyExists","emit","next","result","args","nextMessage","Next","maybeResult","Object","assign","error","errors","errorMessage","Error","maybeErrors","complete","notifyClient","completeMessage","maybeExecArgsOrErrors","Array","isArray","execArgs","operationName","document","query","variableValues","variables","validationErrors","length","operationAST","rootValue","operation","contextValue","operationResult","return","undefined","operationResult_1","operationResult_1_1","e_1","_a","subscription","clearTimeout","values","sub","handleProtocols","protocols","Set","has","includes","split","map","p","trim"],"sources":["C:/Users/Alias/weboldal/web-login/node_modules/graphql-ws/lib/server.mjs"],"sourcesContent":["/**\n *\n * server\n *\n */\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nimport { parse, validate as graphqlValidate, execute as graphqlExecute, subscribe as graphqlSubscribe, getOperationAST, GraphQLError, } from 'graphql';\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, stringifyMessage, parseMessage, } from './common.mjs';\nimport { isObject, isAsyncGenerator, isAsyncIterable, areGraphQLErrors, } from './utils.mjs';\n/**\n * Makes a Protocol complient WebSocket GraphQL server. The server\n * is actually an API which is to be used with your favourite WebSocket\n * server library!\n *\n * Read more about the Protocol in the PROTOCOL.md documentation file.\n *\n * @category Server\n */\nexport function makeServer(options) {\n    const { schema, context, roots, validate, execute, subscribe, connectionInitWaitTimeout = 3000, // 3 seconds\n    onConnect, onDisconnect, onClose, onSubscribe, onOperation, onNext, onError, onComplete, jsonMessageReviver: reviver, jsonMessageReplacer: replacer, } = options;\n    return {\n        opened(socket, extra) {\n            const ctx = {\n                connectionInitReceived: false,\n                acknowledged: false,\n                subscriptions: {},\n                extra,\n            };\n            if (socket.protocol !== GRAPHQL_TRANSPORT_WS_PROTOCOL) {\n                socket.close(CloseCode.SubprotocolNotAcceptable, 'Subprotocol not acceptable');\n                return async (code, reason) => {\n                    /* nothing was set up, just notify the closure */\n                    await (onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason));\n                };\n            }\n            // kick the client off (close socket) if the connection has\n            // not been initialised after the specified wait timeout\n            const connectionInitWait = connectionInitWaitTimeout > 0 && isFinite(connectionInitWaitTimeout)\n                ? setTimeout(() => {\n                    if (!ctx.connectionInitReceived)\n                        socket.close(CloseCode.ConnectionInitialisationTimeout, 'Connection initialisation timeout');\n                }, connectionInitWaitTimeout)\n                : null;\n            socket.onMessage(async function onMessage(data) {\n                var e_1, _a;\n                var _b;\n                let message;\n                try {\n                    message = parseMessage(data, reviver);\n                }\n                catch (err) {\n                    return socket.close(CloseCode.BadRequest, 'Invalid message received');\n                }\n                switch (message.type) {\n                    case MessageType.ConnectionInit: {\n                        if (ctx.connectionInitReceived)\n                            return socket.close(CloseCode.TooManyInitialisationRequests, 'Too many initialisation requests');\n                        // @ts-expect-error: I can write\n                        ctx.connectionInitReceived = true;\n                        if (isObject(message.payload))\n                            // @ts-expect-error: I can write\n                            ctx.connectionParams = message.payload;\n                        const permittedOrPayload = await (onConnect === null || onConnect === void 0 ? void 0 : onConnect(ctx));\n                        if (permittedOrPayload === false)\n                            return socket.close(CloseCode.Forbidden, 'Forbidden');\n                        await socket.send(stringifyMessage(isObject(permittedOrPayload)\n                            ? {\n                                type: MessageType.ConnectionAck,\n                                payload: permittedOrPayload,\n                            }\n                            : {\n                                type: MessageType.ConnectionAck,\n                                // payload is completely absent if not provided\n                            }, replacer));\n                        // @ts-expect-error: I can write\n                        ctx.acknowledged = true;\n                        return;\n                    }\n                    case MessageType.Ping: {\n                        if (socket.onPing)\n                            // if the onPing listener is registered, automatic pong is disabled\n                            return await socket.onPing(message.payload);\n                        await socket.send(stringifyMessage(message.payload\n                            ? { type: MessageType.Pong, payload: message.payload }\n                            : {\n                                type: MessageType.Pong,\n                                // payload is completely absent if not provided\n                            }));\n                        return;\n                    }\n                    case MessageType.Pong:\n                        return await ((_b = socket.onPong) === null || _b === void 0 ? void 0 : _b.call(socket, message.payload));\n                    case MessageType.Subscribe: {\n                        if (!ctx.acknowledged)\n                            return socket.close(CloseCode.Unauthorized, 'Unauthorized');\n                        const { id, payload } = message;\n                        if (id in ctx.subscriptions)\n                            return socket.close(CloseCode.SubscriberAlreadyExists, `Subscriber for ${id} already exists`);\n                        // if this turns out to be a streaming operation, the subscription value\n                        // will change to an `AsyncIterable`, otherwise it will stay as is\n                        ctx.subscriptions[id] = null;\n                        const emit = {\n                            next: async (result, args) => {\n                                let nextMessage = {\n                                    id,\n                                    type: MessageType.Next,\n                                    payload: result,\n                                };\n                                const maybeResult = await (onNext === null || onNext === void 0 ? void 0 : onNext(ctx, nextMessage, args, result));\n                                if (maybeResult)\n                                    nextMessage = Object.assign(Object.assign({}, nextMessage), { payload: maybeResult });\n                                await socket.send(stringifyMessage(nextMessage, replacer));\n                            },\n                            error: async (errors) => {\n                                let errorMessage = {\n                                    id,\n                                    type: MessageType.Error,\n                                    payload: errors,\n                                };\n                                const maybeErrors = await (onError === null || onError === void 0 ? void 0 : onError(ctx, errorMessage, errors));\n                                if (maybeErrors)\n                                    errorMessage = Object.assign(Object.assign({}, errorMessage), { payload: maybeErrors });\n                                await socket.send(stringifyMessage(errorMessage, replacer));\n                            },\n                            complete: async (notifyClient) => {\n                                const completeMessage = {\n                                    id,\n                                    type: MessageType.Complete,\n                                };\n                                await (onComplete === null || onComplete === void 0 ? void 0 : onComplete(ctx, completeMessage));\n                                if (notifyClient)\n                                    await socket.send(stringifyMessage(completeMessage, replacer));\n                            },\n                        };\n                        try {\n                            let execArgs;\n                            const maybeExecArgsOrErrors = await (onSubscribe === null || onSubscribe === void 0 ? void 0 : onSubscribe(ctx, message));\n                            if (maybeExecArgsOrErrors) {\n                                if (areGraphQLErrors(maybeExecArgsOrErrors))\n                                    return await emit.error(maybeExecArgsOrErrors);\n                                else if (Array.isArray(maybeExecArgsOrErrors))\n                                    throw new Error('Invalid return value from onSubscribe hook, expected an array of GraphQLError objects');\n                                // not errors, is exec args\n                                execArgs = maybeExecArgsOrErrors;\n                            }\n                            else {\n                                // you either provide a schema dynamically through\n                                // `onSubscribe` or you set one up during the server setup\n                                if (!schema)\n                                    throw new Error('The GraphQL schema is not provided');\n                                const args = {\n                                    operationName: payload.operationName,\n                                    document: parse(payload.query),\n                                    variableValues: payload.variables,\n                                };\n                                execArgs = Object.assign(Object.assign({}, args), { schema: typeof schema === 'function'\n                                        ? await schema(ctx, message, args)\n                                        : schema });\n                                const validationErrors = (validate !== null && validate !== void 0 ? validate : graphqlValidate)(execArgs.schema, execArgs.document);\n                                if (validationErrors.length > 0)\n                                    return await emit.error(validationErrors);\n                            }\n                            const operationAST = getOperationAST(execArgs.document, execArgs.operationName);\n                            if (!operationAST)\n                                return await emit.error([\n                                    new GraphQLError('Unable to identify operation'),\n                                ]);\n                            // if `onSubscribe` didnt specify a rootValue, inject one\n                            if (!('rootValue' in execArgs))\n                                execArgs.rootValue = roots === null || roots === void 0 ? void 0 : roots[operationAST.operation];\n                            // if `onSubscribe` didn't specify a context, inject one\n                            if (!('contextValue' in execArgs))\n                                execArgs.contextValue =\n                                    typeof context === 'function'\n                                        ? await context(ctx, message, execArgs)\n                                        : context;\n                            // the execution arguments have been prepared\n                            // perform the operation and act accordingly\n                            let operationResult;\n                            if (operationAST.operation === 'subscription')\n                                operationResult = await (subscribe !== null && subscribe !== void 0 ? subscribe : graphqlSubscribe)(execArgs);\n                            // operation === 'query' || 'mutation'\n                            else\n                                operationResult = await (execute !== null && execute !== void 0 ? execute : graphqlExecute)(execArgs);\n                            const maybeResult = await (onOperation === null || onOperation === void 0 ? void 0 : onOperation(ctx, message, execArgs, operationResult));\n                            if (maybeResult)\n                                operationResult = maybeResult;\n                            if (isAsyncIterable(operationResult)) {\n                                /** multiple emitted results */\n                                if (!(id in ctx.subscriptions)) {\n                                    // subscription was completed/canceled before the operation settled\n                                    if (isAsyncGenerator(operationResult))\n                                        operationResult.return(undefined);\n                                }\n                                else {\n                                    ctx.subscriptions[id] = operationResult;\n                                    try {\n                                        for (var operationResult_1 = __asyncValues(operationResult), operationResult_1_1; operationResult_1_1 = await operationResult_1.next(), !operationResult_1_1.done;) {\n                                            const result = operationResult_1_1.value;\n                                            await emit.next(result, execArgs);\n                                        }\n                                    }\n                                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                                    finally {\n                                        try {\n                                            if (operationResult_1_1 && !operationResult_1_1.done && (_a = operationResult_1.return)) await _a.call(operationResult_1);\n                                        }\n                                        finally { if (e_1) throw e_1.error; }\n                                    }\n                                }\n                            }\n                            else {\n                                /** single emitted result */\n                                // if the client completed the subscription before the single result\n                                // became available, he effectively canceled it and no data should be sent\n                                if (id in ctx.subscriptions)\n                                    await emit.next(operationResult, execArgs);\n                            }\n                            // lack of subscription at this point indicates that the client\n                            // completed the subscription, he doesnt need to be reminded\n                            await emit.complete(id in ctx.subscriptions);\n                        }\n                        finally {\n                            // whatever happens to the subscription, we finally want to get rid of the reservation\n                            delete ctx.subscriptions[id];\n                        }\n                        return;\n                    }\n                    case MessageType.Complete: {\n                        const subscription = ctx.subscriptions[message.id];\n                        delete ctx.subscriptions[message.id]; // deleting the subscription means no further activity should take place\n                        if (isAsyncGenerator(subscription))\n                            await subscription.return(undefined);\n                        return;\n                    }\n                    default:\n                        throw new Error(`Unexpected message of type ${message.type} received`);\n                }\n            });\n            // wait for close, cleanup and the disconnect callback\n            return async (code, reason) => {\n                if (connectionInitWait)\n                    clearTimeout(connectionInitWait);\n                for (const sub of Object.values(ctx.subscriptions)) {\n                    if (isAsyncGenerator(sub))\n                        await sub.return(undefined);\n                }\n                if (ctx.acknowledged)\n                    await (onDisconnect === null || onDisconnect === void 0 ? void 0 : onDisconnect(ctx, code, reason));\n                await (onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason));\n            };\n        },\n    };\n}\n/**\n * Helper utility for choosing the \"graphql-transport-ws\" subprotocol from\n * a set of WebSocket subprotocols.\n *\n * Accepts a set of already extracted WebSocket subprotocols or the raw\n * Sec-WebSocket-Protocol header value. In either case, if the right\n * protocol appears, it will be returned.\n *\n * By specification, the server should not provide a value with Sec-WebSocket-Protocol\n * if it does not agree with client's subprotocols. The client has a responsibility\n * to handle the connection afterwards.\n *\n * @category Server\n */\nexport function handleProtocols(protocols) {\n    switch (true) {\n        case protocols instanceof Set &&\n            protocols.has(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n        case Array.isArray(protocols) &&\n            protocols.includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n        case typeof protocols === 'string' &&\n            protocols\n                .split(',')\n                .map((p) => p.trim())\n                .includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n            return GRAPHQL_TRANSPORT_WS_PROTOCOL;\n        default:\n            return false;\n    }\n}\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA,IAAIA,aAAa,GAAI,IAAI,IAAI,IAAI,CAACA,aAAa,IAAK,UAAUC,CAAC,EAAE;EAC7D,IAAI,CAACC,MAAM,CAACC,aAAa,EAAE,MAAM,IAAIC,SAAS,CAAC,sCAAsC,CAAC;EACtF,IAAIC,CAAC,GAAGJ,CAAC,CAACC,MAAM,CAACC,aAAa,CAAC;IAAEG,CAAC;EAClC,OAAOD,CAAC,GAAGA,CAAC,CAACE,IAAI,CAACN,CAAC,CAAC,IAAIA,CAAC,GAAG,OAAOO,QAAQ,KAAK,UAAU,GAAGA,QAAQ,CAACP,CAAC,CAAC,GAAGA,CAAC,CAACC,MAAM,CAACO,QAAQ,CAAC,EAAE,EAAEH,CAAC,GAAG,CAAC,CAAC,EAAEI,IAAI,CAAC,MAAM,CAAC,EAAEA,IAAI,CAAC,OAAO,CAAC,EAAEA,IAAI,CAAC,QAAQ,CAAC,EAAEJ,CAAC,CAACJ,MAAM,CAACC,aAAa,CAAC,GAAG,YAAY;IAAE,OAAO,IAAI;EAAE,CAAC,EAAEG,CAAC,CAAC;EAChN,SAASI,IAAI,CAACC,CAAC,EAAE;IAAEL,CAAC,CAACK,CAAC,CAAC,GAAGV,CAAC,CAACU,CAAC,CAAC,IAAI,UAAUC,CAAC,EAAE;MAAE,OAAO,IAAIC,OAAO,CAAC,UAAUC,OAAO,EAAEC,MAAM,EAAE;QAAEH,CAAC,GAAGX,CAAC,CAACU,CAAC,CAAC,CAACC,CAAC,CAAC,EAAEI,MAAM,CAACF,OAAO,EAAEC,MAAM,EAAEH,CAAC,CAACK,IAAI,EAAEL,CAAC,CAACM,KAAK,CAAC;MAAE,CAAC,CAAC;IAAE,CAAC;EAAE;EAC/J,SAASF,MAAM,CAACF,OAAO,EAAEC,MAAM,EAAEI,CAAC,EAAEP,CAAC,EAAE;IAAEC,OAAO,CAACC,OAAO,CAACF,CAAC,CAAC,CAACQ,IAAI,CAAC,UAASR,CAAC,EAAE;MAAEE,OAAO,CAAC;QAAEI,KAAK,EAAEN,CAAC;QAAEK,IAAI,EAAEE;MAAE,CAAC,CAAC;IAAE,CAAC,EAAEJ,MAAM,CAAC;EAAE;AAC/H,CAAC;AACD,SAASM,KAAK,EAAEC,QAAQ,IAAIC,eAAe,EAAEC,OAAO,IAAIC,cAAc,EAAEC,SAAS,IAAIC,gBAAgB,EAAEC,eAAe,EAAEC,YAAY,QAAS,SAAS;AACtJ,SAASC,6BAA6B,EAAEC,SAAS,EAAEC,WAAW,EAAEC,gBAAgB,EAAEC,YAAY,QAAS,cAAc;AACrH,SAASC,QAAQ,EAAEC,gBAAgB,EAAEC,eAAe,EAAEC,gBAAgB,QAAS,aAAa;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,UAAU,CAACC,OAAO,EAAE;EAChC,IAAQC,MAAM,GAC2ID,OAAO,CADxJC,MAAM;IAAEC,OAAO,GACkIF,OAAO,CADhJE,OAAO;IAAEC,KAAK,GAC2HH,OAAO,CADvIG,KAAK;IAAErB,QAAQ,GACiHkB,OAAO,CADhIlB,QAAQ;IAAEE,OAAO,GACwGgB,OAAO,CADtHhB,OAAO;IAAEE,SAAS,GAC6Fc,OAAO,CAD7Gd,SAAS;IAAA,wBAC6Fc,OAAO,CADlGI,yBAAyB;IAAzBA,yBAAyB,sCAAG,IAAI;IAC9FC,SAAS,GAAgJL,OAAO,CAAhKK,SAAS;IAAEC,YAAY,GAAkIN,OAAO,CAArJM,YAAY;IAAEC,OAAO,GAAyHP,OAAO,CAAvIO,OAAO;IAAEC,WAAW,GAA4GR,OAAO,CAA9HQ,WAAW;IAAEC,WAAW,GAA+FT,OAAO,CAAjHS,WAAW;IAAEC,MAAM,GAAuFV,OAAO,CAApGU,MAAM;IAAEC,OAAO,GAA8EX,OAAO,CAA5FW,OAAO;IAAEC,UAAU,GAAkEZ,OAAO,CAAnFY,UAAU;IAAsBC,OAAO,GAAqCb,OAAO,CAAvEc,kBAAkB;IAAgCC,QAAQ,GAAMf,OAAO,CAA1CgB,mBAAmB;EACzI,OAAO;IACHC,MAAM,kBAACC,MAAM,EAAEC,KAAK,EAAE;MAClB,IAAMC,GAAG,GAAG;QACRC,sBAAsB,EAAE,KAAK;QAC7BC,YAAY,EAAE,KAAK;QACnBC,aAAa,EAAE,CAAC,CAAC;QACjBJ,KAAK,EAALA;MACJ,CAAC;MACD,IAAID,MAAM,CAACM,QAAQ,KAAKlC,6BAA6B,EAAE;QACnD4B,MAAM,CAACO,KAAK,CAAClC,SAAS,CAACmC,wBAAwB,EAAE,4BAA4B,CAAC;QAC9E;UAAA,sEAAO,iBAAOC,IAAI,EAAEC,MAAM;YAAA;cAAA;gBAAA;kBAAA;oBAAA;oBAAA,OAEfrB,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACa,GAAG,EAAEO,IAAI,EAAEC,MAAM,CAAC;kBAAA;kBAAA;oBAAA;gBAAA;cAAA;YAAA;UAAA,CACtF;UAAA;YAAA;UAAA;QAAA;MACL;MACA;MACA;MACA,IAAMC,kBAAkB,GAAGzB,yBAAyB,GAAG,CAAC,IAAI0B,QAAQ,CAAC1B,yBAAyB,CAAC,GACzF2B,UAAU,CAAC,YAAM;QACf,IAAI,CAACX,GAAG,CAACC,sBAAsB,EAC3BH,MAAM,CAACO,KAAK,CAAClC,SAAS,CAACyC,+BAA+B,EAAE,mCAAmC,CAAC;MACpG,CAAC,EAAE5B,yBAAyB,CAAC,GAC3B,IAAI;MACVc,MAAM,CAACe,SAAS;QAAA,4EAAC,kBAAyBC,IAAI;UAAA;UAAA;YAAA;cAAA;gBAAA;kBAAA;kBAKtCC,OAAO,GAAGzC,YAAY,CAACwC,IAAI,EAAErB,OAAO,CAAC;kBAAC;kBAAA;gBAAA;kBAAA;kBAAA;kBAAA,kCAG/BK,MAAM,CAACO,KAAK,CAAClC,SAAS,CAAC6C,UAAU,EAAE,0BAA0B,CAAC;gBAAA;kBAAA,eAEjED,OAAO,CAACE,IAAI;kBAAA,kCACX7C,WAAW,CAAC8C,cAAc,yBAwB1B9C,WAAW,CAAC+C,IAAI,yBAYhB/C,WAAW,CAACgD,IAAI,yBAEhBhD,WAAW,CAACiD,SAAS,yBAwIrBjD,WAAW,CAACkD,QAAQ;kBAAA;gBAAA;kBAAA,KA7KjBtB,GAAG,CAACC,sBAAsB;oBAAA;oBAAA;kBAAA;kBAAA,kCACnBH,MAAM,CAACO,KAAK,CAAClC,SAAS,CAACoD,6BAA6B,EAAE,kCAAkC,CAAC;gBAAA;kBACpG;kBACAvB,GAAG,CAACC,sBAAsB,GAAG,IAAI;kBACjC,IAAI1B,QAAQ,CAACwC,OAAO,CAACS,OAAO,CAAC;oBACzB;oBACAxB,GAAG,CAACyB,gBAAgB,GAAGV,OAAO,CAACS,OAAO;kBAAC;kBAAA,OACTvC,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACe,GAAG,CAAC;gBAAA;kBAAhG0B,kBAAkB;kBAAA,MACpBA,kBAAkB,KAAK,KAAK;oBAAA;oBAAA;kBAAA;kBAAA,kCACrB5B,MAAM,CAACO,KAAK,CAAClC,SAAS,CAACwD,SAAS,EAAE,WAAW,CAAC;gBAAA;kBAAA;kBAAA,OACnD7B,MAAM,CAAC8B,IAAI,CAACvD,gBAAgB,CAACE,QAAQ,CAACmD,kBAAkB,CAAC,GACzD;oBACET,IAAI,EAAE7C,WAAW,CAACyD,aAAa;oBAC/BL,OAAO,EAAEE;kBACb,CAAC,GACC;oBACET,IAAI,EAAE7C,WAAW,CAACyD;oBAClB;kBACJ,CAAC,EAAElC,QAAQ,CAAC,CAAC;gBAAA;kBACjB;kBACAK,GAAG,CAACE,YAAY,GAAG,IAAI;kBAAC;gBAAA;kBAAA,KAIpBJ,MAAM,CAACgC,MAAM;oBAAA;oBAAA;kBAAA;kBAAA;kBAAA,OAEAhC,MAAM,CAACgC,MAAM,CAACf,OAAO,CAACS,OAAO,CAAC;gBAAA;kBAAA;gBAAA;kBAAA;kBAAA,OACzC1B,MAAM,CAAC8B,IAAI,CAACvD,gBAAgB,CAAC0C,OAAO,CAACS,OAAO,GAC5C;oBAAEP,IAAI,EAAE7C,WAAW,CAACgD,IAAI;oBAAEI,OAAO,EAAET,OAAO,CAACS;kBAAQ,CAAC,GACpD;oBACEP,IAAI,EAAE7C,WAAW,CAACgD;oBAClB;kBACJ,CAAC,CAAC,CAAC;gBAAA;kBAAA;gBAAA;kBAAA;kBAAA,OAIO,CAACW,EAAE,GAAGjC,MAAM,CAACkC,MAAM,MAAM,IAAI,IAAID,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACpF,IAAI,CAACmD,MAAM,EAAEiB,OAAO,CAACS,OAAO,CAAC;gBAAA;kBAAA;gBAAA;kBAAA,IAEnGxB,GAAG,CAACE,YAAY;oBAAA;oBAAA;kBAAA;kBAAA,kCACVJ,MAAM,CAACO,KAAK,CAAClC,SAAS,CAAC8D,YAAY,EAAE,cAAc,CAAC;gBAAA;kBAAA,WACvClB,OAAO,EAAvBmB,EAAE,YAAFA,EAAE,EAAEV,OAAO,YAAPA,OAAO;kBAAA,MACfU,EAAE,IAAIlC,GAAG,CAACG,aAAa;oBAAA;oBAAA;kBAAA;kBAAA,kCAChBL,MAAM,CAACO,KAAK,CAAClC,SAAS,CAACgE,uBAAuB,2BAAoBD,EAAE,qBAAkB;gBAAA;kBACjG;kBACA;kBACAlC,GAAG,CAACG,aAAa,CAAC+B,EAAE,CAAC,GAAG,IAAI;kBACtBE,IAAI,GAAG;oBACTC,IAAI;sBAAA,uEAAE,kBAAOC,MAAM,EAAEC,IAAI;wBAAA;wBAAA;0BAAA;4BAAA;8BAAA;gCACjBC,WAAW,GAAG;kCACdN,EAAE,EAAFA,EAAE;kCACFjB,IAAI,EAAE7C,WAAW,CAACqE,IAAI;kCACtBjB,OAAO,EAAEc;gCACb,CAAC;gCAAA;gCAAA,OAC0BhD,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACU,GAAG,EAAEwC,WAAW,EAAED,IAAI,EAAED,MAAM,CAAC;8BAAA;gCAA3GI,WAAW;gCACjB,IAAIA,WAAW,EACXF,WAAW,GAAGG,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEJ,WAAW,CAAC,EAAE;kCAAEhB,OAAO,EAAEkB;gCAAY,CAAC,CAAC;gCAAC;gCAAA,OACpF5C,MAAM,CAAC8B,IAAI,CAACvD,gBAAgB,CAACmE,WAAW,EAAE7C,QAAQ,CAAC,CAAC;8BAAA;8BAAA;gCAAA;4BAAA;0BAAA;wBAAA;sBAAA,CAC7D;sBAAA;wBAAA;sBAAA;sBAAA;oBAAA;oBACDkD,KAAK;sBAAA,wEAAE,kBAAOC,MAAM;wBAAA;wBAAA;0BAAA;4BAAA;8BAAA;gCACZC,YAAY,GAAG;kCACfb,EAAE,EAAFA,EAAE;kCACFjB,IAAI,EAAE7C,WAAW,CAAC4E,KAAK;kCACvBxB,OAAO,EAAEsB;gCACb,CAAC;gCAAA;gCAAA,OAC0BvD,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACS,GAAG,EAAE+C,YAAY,EAAED,MAAM,CAAC;8BAAA;gCAAzGG,WAAW;gCACjB,IAAIA,WAAW,EACXF,YAAY,GAAGJ,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEG,YAAY,CAAC,EAAE;kCAAEvB,OAAO,EAAEyB;gCAAY,CAAC,CAAC;gCAAC;gCAAA,OACtFnD,MAAM,CAAC8B,IAAI,CAACvD,gBAAgB,CAAC0E,YAAY,EAAEpD,QAAQ,CAAC,CAAC;8BAAA;8BAAA;gCAAA;4BAAA;0BAAA;wBAAA;sBAAA,CAC9D;sBAAA;wBAAA;sBAAA;sBAAA;oBAAA;oBACDuD,QAAQ;sBAAA,2EAAE,kBAAOC,YAAY;wBAAA;wBAAA;0BAAA;4BAAA;8BAAA;gCACnBC,eAAe,GAAG;kCACpBlB,EAAE,EAAFA,EAAE;kCACFjB,IAAI,EAAE7C,WAAW,CAACkD;gCACtB,CAAC;gCAAA;gCAAA,OACM9B,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,UAAU,CAACQ,GAAG,EAAEoD,eAAe,CAAC;8BAAA;gCAAA,KAC3FD,YAAY;kCAAA;kCAAA;gCAAA;gCAAA;gCAAA,OACNrD,MAAM,CAAC8B,IAAI,CAACvD,gBAAgB,CAAC+E,eAAe,EAAEzD,QAAQ,CAAC,CAAC;8BAAA;8BAAA;gCAAA;4BAAA;0BAAA;wBAAA;sBAAA,CACrE;sBAAA;wBAAA;sBAAA;sBAAA;oBAAA;kBACL,CAAC;kBAAA;kBAAA;kBAAA,OAGwCP,WAAW,KAAK,IAAI,IAAIA,WAAW,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,WAAW,CAACY,GAAG,EAAEe,OAAO,CAAC;gBAAA;kBAAlHsC,qBAAqB;kBAAA,KACvBA,qBAAqB;oBAAA;oBAAA;kBAAA;kBAAA,KACjB3E,gBAAgB,CAAC2E,qBAAqB,CAAC;oBAAA;oBAAA;kBAAA;kBAAA;kBAAA,OAC1BjB,IAAI,CAACS,KAAK,CAACQ,qBAAqB,CAAC;gBAAA;kBAAA;gBAAA;kBAAA,KACzCC,KAAK,CAACC,OAAO,CAACF,qBAAqB,CAAC;oBAAA;oBAAA;kBAAA;kBAAA,MACnC,IAAIL,KAAK,CAAC,uFAAuF,CAAC;gBAAA;kBAC5G;kBACAQ,QAAQ,GAAGH,qBAAqB;kBAAC;kBAAA;gBAAA;kBAAA,IAK5BxE,MAAM;oBAAA;oBAAA;kBAAA;kBAAA,MACD,IAAImE,KAAK,CAAC,oCAAoC,CAAC;gBAAA;kBACnDT,IAAI,GAAG;oBACTkB,aAAa,EAAEjC,OAAO,CAACiC,aAAa;oBACpCC,QAAQ,EAAEjG,KAAK,CAAC+D,OAAO,CAACmC,KAAK,CAAC;oBAC9BC,cAAc,EAAEpC,OAAO,CAACqC;kBAC5B,CAAC;kBAAA,eACUlB,MAAM;kBAAA,eAAQA,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEL,IAAI,CAAC;kBAAA,MAAY,OAAO1D,MAAM,KAAK,UAAU;oBAAA;oBAAA;kBAAA;kBAAA;kBAAA,OACxEA,MAAM,CAACmB,GAAG,EAAEe,OAAO,EAAEwB,IAAI,CAAC;gBAAA;kBAAA;kBAAA;kBAAA;gBAAA;kBAAA,eAChC1D,MAAM;gBAAA;kBAAA;kBAAA;oBAFoCA,MAAM;kBAAA;kBAA1D2E,QAAQ,gBAAUZ,MAAM;kBAGlBkB,gBAAgB,GAAG,CAACpG,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAGA,QAAQ,GAAGC,eAAe,EAAE6F,QAAQ,CAAC3E,MAAM,EAAE2E,QAAQ,CAACE,QAAQ,CAAC;kBAAA,MAChII,gBAAgB,CAACC,MAAM,GAAG,CAAC;oBAAA;oBAAA;kBAAA;kBAAA;kBAAA,OACd3B,IAAI,CAACS,KAAK,CAACiB,gBAAgB,CAAC;gBAAA;kBAAA;gBAAA;kBAE3CE,YAAY,GAAGhG,eAAe,CAACwF,QAAQ,CAACE,QAAQ,EAAEF,QAAQ,CAACC,aAAa,CAAC;kBAAA,IAC1EO,YAAY;oBAAA;oBAAA;kBAAA;kBAAA;kBAAA,OACA5B,IAAI,CAACS,KAAK,CAAC,CACpB,IAAI5E,YAAY,CAAC,8BAA8B,CAAC,CACnD,CAAC;gBAAA;kBAAA;gBAAA;kBACN;kBACA,IAAI,EAAE,WAAW,IAAIuF,QAAQ,CAAC,EAC1BA,QAAQ,CAACS,SAAS,GAAGlF,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAACiF,YAAY,CAACE,SAAS,CAAC;kBACpG;kBAAA,IACM,cAAc,IAAIV,QAAQ;oBAAA;oBAAA;kBAAA;kBAAA,MAExB,OAAO1E,OAAO,KAAK,UAAU;oBAAA;oBAAA;kBAAA;kBAAA;kBAAA,OACjBA,OAAO,CAACkB,GAAG,EAAEe,OAAO,EAAEyC,QAAQ,CAAC;gBAAA;kBAAA;kBAAA;kBAAA;gBAAA;kBAAA,eACrC1E,OAAO;gBAAA;kBAHjB0E,QAAQ,CAACW,YAAY;gBAAA;kBAAA,MAOrBH,YAAY,CAACE,SAAS,KAAK,cAAc;oBAAA;oBAAA;kBAAA;kBAAA;kBAAA,OACjB,CAACpG,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAGC,gBAAgB,EAAEyF,QAAQ,CAAC;gBAAA;kBAA7GY,eAAe;kBAAA;kBAAA;gBAAA;kBAAA;kBAAA,OAGS,CAACxG,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAGA,OAAO,GAAGC,cAAc,EAAE2F,QAAQ,CAAC;gBAAA;kBAArGY,eAAe;gBAAA;kBAAA;kBAAA,OACQ/E,WAAW,KAAK,IAAI,IAAIA,WAAW,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,WAAW,CAACW,GAAG,EAAEe,OAAO,EAAEyC,QAAQ,EAAEY,eAAe,CAAC;gBAAA;kBAAnI1B,WAAW;kBACjB,IAAIA,WAAW,EACX0B,eAAe,GAAG1B,WAAW;kBAAC,KAC9BjE,eAAe,CAAC2F,eAAe,CAAC;oBAAA;oBAAA;kBAAA;kBAAA,IAE1BlC,EAAE,IAAIlC,GAAG,CAACG,aAAa;oBAAA;oBAAA;kBAAA;kBACzB;kBACA,IAAI3B,gBAAgB,CAAC4F,eAAe,CAAC,EACjCA,eAAe,CAACC,MAAM,CAACC,SAAS,CAAC;kBAAC;kBAAA;gBAAA;kBAGtCtE,GAAG,CAACG,aAAa,CAAC+B,EAAE,CAAC,GAAGkC,eAAe;kBAAC;kBAE3BG,iBAAiB,GAAGnI,aAAa,CAACgI,eAAe,CAAC;gBAAA;kBAAA;kBAAA,OAAmDG,iBAAiB,CAAClC,IAAI,EAAE;gBAAA;kBAApDmC,mBAAmB;kBAAA,IAAoCA,mBAAmB,CAACnH,IAAI;oBAAA;oBAAA;kBAAA;kBACvJiF,MAAM,GAAGkC,mBAAmB,CAAClH,KAAK;kBAAA;kBAAA,OAClC8E,IAAI,CAACC,IAAI,CAACC,MAAM,EAAEkB,QAAQ,CAAC;gBAAA;kBAAA;kBAAA;gBAAA;kBAAA;kBAAA;gBAAA;kBAAA;kBAAA;kBAGzBiB,GAAG,GAAG;oBAAE5B,KAAK;kBAAQ,CAAC;gBAAC;kBAAA;kBAAA;kBAAA,MAG3B2B,mBAAmB,IAAI,CAACA,mBAAmB,CAACnH,IAAI,KAAKqH,EAAE,GAAGH,iBAAiB,CAACF,MAAM,CAAC;oBAAA;oBAAA;kBAAA;kBAAA;kBAAA,OAAQK,EAAE,CAAC/H,IAAI,CAAC4H,iBAAiB,CAAC;gBAAA;kBAAA;kBAAA,KAE/GE,GAAG;oBAAA;oBAAA;kBAAA;kBAAA,MAAQA,GAAG,CAAC5B,KAAK;gBAAA;kBAAA;gBAAA;kBAAA;gBAAA;kBAAA;kBAAA;gBAAA;kBAAA,MAQtCX,EAAE,IAAIlC,GAAG,CAACG,aAAa;oBAAA;oBAAA;kBAAA;kBAAA;kBAAA,OACjBiC,IAAI,CAACC,IAAI,CAAC+B,eAAe,EAAEZ,QAAQ,CAAC;gBAAA;kBAAA;kBAAA,OAI5CpB,IAAI,CAACc,QAAQ,CAAChB,EAAE,IAAIlC,GAAG,CAACG,aAAa,CAAC;gBAAA;kBAAA;kBAG5C;kBACA,OAAOH,GAAG,CAACG,aAAa,CAAC+B,EAAE,CAAC;kBAAC;gBAAA;kBAAA;gBAAA;kBAK3ByC,YAAY,GAAG3E,GAAG,CAACG,aAAa,CAACY,OAAO,CAACmB,EAAE,CAAC;kBAClD,OAAOlC,GAAG,CAACG,aAAa,CAACY,OAAO,CAACmB,EAAE,CAAC,CAAC,CAAC;kBAAA,KAClC1D,gBAAgB,CAACmG,YAAY,CAAC;oBAAA;oBAAA;kBAAA;kBAAA;kBAAA,OACxBA,YAAY,CAACN,MAAM,CAACC,SAAS,CAAC;gBAAA;kBAAA;gBAAA;kBAAA,MAIlC,IAAItB,KAAK,sCAA+BjC,OAAO,CAACE,IAAI,eAAY;gBAAA;gBAAA;kBAAA;cAAA;YAAA;UAAA;QAAA,CAEjF;QAAA,SAnM+BJ,SAAS;UAAA;QAAA;QAAA,OAATA,SAAS;MAAA,IAmMvC;MACF;MACA;QAAA,uEAAO,kBAAON,IAAI,EAAEC,MAAM;UAAA;UAAA;YAAA;cAAA;gBAAA;kBACtB,IAAIC,kBAAkB,EAClBmE,YAAY,CAACnE,kBAAkB,CAAC;kBAAC,yBACnBkC,MAAM,CAACkC,MAAM,CAAC7E,GAAG,CAACG,aAAa,CAAC;gBAAA;kBAAA;oBAAA;oBAAA;kBAAA;kBAAvC2E,GAAG;kBAAA,KACNtG,gBAAgB,CAACsG,GAAG,CAAC;oBAAA;oBAAA;kBAAA;kBAAA;kBAAA,OACfA,GAAG,CAACT,MAAM,CAACC,SAAS,CAAC;gBAAA;kBAAA;kBAAA;kBAAA;gBAAA;kBAAA,KAE/BtE,GAAG,CAACE,YAAY;oBAAA;oBAAA;kBAAA;kBAAA;kBAAA,OACThB,YAAY,KAAK,IAAI,IAAIA,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,CAACc,GAAG,EAAEO,IAAI,EAAEC,MAAM,CAAC;gBAAA;kBAAA;kBAAA,OAC/FrB,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACa,GAAG,EAAEO,IAAI,EAAEC,MAAM,CAAC;gBAAA;gBAAA;kBAAA;cAAA;YAAA;UAAA;QAAA,CACtF;QAAA;UAAA;QAAA;MAAA;IACL;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASuE,eAAe,CAACC,SAAS,EAAE;EACvC,QAAQ,IAAI;IACR,KAAKA,SAAS,YAAYC,GAAG,IACzBD,SAAS,CAACE,GAAG,CAAChH,6BAA6B,CAAC;IAChD,KAAKoF,KAAK,CAACC,OAAO,CAACyB,SAAS,CAAC,IACzBA,SAAS,CAACG,QAAQ,CAACjH,6BAA6B,CAAC;IACrD,KAAK,OAAO8G,SAAS,KAAK,QAAQ,IAC9BA,SAAS,CACJI,KAAK,CAAC,GAAG,CAAC,CACVC,GAAG,CAAC,UAACC,CAAC;MAAA,OAAKA,CAAC,CAACC,IAAI,EAAE;IAAA,EAAC,CACpBJ,QAAQ,CAACjH,6BAA6B,CAAC;MAC5C,OAAOA,6BAA6B;IACxC;MACI,OAAO,KAAK;EAAC;AAEzB"},"metadata":{},"sourceType":"module"}