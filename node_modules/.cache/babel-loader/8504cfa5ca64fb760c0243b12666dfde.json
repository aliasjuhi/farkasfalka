{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\Alias\\\\weboldal\\\\web-login\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\Alias\\\\weboldal\\\\web-login\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\Alias\\\\weboldal\\\\web-login\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _createClass from \"C:\\\\Users\\\\Alias\\\\weboldal\\\\web-login\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"C:\\\\Users\\\\Alias\\\\weboldal\\\\web-login\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\Alias\\\\weboldal\\\\web-login\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Alias\\\\weboldal\\\\web-login\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Alias\\\\weboldal\\\\web-login\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _wrapNativeSuper from \"C:\\\\Users\\\\Alias\\\\weboldal\\\\web-login\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/wrapNativeSuper\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  if (__getOwnPropSymbols) {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols(b)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return a;\n};\nvar __spreadProps = function __spreadProps(a, b) {\n  return __defProps(a, __getOwnPropDescs(b));\n};\nvar __objRest = function __objRest(source, exclude) {\n  var target = {};\n  for (var prop in source) {\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  }\n  if (source != null && __getOwnPropSymbols) {\n    var _iterator2 = _createForOfIteratorHelper(__getOwnPropSymbols(source)),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var prop = _step2.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  return target;\n};\nimport { createMachine, assign, send, interpret } from \"xstate\";\nimport axios from \"axios\";\nimport Cookies from \"js-cookie\";\nfunction utf8StringToBuffer(value) {\n  return new TextEncoder().encode(value);\n}\nfunction bufferToBase64URLString(buffer) {\n  var bytes = new Uint8Array(buffer);\n  var str = \"\";\n  var _iterator3 = _createForOfIteratorHelper(bytes),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var charCode = _step3.value;\n      str += String.fromCharCode(charCode);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  var base64String = btoa(str);\n  return base64String.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\nfunction base64URLStringToBuffer(base64URLString) {\n  var base64 = base64URLString.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  var padLength = (4 - base64.length % 4) % 4;\n  var padded = base64.padEnd(base64.length + padLength, \"=\");\n  var binary = atob(padded);\n  var buffer = new ArrayBuffer(binary.length);\n  var bytes = new Uint8Array(buffer);\n  for (var i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return buffer;\n}\nfunction browserSupportsWebAuthn() {\n  return (window === null || window === void 0 ? void 0 : window.PublicKeyCredential) !== void 0 && typeof window.PublicKeyCredential === \"function\";\n}\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n  var id = descriptor.id;\n  return __spreadProps(__spreadValues({}, descriptor), {\n    id: base64URLStringToBuffer(id),\n    transports: descriptor.transports\n  });\n}\nfunction isValidDomain(hostname) {\n  return hostname === \"localhost\" || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname);\n}\nvar WebAuthnError = /*#__PURE__*/function (_Error) {\n  _inherits(WebAuthnError, _Error);\n  function WebAuthnError(message) {\n    var _this;\n    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"WebAuthnError\";\n    _classCallCheck(this, WebAuthnError);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebAuthnError).call(this, message));\n    _this.name = name;\n    return _this;\n  }\n  return WebAuthnError;\n}(_wrapNativeSuper(Error));\nfunction identifyRegistrationError(_ref) {\n  var error = _ref.error,\n    options = _ref.options;\n  var _a, _b;\n  var publicKey = options.publicKey;\n  if (!publicKey) {\n    throw Error(\"options was missing required publicKey property\");\n  }\n  if (error.name === \"AbortError\") {\n    if (options.signal === new AbortController().signal) {\n      return new WebAuthnError(\"Registration ceremony was sent an abort signal\", \"AbortError\");\n    }\n  } else if (error.name === \"ConstraintError\") {\n    if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {\n      return new WebAuthnError(\"Discoverable credentials were required but no available authenticator supported it\", \"ConstraintError\");\n    } else if (((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === \"required\") {\n      return new WebAuthnError(\"User verification was required but no available authenticator supported it\", \"ConstraintError\");\n    }\n  } else if (error.name === \"InvalidStateError\") {\n    return new WebAuthnError(\"The authenticator was previously registered\", \"InvalidStateError\");\n  } else if (error.name === \"NotAllowedError\") {\n    return new WebAuthnError(\"User clicked cancel, or the registration ceremony timed out\", \"NotAllowedError\");\n  } else if (error.name === \"NotSupportedError\") {\n    var validPubKeyCredParams = publicKey.pubKeyCredParams.filter(function (param) {\n      return param.type === \"public-key\";\n    });\n    if (validPubKeyCredParams.length === 0) {\n      return new WebAuthnError('No entry in pubKeyCredParams was of type \"public-key\"', \"NotSupportedError\");\n    }\n    return new WebAuthnError(\"No available authenticator supported any of the specified pubKeyCredParams algorithms\", \"NotSupportedError\");\n  } else if (error.name === \"SecurityError\") {\n    var effectiveDomain = window.location.hostname;\n    if (!isValidDomain(effectiveDomain)) {\n      return new WebAuthnError(\"\".concat(window.location.hostname, \" is an invalid domain\"), \"SecurityError\");\n    } else if (publicKey.rp.id !== effectiveDomain) {\n      return new WebAuthnError(\"The RP ID \\\"\".concat(publicKey.rp.id, \"\\\" is invalid for this domain\"), \"SecurityError\");\n    }\n  } else if (error.name === \"TypeError\") {\n    if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n      return new WebAuthnError(\"User ID was not between 1 and 64 characters\", \"TypeError\");\n    }\n  } else if (error.name === \"UnknownError\") {\n    return new WebAuthnError(\"The authenticator was unable to process the specified options, or could not create a new credential\", \"UnknownError\");\n  }\n  return error;\n}\nvar WebAuthnAbortService = /*#__PURE__*/function () {\n  function WebAuthnAbortService() {\n    _classCallCheck(this, WebAuthnAbortService);\n  }\n  _createClass(WebAuthnAbortService, [{\n    key: \"createNewAbortSignal\",\n    value: function createNewAbortSignal() {\n      if (this.controller) {\n        this.controller.abort();\n      }\n      this.controller = new AbortController();\n      return this.controller.signal;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.controller = void 0;\n    }\n  }]);\n  return WebAuthnAbortService;\n}();\nvar webauthnAbortService = new WebAuthnAbortService();\nfunction startRegistration(_x) {\n  return _startRegistration.apply(this, arguments);\n}\nfunction _startRegistration() {\n  _startRegistration = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(creationOptionsJSON) {\n    var publicKey, options, credential, _credential, id, rawId, response, type, credentialJSON;\n    return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n      while (1) {\n        switch (_context17.prev = _context17.next) {\n          case 0:\n            if (browserSupportsWebAuthn()) {\n              _context17.next = 2;\n              break;\n            }\n            throw new Error(\"WebAuthn is not supported in this browser\");\n          case 2:\n            publicKey = __spreadProps(__spreadValues({}, creationOptionsJSON), {\n              challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n              user: __spreadProps(__spreadValues({}, creationOptionsJSON.user), {\n                id: utf8StringToBuffer(creationOptionsJSON.user.id)\n              }),\n              excludeCredentials: creationOptionsJSON.excludeCredentials.map(toPublicKeyCredentialDescriptor)\n            });\n            options = {\n              publicKey: publicKey\n            };\n            options.signal = webauthnAbortService.createNewAbortSignal();\n            _context17.prev = 5;\n            _context17.next = 8;\n            return navigator.credentials.create(options);\n          case 8:\n            credential = _context17.sent;\n            _context17.next = 14;\n            break;\n          case 11:\n            _context17.prev = 11;\n            _context17.t0 = _context17[\"catch\"](5);\n            throw identifyRegistrationError({\n              error: _context17.t0,\n              options: options\n            });\n          case 14:\n            _context17.prev = 14;\n            webauthnAbortService.reset();\n            return _context17.finish(14);\n          case 17:\n            if (credential) {\n              _context17.next = 19;\n              break;\n            }\n            throw new Error(\"Registration was not completed\");\n          case 19:\n            _credential = credential, id = _credential.id, rawId = _credential.rawId, response = _credential.response, type = _credential.type;\n            credentialJSON = {\n              id: id,\n              rawId: bufferToBase64URLString(rawId),\n              response: {\n                attestationObject: bufferToBase64URLString(response.attestationObject),\n                clientDataJSON: bufferToBase64URLString(response.clientDataJSON)\n              },\n              type: type,\n              clientExtensionResults: credential.getClientExtensionResults(),\n              authenticatorAttachment: credential.authenticatorAttachment\n            };\n            if (typeof response.getTransports === \"function\") {\n              credentialJSON.transports = response.getTransports();\n            }\n            return _context17.abrupt(\"return\", credentialJSON);\n          case 23:\n          case \"end\":\n            return _context17.stop();\n        }\n      }\n    }, _callee17, null, [[5, 11, 14, 17]]);\n  }));\n  return _startRegistration.apply(this, arguments);\n}\nfunction bufferToUTF8String(value) {\n  return new TextDecoder(\"utf-8\").decode(value);\n}\nfunction browserSupportsWebAuthnAutofill() {\n  return _browserSupportsWebAuthnAutofill.apply(this, arguments);\n}\nfunction _browserSupportsWebAuthnAutofill() {\n  _browserSupportsWebAuthnAutofill = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n    var globalPublicKeyCredential;\n    return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n      while (1) {\n        switch (_context18.prev = _context18.next) {\n          case 0:\n            if (!navigator.credentials.conditionalMediationSupported) {\n              _context18.next = 2;\n              break;\n            }\n            return _context18.abrupt(\"return\", true);\n          case 2:\n            globalPublicKeyCredential = window.PublicKeyCredential;\n            return _context18.abrupt(\"return\", globalPublicKeyCredential.isConditionalMediationAvailable !== void 0 && globalPublicKeyCredential.isConditionalMediationAvailable());\n          case 4:\n          case \"end\":\n            return _context18.stop();\n        }\n      }\n    }, _callee18);\n  }));\n  return _browserSupportsWebAuthnAutofill.apply(this, arguments);\n}\nfunction identifyAuthenticationError(_ref2) {\n  var error = _ref2.error,\n    options = _ref2.options;\n  var _a;\n  var publicKey = options.publicKey;\n  if (!publicKey) {\n    throw Error(\"options was missing required publicKey property\");\n  }\n  if (error.name === \"AbortError\") {\n    if (options.signal === new AbortController().signal) {\n      return new WebAuthnError(\"Authentication ceremony was sent an abort signal\", \"AbortError\");\n    }\n  } else if (error.name === \"NotAllowedError\") {\n    if ((_a = publicKey.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) {\n      return new WebAuthnError(\"No available authenticator recognized any of the allowed credentials\", \"NotAllowedError\");\n    }\n    return new WebAuthnError(\"User clicked cancel, or the authentication ceremony timed out\", \"NotAllowedError\");\n  } else if (error.name === \"SecurityError\") {\n    var effectiveDomain = window.location.hostname;\n    if (!isValidDomain(effectiveDomain)) {\n      return new WebAuthnError(\"\".concat(window.location.hostname, \" is an invalid domain\"), \"SecurityError\");\n    } else if (publicKey.rpId !== effectiveDomain) {\n      return new WebAuthnError(\"The RP ID \\\"\".concat(publicKey.rpId, \"\\\" is invalid for this domain\"), \"SecurityError\");\n    }\n  } else if (error.name === \"UnknownError\") {\n    return new WebAuthnError(\"The authenticator was unable to process the specified options, or could not create a new assertion signature\", \"UnknownError\");\n  }\n  return error;\n}\nfunction startAuthentication(_x2) {\n  return _startAuthentication.apply(this, arguments);\n}\nfunction _startAuthentication() {\n  _startAuthentication = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(requestOptionsJSON) {\n    var useBrowserAutofill,\n      _a,\n      _b,\n      allowCredentials,\n      publicKey,\n      options,\n      eligibleInputs,\n      credential,\n      _credential2,\n      id,\n      rawId,\n      response,\n      type,\n      userHandle,\n      _args19 = arguments;\n    return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n      while (1) {\n        switch (_context19.prev = _context19.next) {\n          case 0:\n            useBrowserAutofill = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : false;\n            if (browserSupportsWebAuthn()) {\n              _context19.next = 3;\n              break;\n            }\n            throw new Error(\"WebAuthn is not supported in this browser\");\n          case 3:\n            if (((_a = requestOptionsJSON.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) !== 0) {\n              allowCredentials = (_b = requestOptionsJSON.allowCredentials) === null || _b === void 0 ? void 0 : _b.map(toPublicKeyCredentialDescriptor);\n            }\n            publicKey = __spreadProps(__spreadValues({}, requestOptionsJSON), {\n              challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n              allowCredentials: allowCredentials\n            });\n            options = {};\n            if (!useBrowserAutofill) {\n              _context19.next = 16;\n              break;\n            }\n            _context19.next = 9;\n            return browserSupportsWebAuthnAutofill();\n          case 9:\n            if (_context19.sent) {\n              _context19.next = 11;\n              break;\n            }\n            throw Error(\"Browser does not support WebAuthn autofill\");\n          case 11:\n            eligibleInputs = document.querySelectorAll(\"input[autocomplete*='webauthn']\");\n            if (!(eligibleInputs.length < 1)) {\n              _context19.next = 14;\n              break;\n            }\n            throw Error('No <input> with `\"webauthn\"` in its `autocomplete` attribute was detected');\n          case 14:\n            options.mediation = \"conditional\";\n            publicKey.allowCredentials = [];\n          case 16:\n            options.publicKey = publicKey;\n            options.signal = webauthnAbortService.createNewAbortSignal();\n            _context19.prev = 18;\n            _context19.next = 21;\n            return navigator.credentials.get(options);\n          case 21:\n            credential = _context19.sent;\n            _context19.next = 27;\n            break;\n          case 24:\n            _context19.prev = 24;\n            _context19.t0 = _context19[\"catch\"](18);\n            throw identifyAuthenticationError({\n              error: _context19.t0,\n              options: options\n            });\n          case 27:\n            _context19.prev = 27;\n            webauthnAbortService.reset();\n            return _context19.finish(27);\n          case 30:\n            if (credential) {\n              _context19.next = 32;\n              break;\n            }\n            throw new Error(\"Authentication was not completed\");\n          case 32:\n            _credential2 = credential, id = _credential2.id, rawId = _credential2.rawId, response = _credential2.response, type = _credential2.type;\n            userHandle = void 0;\n            if (response.userHandle) {\n              userHandle = bufferToUTF8String(response.userHandle);\n            }\n            return _context19.abrupt(\"return\", {\n              id: id,\n              rawId: bufferToBase64URLString(rawId),\n              response: {\n                authenticatorData: bufferToBase64URLString(response.authenticatorData),\n                clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n                signature: bufferToBase64URLString(response.signature),\n                userHandle: userHandle\n              },\n              type: type,\n              clientExtensionResults: credential.getClientExtensionResults(),\n              authenticatorAttachment: credential.authenticatorAttachment\n            });\n          case 36:\n          case \"end\":\n            return _context19.stop();\n        }\n      }\n    }, _callee19, null, [[18, 24, 27, 30]]);\n  }));\n  return _startAuthentication.apply(this, arguments);\n}\nvar NHOST_REFRESH_TOKEN_KEY = \"nhostRefreshToken\";\nvar NHOST_JWT_EXPIRES_AT_KEY = \"nhostRefreshTokenExpiresAt\";\nvar MIN_PASSWORD_LENGTH = 3;\nvar TOKEN_REFRESH_MARGIN = 300;\nvar REFRESH_TOKEN_RETRY_INTERVAL = 5;\nvar REFRESH_TOKEN_RETRY_MAX_ATTEMPTS = 30;\nvar NETWORK_ERROR_CODE = 0;\nvar OTHER_ERROR_CODE = 1;\nvar VALIDATION_ERROR_CODE = 10;\nvar STATE_ERROR_CODE = 20;\nvar CodifiedError = /*#__PURE__*/function (_Error2) {\n  _inherits(CodifiedError, _Error2);\n  function CodifiedError(original) {\n    var _this2;\n    _classCallCheck(this, CodifiedError);\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(CodifiedError).call(this, original.message));\n    Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this2)), _this2.constructor);\n    if (original instanceof Error) {\n      _this2.name = original.name;\n      _this2.error = {\n        error: original.name,\n        status: OTHER_ERROR_CODE,\n        message: original.message\n      };\n    } else {\n      _this2.name = original.error;\n      _this2.error = original;\n    }\n    return _this2;\n  }\n  return CodifiedError;\n}(_wrapNativeSuper(Error));\nvar INVALID_EMAIL_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-email\",\n  message: \"Email is incorrectly formatted\"\n};\nvar INVALID_MFA_TYPE_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-mfa-type\",\n  message: \"MFA type is invalid\"\n};\nvar INVALID_MFA_CODE_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-mfa-code\",\n  message: \"MFA code is invalid\"\n};\nvar INVALID_PASSWORD_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-password\",\n  message: \"Password is incorrectly formatted\"\n};\nvar INVALID_PHONE_NUMBER_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-phone-number\",\n  message: \"Phone number is incorrectly formatted\"\n};\nvar INVALID_MFA_TICKET_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-mfa-ticket\",\n  message: \"MFA ticket is invalid\"\n};\nvar NO_MFA_TICKET_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"no-mfa-ticket\",\n  message: \"No MFA ticket has been provided\"\n};\nvar NO_REFRESH_TOKEN = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"no-refresh-token\",\n  message: \"No refresh token has been provided\"\n};\nvar TOKEN_REFRESHER_RUNNING_ERROR = {\n  status: STATE_ERROR_CODE,\n  error: \"refresher-already-running\",\n  message: \"The token refresher is already running. You must wait until is has finished before submitting a new token.\"\n};\nvar USER_ALREADY_SIGNED_IN = {\n  status: STATE_ERROR_CODE,\n  error: \"already-signed-in\",\n  message: \"User is already signed in\"\n};\nvar USER_UNAUTHENTICATED = {\n  status: STATE_ERROR_CODE,\n  error: \"unauthenticated-user\",\n  message: \"User is not authenticated\"\n};\nvar USER_NOT_ANONYMOUS = {\n  status: STATE_ERROR_CODE,\n  error: \"user-not-anonymous\",\n  message: \"User is not anonymous\"\n};\nvar EMAIL_NEEDS_VERIFICATION = {\n  status: STATE_ERROR_CODE,\n  error: \"unverified-user\",\n  message: \"Email needs verification\"\n};\nvar INVALID_REFRESH_TOKEN = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-refresh-token\",\n  message: \"Invalid or expired refresh token\"\n};\nvar nhostApiClient = function nhostApiClient(backendUrl) {\n  var client = axios.create({\n    baseURL: backendUrl\n  });\n  client.interceptors.response.use(function (response) {\n    return response;\n  }, function (error) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    return Promise.reject({\n      error: {\n        message: (_e = (_d = (_c = (_b = (_a = error.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message) != null ? _c : error.message) != null ? _d : error.request.responseText) != null ? _e : JSON.stringify(error),\n        status: (_i = (_h = (_f = error.response) == null ? void 0 : _f.status) != null ? _h : (_g = error.response) == null ? void 0 : _g.data.statusCode) != null ? _i : NETWORK_ERROR_CODE,\n        error: ((_j = error.response) == null ? void 0 : _j.data.error) || error.request.statusText || \"network\"\n      }\n    });\n  });\n  return client;\n};\nvar isBrowser$1 = typeof window !== \"undefined\";\nvar inMemoryLocalStorage = /* @__PURE__ */new Map();\nvar defaultClientStorageGetter = function defaultClientStorageGetter(key) {\n  var _a;\n  if (isBrowser$1 && typeof localStorage !== \"undefined\") return localStorage.getItem(key);else return (_a = inMemoryLocalStorage.get(key)) != null ? _a : null;\n};\nvar defaultClientStorageSetter = function defaultClientStorageSetter(key, value) {\n  if (isBrowser$1 && typeof localStorage !== \"undefined\") {\n    if (value) {\n      localStorage.setItem(key, value);\n    } else {\n      localStorage.removeItem(key);\n    }\n  } else {\n    if (value) {\n      inMemoryLocalStorage.set(key, value);\n    } else if (inMemoryLocalStorage.has(key)) {\n      inMemoryLocalStorage.delete(key);\n    }\n  }\n};\nvar localStorageGetter = function localStorageGetter(clientStorageType, clientStorage) {\n  if (clientStorageType === \"localStorage\" || clientStorageType === \"web\") {\n    return defaultClientStorageGetter;\n  }\n  if (clientStorageType === \"cookie\") {\n    return function (key) {\n      var _a;\n      if (isBrowser$1) {\n        return (_a = Cookies.get(key)) != null ? _a : null;\n      } else {\n        return null;\n      }\n    };\n  }\n  if (!clientStorage) {\n    throw Error(\"clientStorageType is set to '\".concat(clientStorageType, \"' but no clientStorage has been given\"));\n  }\n  if (clientStorageType === \"react-native\") {\n    return function (key) {\n      var _a;\n      return (_a = clientStorage.getItem) == null ? void 0 : _a.call(clientStorage, key);\n    };\n  }\n  if (clientStorageType === \"capacitor\") {\n    return function (key) {\n      var _a;\n      return (_a = clientStorage.get) == null ? void 0 : _a.call(clientStorage, {\n        key: key\n      });\n    };\n  }\n  if (clientStorageType === \"expo-secure-storage\") {\n    return function (key) {\n      var _a;\n      return (_a = clientStorage.getItemAsync) == null ? void 0 : _a.call(clientStorage, key);\n    };\n  }\n  if (clientStorageType === \"custom\") {\n    if (clientStorage.getItem && clientStorage.removeItem) {\n      return clientStorage.getItem;\n    }\n    if (clientStorage.getItemAsync) {\n      return clientStorage.getItemAsync;\n    }\n    throw Error(\"clientStorageType is set to 'custom' but clientStorage is missing either \\\"getItem\\\" and \\\"removeItem\\\" properties or \\\"getItemAsync\\\" property\");\n  }\n  throw Error(\"Unknown storage type: \".concat(clientStorageType));\n};\nvar localStorageSetter = function localStorageSetter(clientStorageType, clientStorage) {\n  if (clientStorageType === \"localStorage\" || clientStorageType === \"web\") {\n    return defaultClientStorageSetter;\n  }\n  if (clientStorageType === \"cookie\") {\n    return function (key, value) {\n      if (isBrowser$1) {\n        if (value) {\n          Cookies.set(key, value, {\n            expires: 30\n          });\n        } else {\n          Cookies.remove(key);\n        }\n      }\n    };\n  }\n  if (!clientStorage) {\n    throw Error(\"clientStorageType is set to '\".concat(clientStorageType, \"' but no clienStorage has been given\"));\n  }\n  if (clientStorageType === \"react-native\") {\n    return function (key, value) {\n      var _a, _b;\n      return value ? (_a = clientStorage.setItem) == null ? void 0 : _a.call(clientStorage, key, value) : (_b = clientStorage.removeItem) == null ? void 0 : _b.call(clientStorage, key);\n    };\n  }\n  if (clientStorageType === \"capacitor\") {\n    return function (key, value) {\n      var _a, _b;\n      return value ? (_a = clientStorage.set) == null ? void 0 : _a.call(clientStorage, {\n        key: key,\n        value: value\n      }) : (_b = clientStorage.remove) == null ? void 0 : _b.call(clientStorage, {\n        key: key\n      });\n    };\n  }\n  if (clientStorageType === \"expo-secure-storage\") {\n    return /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key, value) {\n        var _a, _b;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", value ? (_a = clientStorage.setItemAsync) == null ? void 0 : _a.call(clientStorage, key, value) : (_b = clientStorage.deleteItemAsync) == null ? void 0 : _b.call(clientStorage, key));\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function (_x3, _x4) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n  }\n  if (clientStorageType === \"custom\") {\n    if (!clientStorage.removeItem) {\n      throw Error(\"clientStorageType is set to 'custom' but clientStorage is missing a removeItem property\");\n    }\n    if (clientStorage.setItem) {\n      return function (key, value) {\n        var _a, _b;\n        return value ? (_a = clientStorage.setItem) == null ? void 0 : _a.call(clientStorage, key, value) : (_b = clientStorage.removeItem) == null ? void 0 : _b.call(clientStorage, key);\n      };\n    }\n    if (clientStorage.setItemAsync) {\n      return /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key, value) {\n          var _a, _b;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  return _context2.abrupt(\"return\", value ? (_a = clientStorage.setItemAsync) == null ? void 0 : _a.call(clientStorage, key, value) : (_b = clientStorage.removeItem) == null ? void 0 : _b.call(clientStorage, key));\n                case 1:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n        return function (_x5, _x6) {\n          return _ref4.apply(this, arguments);\n        };\n      }();\n    }\n    throw Error(\"clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property\");\n  }\n  throw Error(\"Unknown storage type: \".concat(clientStorageType));\n};\nvar encodeQueryParameters = function encodeQueryParameters(baseUrl, parameters) {\n  var encodedParameters = parameters && Object.entries(parameters).map(function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 2),\n      key = _ref6[0],\n      value = _ref6[1];\n    var stringValue = Array.isArray(value) ? value.join(\",\") : typeof value === \"object\" ? JSON.stringify(value) : value;\n    return \"\".concat(key, \"=\").concat(encodeURIComponent(stringValue));\n  }).join(\"&\");\n  if (encodedParameters) return \"\".concat(baseUrl, \"?\").concat(encodedParameters);else return baseUrl;\n};\nvar rewriteRedirectTo = function rewriteRedirectTo(clientUrl, options) {\n  if (!(options == null ? void 0 : options.redirectTo)) {\n    return options;\n  }\n  var _a = options,\n    redirectTo = _a.redirectTo,\n    otherOptions = __objRest(_a, [\"redirectTo\"]);\n  if (!clientUrl) {\n    if (redirectTo.startsWith(\"/\")) {\n      return otherOptions;\n    } else {\n      return options;\n    }\n  }\n  var baseClientUrl = new URL(clientUrl);\n  var clientParams = Object.fromEntries(new URLSearchParams(baseClientUrl.search));\n  var url = new URL(redirectTo.startsWith(\"/\") ? baseClientUrl.origin + redirectTo : redirectTo);\n  var additionalParams = new URLSearchParams(url.search);\n  var combinedParams = Object.fromEntries(additionalParams);\n  if (redirectTo.startsWith(\"/\")) {\n    combinedParams = __spreadValues(__spreadValues({}, clientParams), combinedParams);\n  }\n  var pathName = baseClientUrl.pathname;\n  if (url.pathname.length > 1) {\n    pathName += url.pathname.slice(1);\n  }\n  return __spreadProps(__spreadValues({}, otherOptions), {\n    redirectTo: encodeQueryParameters(url.origin + pathName, combinedParams)\n  });\n};\nfunction getParameterByName(name, url) {\n  var _a;\n  if (!url) {\n    if (typeof window === \"undefined\") {\n      return;\n    }\n    url = ((_a = window.location) == null ? void 0 : _a.href) || \"\";\n  }\n  name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n  var regex = new RegExp(\"[?&#]\" + name + \"(=([^&#]*)|&|#|$)\"),\n    results = regex.exec(url);\n  if (!results) return null;\n  if (!results[2]) return \"\";\n  return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n}\nfunction removeParameterFromWindow(name) {\n  var _a;\n  if (typeof window === \"undefined\") {\n    return;\n  }\n  var location = window == null ? void 0 : window.location;\n  if (!location) {\n    return;\n  }\n  if (location) {\n    var search = new URLSearchParams(location.search);\n    var hash = new URLSearchParams((_a = location.hash) == null ? void 0 : _a.slice(1));\n    search.delete(name);\n    hash.delete(name);\n    var url = window.location.pathname;\n    if (Array.from(search).length) url += \"?\".concat(search.toString());\n    if (Array.from(hash).length) url += \"#\".concat(hash.toString());\n    window.history.pushState({}, \"\", url);\n  }\n}\nvar isValidEmail = function isValidEmail(email) {\n  return !!email && typeof email === \"string\" && !!String(email).toLowerCase().match(/^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/);\n};\nvar isValidPassword = function isValidPassword(password) {\n  return !!password && typeof password === \"string\" && password.length >= MIN_PASSWORD_LENGTH;\n};\nvar isValidPhoneNumber = function isValidPhoneNumber(phoneNumber) {\n  return !!phoneNumber && typeof phoneNumber === \"string\";\n};\nvar isValidTicket = function isValidTicket(ticket) {\n  return ticket && typeof ticket === \"string\" && ticket.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i);\n};\nvar INITIAL_MACHINE_CONTEXT = {\n  user: null,\n  mfa: null,\n  accessToken: {\n    value: null,\n    expiresAt: null\n  },\n  refreshTimer: {\n    startedAt: null,\n    attempts: 0,\n    lastAttempt: null\n  },\n  refreshToken: {\n    value: null\n  },\n  errors: {}\n};\nvar createChangeEmailMachine = function createChangeEmailMachine(_ref7) {\n  var backendUrl = _ref7.backendUrl,\n    clientUrl = _ref7.clientUrl,\n    interpreter = _ref7.interpreter;\n  var api = nhostApiClient(backendUrl);\n  return createMachine({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    preserveActionOrder: true,\n    id: \"changeEmail\",\n    initial: \"idle\",\n    context: {\n      error: null\n    },\n    states: {\n      idle: {\n        on: {\n          REQUEST: [{\n            cond: \"invalidEmail\",\n            actions: \"saveInvalidEmailError\",\n            target: \".error\"\n          }, {\n            target: \"requesting\"\n          }]\n        },\n        initial: \"initial\",\n        states: {\n          initial: {},\n          success: {},\n          error: {}\n        }\n      },\n      requesting: {\n        invoke: {\n          src: \"requestChange\",\n          id: \"requestChange\",\n          onDone: {\n            target: \"idle.success\",\n            actions: \"reportSuccess\"\n          },\n          onError: {\n            actions: [\"saveRequestError\", \"reportError\"],\n            target: \"idle.error\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidEmailError: assign({\n        error: function error(_) {\n          return INVALID_EMAIL_ERROR;\n        }\n      }),\n      saveRequestError: assign({\n        error: function error(_, _ref8) {\n          var _error = _ref8.data.error;\n          return _error;\n        }\n      }),\n      reportError: send(function (ctx) {\n        return {\n          type: \"ERROR\",\n          error: ctx.error\n        };\n      }),\n      reportSuccess: send(\"SUCCESS\")\n    },\n    guards: {\n      invalidEmail: function invalidEmail(_, _ref9) {\n        var email = _ref9.email;\n        return !isValidEmail(email);\n      }\n    },\n    services: {\n      requestChange: function () {\n        var _requestChange = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_, _ref10) {\n          var email, options, res;\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  email = _ref10.email, options = _ref10.options;\n                  _context3.next = 3;\n                  return api.post(\"/user/email/change\", {\n                    newEmail: email,\n                    options: rewriteRedirectTo(clientUrl, options)\n                  }, {\n                    headers: {\n                      authorization: \"Bearer \".concat(interpreter == null ? void 0 : interpreter.state.context.accessToken.value)\n                    }\n                  });\n                case 3:\n                  res = _context3.sent;\n                  return _context3.abrupt(\"return\", res.data);\n                case 5:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3);\n        }));\n        function requestChange(_x7, _x8) {\n          return _requestChange.apply(this, arguments);\n        }\n        return requestChange;\n      }()\n    }\n  });\n};\nvar createChangePasswordMachine = function createChangePasswordMachine(_ref11) {\n  var backendUrl = _ref11.backendUrl,\n    interpreter = _ref11.interpreter;\n  var api = nhostApiClient(backendUrl);\n  return createMachine({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    preserveActionOrder: true,\n    id: \"changePassword\",\n    initial: \"idle\",\n    context: {\n      error: null\n    },\n    states: {\n      idle: {\n        on: {\n          REQUEST: [{\n            cond: \"invalidPassword\",\n            actions: \"saveInvalidPasswordError\",\n            target: \".error\"\n          }, {\n            target: \"requesting\"\n          }]\n        },\n        initial: \"initial\",\n        states: {\n          initial: {},\n          success: {},\n          error: {}\n        }\n      },\n      requesting: {\n        invoke: {\n          src: \"requestChange\",\n          id: \"requestChange\",\n          onDone: {\n            target: \"idle.success\",\n            actions: \"reportSuccess\"\n          },\n          onError: {\n            actions: [\"saveRequestError\", \"reportError\"],\n            target: \"idle.error\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidPasswordError: assign({\n        error: function error(_) {\n          return INVALID_PASSWORD_ERROR;\n        }\n      }),\n      saveRequestError: assign({\n        error: function error(_, _ref12) {\n          var _error2 = _ref12.data.error;\n          return _error2;\n        }\n      }),\n      reportError: send(function (ctx) {\n        return {\n          type: \"ERROR\",\n          error: ctx.error\n        };\n      }),\n      reportSuccess: send(\"SUCCESS\")\n    },\n    guards: {\n      invalidPassword: function invalidPassword(_, _ref13) {\n        var password = _ref13.password;\n        return !isValidPassword(password);\n      }\n    },\n    services: {\n      requestChange: function requestChange(_, _ref14) {\n        var password = _ref14.password,\n          ticket = _ref14.ticket;\n        return api.post(\"/user/password\", {\n          newPassword: password,\n          ticket: ticket\n        }, {\n          headers: {\n            authorization: \"Bearer \".concat(interpreter == null ? void 0 : interpreter.state.context.accessToken.value)\n          }\n        });\n      }\n    }\n  });\n};\nvar createEnableMfaMachine = function createEnableMfaMachine(_ref15) {\n  var backendUrl = _ref15.backendUrl,\n    interpreter = _ref15.interpreter;\n  var api = nhostApiClient(backendUrl);\n  return createMachine({\n    schema: {\n      context: {},\n      events: {}\n    },\n    tsTypes: {},\n    preserveActionOrder: true,\n    id: \"enableMfa\",\n    initial: \"idle\",\n    context: {\n      error: null,\n      imageUrl: null,\n      secret: null\n    },\n    states: {\n      idle: {\n        initial: \"initial\",\n        on: {\n          GENERATE: \"generating\"\n        },\n        states: {\n          initial: {},\n          error: {}\n        }\n      },\n      generating: {\n        invoke: {\n          src: \"generate\",\n          id: \"generate\",\n          onDone: {\n            target: \"generated\",\n            actions: [\"reportGeneratedSuccess\", \"saveGeneration\"]\n          },\n          onError: {\n            actions: [\"saveError\", \"reportGeneratedError\"],\n            target: \"idle.error\"\n          }\n        }\n      },\n      generated: {\n        initial: \"idle\",\n        states: {\n          idle: {\n            initial: \"idle\",\n            on: {\n              ACTIVATE: [{\n                cond: \"invalidMfaType\",\n                actions: \"saveInvalidMfaTypeError\",\n                target: \".error\"\n              }, {\n                cond: \"invalidMfaCode\",\n                actions: \"saveInvalidMfaCodeError\",\n                target: \".error\"\n              }, {\n                target: \"activating\"\n              }]\n            },\n            states: {\n              idle: {},\n              error: {}\n            }\n          },\n          activating: {\n            invoke: {\n              src: \"activate\",\n              id: \"activate\",\n              onDone: {\n                target: \"activated\",\n                actions: \"reportSuccess\"\n              },\n              onError: {\n                actions: [\"saveError\", \"reportError\"],\n                target: \"idle.error\"\n              }\n            }\n          },\n          activated: {\n            type: \"final\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidMfaTypeError: assign({\n        error: function error(_) {\n          return INVALID_MFA_TYPE_ERROR;\n        }\n      }),\n      saveInvalidMfaCodeError: assign({\n        error: function error(_) {\n          return INVALID_MFA_CODE_ERROR;\n        }\n      }),\n      saveError: assign({\n        error: function error(_, _ref16) {\n          var _error3 = _ref16.data.error;\n          return _error3;\n        }\n      }),\n      saveGeneration: assign({\n        imageUrl: function imageUrl(_, _ref17) {\n          var _imageUrl = _ref17.data.imageUrl;\n          return _imageUrl;\n        },\n        secret: function secret(_, _ref18) {\n          var totpSecret = _ref18.data.totpSecret;\n          return totpSecret;\n        }\n      }),\n      reportError: send(function (ctx) {\n        return {\n          type: \"ERROR\",\n          error: ctx.error\n        };\n      }),\n      reportSuccess: send(\"SUCCESS\"),\n      reportGeneratedSuccess: send(\"GENERATED\"),\n      reportGeneratedError: send(function (ctx) {\n        return {\n          type: \"GENERATED_ERROR\",\n          error: ctx.error\n        };\n      })\n    },\n    guards: {\n      invalidMfaCode: function invalidMfaCode(_, _ref19) {\n        var code = _ref19.code;\n        return !code;\n      },\n      invalidMfaType: function invalidMfaType(_, _ref20) {\n        var activeMfaType = _ref20.activeMfaType;\n        return !activeMfaType || activeMfaType !== \"totp\";\n      }\n    },\n    services: {\n      generate: function () {\n        var _generate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_) {\n          var _yield$api$get, data;\n          return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.next = 2;\n                  return api.get(\"/mfa/totp/generate\", {\n                    headers: {\n                      authorization: \"Bearer \".concat(interpreter == null ? void 0 : interpreter.state.context.accessToken.value)\n                    }\n                  });\n                case 2:\n                  _yield$api$get = _context4.sent;\n                  data = _yield$api$get.data;\n                  return _context4.abrupt(\"return\", data);\n                case 5:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4);\n        }));\n        function generate(_x9) {\n          return _generate.apply(this, arguments);\n        }\n        return generate;\n      }(),\n      activate: function activate(_, _ref21) {\n        var code = _ref21.code,\n          activeMfaType = _ref21.activeMfaType;\n        return api.post(\"/user/mfa\", {\n          code: code,\n          activeMfaType: activeMfaType\n        }, {\n          headers: {\n            authorization: \"Bearer \".concat(interpreter == null ? void 0 : interpreter.state.context.accessToken.value)\n          }\n        });\n      }\n    }\n  });\n};\nvar createResetPasswordMachine = function createResetPasswordMachine(_ref22) {\n  var backendUrl = _ref22.backendUrl,\n    clientUrl = _ref22.clientUrl;\n  var api = nhostApiClient(backendUrl);\n  return createMachine({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    preserveActionOrder: true,\n    id: \"changePassword\",\n    initial: \"idle\",\n    context: {\n      error: null\n    },\n    states: {\n      idle: {\n        on: {\n          REQUEST: [{\n            cond: \"invalidEmail\",\n            actions: \"saveInvalidEmailError\",\n            target: \".error\"\n          }, {\n            target: \"requesting\"\n          }]\n        },\n        initial: \"initial\",\n        states: {\n          initial: {},\n          success: {},\n          error: {}\n        }\n      },\n      requesting: {\n        invoke: {\n          src: \"requestChange\",\n          id: \"requestChange\",\n          onDone: {\n            target: \"idle.success\",\n            actions: \"reportSuccess\"\n          },\n          onError: {\n            actions: [\"saveRequestError\", \"reportError\"],\n            target: \"idle.error\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidEmailError: assign({\n        error: function error(_) {\n          return INVALID_EMAIL_ERROR;\n        }\n      }),\n      saveRequestError: assign({\n        error: function error(_, _ref23) {\n          var _error4 = _ref23.data.error;\n          return _error4;\n        }\n      }),\n      reportError: send(function (ctx) {\n        return {\n          type: \"ERROR\",\n          error: ctx.error\n        };\n      }),\n      reportSuccess: send(\"SUCCESS\")\n    },\n    guards: {\n      invalidEmail: function invalidEmail(_, _ref24) {\n        var email = _ref24.email;\n        return !isValidEmail(email);\n      }\n    },\n    services: {\n      requestChange: function requestChange(_, _ref25) {\n        var email = _ref25.email,\n          options = _ref25.options;\n        return api.post(\"/user/password/reset\", {\n          email: email,\n          options: rewriteRedirectTo(clientUrl, options)\n        });\n      }\n    }\n  });\n};\nvar createSendVerificationEmailMachine = function createSendVerificationEmailMachine(_ref26) {\n  var backendUrl = _ref26.backendUrl,\n    clientUrl = _ref26.clientUrl;\n  var api = nhostApiClient(backendUrl);\n  return createMachine({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    preserveActionOrder: true,\n    id: \"sendVerificationEmail\",\n    initial: \"idle\",\n    context: {\n      error: null\n    },\n    states: {\n      idle: {\n        on: {\n          REQUEST: [{\n            cond: \"invalidEmail\",\n            actions: \"saveInvalidEmailError\",\n            target: \".error\"\n          }, {\n            target: \"requesting\"\n          }]\n        },\n        initial: \"initial\",\n        states: {\n          initial: {},\n          success: {},\n          error: {}\n        }\n      },\n      requesting: {\n        invoke: {\n          src: \"request\",\n          id: \"request\",\n          onDone: {\n            target: \"idle.success\",\n            actions: \"reportSuccess\"\n          },\n          onError: {\n            actions: [\"saveRequestError\", \"reportError\"],\n            target: \"idle.error\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidEmailError: assign({\n        error: function error(_) {\n          return INVALID_EMAIL_ERROR;\n        }\n      }),\n      saveRequestError: assign({\n        error: function error(_, _ref27) {\n          var _error5 = _ref27.data.error;\n          return _error5;\n        }\n      }),\n      reportError: send(function (ctx) {\n        return {\n          type: \"ERROR\",\n          error: ctx.error\n        };\n      }),\n      reportSuccess: send(\"SUCCESS\")\n    },\n    guards: {\n      invalidEmail: function invalidEmail(_, _ref28) {\n        var email = _ref28.email;\n        return !isValidEmail(email);\n      }\n    },\n    services: {\n      request: function () {\n        var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_, _ref29) {\n          var email, options, res;\n          return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  email = _ref29.email, options = _ref29.options;\n                  _context5.next = 3;\n                  return api.post(\"/user/email/send-verification-email\", {\n                    email: email,\n                    options: rewriteRedirectTo(clientUrl, options)\n                  });\n                case 3:\n                  res = _context5.sent;\n                  return _context5.abrupt(\"return\", res.data);\n                case 5:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5);\n        }));\n        function request(_x10, _x11) {\n          return _request.apply(this, arguments);\n        }\n        return request;\n      }()\n    }\n  });\n};\nvar createAuthMachine = function createAuthMachine(_ref30) {\n  var backendUrl = _ref30.backendUrl,\n    clientUrl = _ref30.clientUrl,\n    clientStorageGetter = _ref30.clientStorageGetter,\n    clientStorageSetter = _ref30.clientStorageSetter,\n    _ref30$clientStorageT = _ref30.clientStorageType,\n    clientStorageType = _ref30$clientStorageT === void 0 ? \"web\" : _ref30$clientStorageT,\n    clientStorage = _ref30.clientStorage,\n    refreshIntervalTime = _ref30.refreshIntervalTime,\n    _ref30$autoRefreshTok = _ref30.autoRefreshToken,\n    autoRefreshToken = _ref30$autoRefreshTok === void 0 ? true : _ref30$autoRefreshTok,\n    _ref30$autoSignIn = _ref30.autoSignIn,\n    autoSignIn = _ref30$autoSignIn === void 0 ? true : _ref30$autoSignIn;\n  var storageGetter = clientStorageGetter || localStorageGetter(clientStorageType, clientStorage);\n  var storageSetter = clientStorageSetter || localStorageSetter(clientStorageType, clientStorage);\n  var api = nhostApiClient(backendUrl);\n  var postRequest = /*#__PURE__*/function () {\n    var _ref31 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(url, data, config) {\n      var result;\n      return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return api.post(url, data, config);\n            case 2:\n              result = _context6.sent;\n              return _context6.abrupt(\"return\", result.data);\n            case 4:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }));\n    return function postRequest(_x12, _x13, _x14) {\n      return _ref31.apply(this, arguments);\n    };\n  }();\n  return createMachine({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    context: INITIAL_MACHINE_CONTEXT,\n    preserveActionOrder: true,\n    id: \"nhost\",\n    type: \"parallel\",\n    states: {\n      authentication: {\n        initial: \"starting\",\n        on: {\n          SESSION_UPDATE: [{\n            cond: \"hasSession\",\n            actions: [\"saveSession\", \"resetTimer\", \"reportTokenChanged\"],\n            target: \".signedIn\"\n          }]\n        },\n        states: {\n          starting: {\n            entry: \"resetErrors\",\n            tags: [\"loading\"],\n            always: {\n              cond: \"isSignedIn\",\n              target: \"signedIn\"\n            },\n            invoke: {\n              id: \"importRefreshToken\",\n              src: \"importRefreshToken\",\n              onDone: {\n                actions: [\"saveSession\", \"reportTokenChanged\"],\n                target: \"signedIn\"\n              },\n              onError: {\n                actions: [\"saveAuthenticationError\"],\n                target: \"signedOut\"\n              }\n            }\n          },\n          signedOut: {\n            initial: \"noErrors\",\n            entry: \"reportSignedOut\",\n            states: {\n              noErrors: {},\n              success: {},\n              needsSmsOtp: {},\n              needsMfa: {},\n              failed: {},\n              signingOut: {\n                entry: [\"clearContextExceptRefreshToken\"],\n                exit: [\"destroyRefreshToken\", \"reportTokenChanged\"],\n                invoke: {\n                  src: \"signout\",\n                  id: \"signingOut\",\n                  onDone: {\n                    target: \"success\"\n                  },\n                  onError: {\n                    target: \"failed\",\n                    actions: [\"saveAuthenticationError\"]\n                  }\n                }\n              }\n            },\n            on: {\n              SIGNIN_PASSWORD: \"authenticating.password\",\n              SIGNIN_ANONYMOUS: \"authenticating.anonymous\",\n              SIGNIN_SECURITY_KEY_EMAIL: \"authenticating.securityKeyEmail\",\n              SIGNIN_MFA_TOTP: \"authenticating.mfa.totp\"\n            }\n          },\n          authenticating: {\n            entry: \"resetErrors\",\n            states: {\n              password: {\n                invoke: {\n                  src: \"signInPassword\",\n                  id: \"authenticateUserWithPassword\",\n                  onDone: [{\n                    cond: \"hasMfaTicket\",\n                    actions: [\"saveMfaTicket\"],\n                    target: \"#nhost.authentication.signedOut.needsMfa\"\n                  }, {\n                    actions: [\"saveSession\", \"reportTokenChanged\"],\n                    target: \"#nhost.authentication.signedIn\"\n                  }],\n                  onError: [{\n                    cond: \"unverified\",\n                    target: [\"#nhost.authentication.signedOut\", \"#nhost.registration.incomplete.needsEmailVerification\"]\n                  }, {\n                    actions: \"saveAuthenticationError\",\n                    target: \"#nhost.authentication.signedOut.failed\"\n                  }]\n                }\n              },\n              anonymous: {\n                invoke: {\n                  src: \"signInAnonymous\",\n                  id: \"authenticateAnonymously\",\n                  onDone: {\n                    actions: [\"saveSession\", \"reportTokenChanged\"],\n                    target: \"#nhost.authentication.signedIn\"\n                  },\n                  onError: {\n                    actions: \"saveAuthenticationError\",\n                    target: \"#nhost.authentication.signedOut.failed\"\n                  }\n                }\n              },\n              mfa: {\n                states: {\n                  totp: {\n                    invoke: {\n                      src: \"signInMfaTotp\",\n                      id: \"signInMfaTotp\",\n                      onDone: {\n                        actions: [\"saveSession\", \"reportTokenChanged\"],\n                        target: \"#nhost.authentication.signedIn\"\n                      },\n                      onError: {\n                        actions: [\"saveAuthenticationError\"],\n                        target: \"#nhost.authentication.signedOut.failed\"\n                      }\n                    }\n                  }\n                }\n              },\n              securityKeyEmail: {\n                invoke: {\n                  src: \"signInSecurityKeyEmail\",\n                  id: \"authenticateUserWithSecurityKey\",\n                  onDone: {\n                    actions: [\"saveSession\", \"reportTokenChanged\"],\n                    target: \"#nhost.authentication.signedIn\"\n                  },\n                  onError: [{\n                    cond: \"unverified\",\n                    target: [\"#nhost.authentication.signedOut\", \"#nhost.registration.incomplete.needsEmailVerification\"]\n                  }, {\n                    actions: \"saveAuthenticationError\",\n                    target: \"#nhost.authentication.signedOut.failed\"\n                  }]\n                }\n              }\n            }\n          },\n          signedIn: {\n            type: \"parallel\",\n            entry: [\"reportSignedIn\", \"cleanUrl\", \"broadcastToken\", \"resetErrors\"],\n            on: {\n              SIGNOUT: \"signedOut.signingOut\"\n            },\n            states: {\n              refreshTimer: {\n                id: \"timer\",\n                initial: \"idle\",\n                states: {\n                  disabled: {\n                    type: \"final\"\n                  },\n                  stopped: {\n                    always: {\n                      cond: \"noToken\",\n                      target: \"idle\"\n                    }\n                  },\n                  idle: {\n                    always: [{\n                      cond: \"isAutoRefreshDisabled\",\n                      target: \"disabled\"\n                    }, {\n                      cond: \"hasRefreshToken\",\n                      target: \"running\"\n                    }]\n                  },\n                  running: {\n                    initial: \"pending\",\n                    entry: \"resetTimer\",\n                    states: {\n                      pending: {\n                        after: {\n                          \"1000\": {\n                            internal: false,\n                            target: \"pending\"\n                          }\n                        },\n                        always: {\n                          cond: \"refreshTimerShouldRefresh\",\n                          target: \"refreshing\"\n                        }\n                      },\n                      refreshing: {\n                        invoke: {\n                          src: \"refreshToken\",\n                          id: \"refreshToken\",\n                          onDone: {\n                            actions: [\"saveSession\", \"resetTimer\", \"reportTokenChanged\"],\n                            target: \"pending\"\n                          },\n                          onError: [{\n                            actions: \"saveRefreshAttempt\",\n                            target: \"pending\"\n                          }]\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      token: {\n        initial: \"idle\",\n        states: {\n          idle: {\n            on: {\n              TRY_TOKEN: \"running\"\n            },\n            initial: \"noErrors\",\n            states: {\n              noErrors: {},\n              error: {}\n            }\n          },\n          running: {\n            invoke: {\n              src: \"refreshToken\",\n              id: \"authenticateWithToken\",\n              onDone: {\n                actions: [\"saveSession\", \"reportTokenChanged\"],\n                target: [\"#nhost.authentication.signedIn\", \"idle.noErrors\"]\n              },\n              onError: [{\n                cond: \"isSignedIn\",\n                target: \"idle.error\"\n              }, {\n                actions: \"saveAuthenticationError\",\n                target: [\"#nhost.authentication.signedOut.failed\", \"idle.error\"]\n              }]\n            }\n          }\n        }\n      },\n      registration: {\n        initial: \"incomplete\",\n        on: {\n          SIGNED_IN: [{\n            cond: \"isAnonymous\",\n            target: \".incomplete\"\n          }, \".complete\"]\n        },\n        states: {\n          incomplete: {\n            on: {\n              SIGNUP_EMAIL_PASSWORD: \"emailPassword\",\n              SIGNUP_SECURITY_KEY: \"securityKey\",\n              PASSWORDLESS_EMAIL: \"passwordlessEmail\",\n              PASSWORDLESS_SMS: \"passwordlessSms\",\n              PASSWORDLESS_SMS_OTP: \"passwordlessSmsOtp\"\n            },\n            initial: \"noErrors\",\n            states: {\n              noErrors: {},\n              needsEmailVerification: {},\n              needsOtp: {},\n              failed: {}\n            }\n          },\n          emailPassword: {\n            entry: [\"resetErrors\"],\n            invoke: {\n              src: \"signUpEmailPassword\",\n              id: \"signUpEmailPassword\",\n              onDone: [{\n                cond: \"hasSession\",\n                actions: [\"saveSession\", \"reportTokenChanged\"],\n                target: \"#nhost.authentication.signedIn\"\n              }, {\n                actions: \"clearContext\",\n                target: [\"#nhost.authentication.signedOut\", \"incomplete.needsEmailVerification\"]\n              }],\n              onError: [{\n                cond: \"unverified\",\n                target: \"incomplete.needsEmailVerification\"\n              }, {\n                actions: \"saveRegistrationError\",\n                target: \"incomplete.failed\"\n              }]\n            }\n          },\n          securityKey: {\n            entry: [\"resetErrors\"],\n            invoke: {\n              src: \"signUpSecurityKey\",\n              id: \"signUpSecurityKey\",\n              onDone: [{\n                cond: \"hasSession\",\n                actions: [\"saveSession\", \"reportTokenChanged\"],\n                target: \"#nhost.authentication.signedIn\"\n              }, {\n                actions: \"clearContext\",\n                target: [\"#nhost.authentication.signedOut\", \"incomplete.needsEmailVerification\"]\n              }],\n              onError: [{\n                cond: \"unverified\",\n                target: \"incomplete.needsEmailVerification\"\n              }, {\n                actions: \"saveRegistrationError\",\n                target: \"incomplete.failed\"\n              }]\n            }\n          },\n          passwordlessEmail: {\n            entry: [\"resetErrors\"],\n            invoke: {\n              src: \"passwordlessEmail\",\n              id: \"passwordlessEmail\",\n              onDone: {\n                actions: \"clearContext\",\n                target: [\"#nhost.authentication.signedOut\", \"incomplete.needsEmailVerification\"]\n              },\n              onError: {\n                actions: \"saveRegistrationError\",\n                target: \"incomplete.failed\"\n              }\n            }\n          },\n          passwordlessSms: {\n            entry: [\"resetErrors\"],\n            invoke: {\n              src: \"passwordlessSms\",\n              id: \"passwordlessSms\",\n              onDone: {\n                actions: \"clearContext\",\n                target: [\"#nhost.authentication.signedOut\", \"incomplete.needsOtp\"]\n              },\n              onError: {\n                actions: \"saveRegistrationError\",\n                target: \"incomplete.failed\"\n              }\n            }\n          },\n          passwordlessSmsOtp: {\n            entry: [\"resetErrors\"],\n            invoke: {\n              src: \"passwordlessSmsOtp\",\n              id: \"passwordlessSmsOtp\",\n              onDone: {\n                actions: [\"saveSession\", \"reportTokenChanged\"],\n                target: \"#nhost.authentication.signedIn\"\n              },\n              onError: {\n                actions: \"saveRegistrationError\",\n                target: \"incomplete.failed\"\n              }\n            }\n          },\n          complete: {\n            on: {\n              SIGNED_OUT: \"incomplete\"\n            }\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      reportSignedIn: send(\"SIGNED_IN\"),\n      reportSignedOut: send(\"SIGNED_OUT\"),\n      reportTokenChanged: send(\"TOKEN_CHANGED\"),\n      clearContext: assign(function () {\n        storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null);\n        storageSetter(NHOST_REFRESH_TOKEN_KEY, null);\n        return __spreadValues({}, INITIAL_MACHINE_CONTEXT);\n      }),\n      clearContextExceptRefreshToken: assign(function (_ref32) {\n        var value = _ref32.refreshToken.value;\n        storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null);\n        return __spreadProps(__spreadValues({}, INITIAL_MACHINE_CONTEXT), {\n          refreshToken: {\n            value: value\n          }\n        });\n      }),\n      saveSession: assign({\n        user: function user(_, _ref33) {\n          var data = _ref33.data;\n          var _a;\n          return ((_a = data == null ? void 0 : data.session) == null ? void 0 : _a.user) || null;\n        },\n        accessToken: function accessToken(_, _ref34) {\n          var data = _ref34.data;\n          if (data.session) {\n            var _data$session = data.session,\n              accessTokenExpiresIn = _data$session.accessTokenExpiresIn,\n              accessToken = _data$session.accessToken;\n            var nextRefresh = new Date(Date.now() + accessTokenExpiresIn * 1e3);\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, nextRefresh.toISOString());\n            return {\n              value: accessToken,\n              expiresAt: nextRefresh\n            };\n          }\n          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null);\n          return {\n            value: null,\n            expiresAt: null\n          };\n        },\n        refreshToken: function refreshToken(_, _ref35) {\n          var data = _ref35.data;\n          var _a;\n          var refreshToken = ((_a = data.session) == null ? void 0 : _a.refreshToken) || null;\n          if (refreshToken) {\n            storageSetter(NHOST_REFRESH_TOKEN_KEY, refreshToken);\n          }\n          return {\n            value: refreshToken\n          };\n        }\n      }),\n      saveMfaTicket: assign({\n        mfa: function mfa(_, e) {\n          var _a;\n          return (_a = e.data) == null ? void 0 : _a.mfa;\n        }\n      }),\n      resetTimer: assign({\n        refreshTimer: function refreshTimer(_) {\n          return {\n            startedAt: new Date(),\n            attempts: 0,\n            lastAttempt: null\n          };\n        }\n      }),\n      saveRefreshAttempt: assign({\n        refreshTimer: function refreshTimer(ctx, e) {\n          return {\n            startedAt: ctx.refreshTimer.startedAt,\n            attempts: ctx.refreshTimer.attempts + 1,\n            lastAttempt: new Date()\n          };\n        }\n      }),\n      saveAuthenticationError: assign({\n        errors: function errors(_ref36, _ref37) {\n          var _errors = _ref36.errors;\n          var error = _ref37.data.error;\n          return __spreadProps(__spreadValues({}, _errors), {\n            authentication: error\n          });\n        }\n      }),\n      resetErrors: assign({\n        errors: function errors(_) {\n          return {};\n        }\n      }),\n      saveRegistrationError: assign({\n        errors: function errors(_ref38, _ref39) {\n          var _errors2 = _ref38.errors;\n          var error = _ref39.data.error;\n          return __spreadProps(__spreadValues({}, _errors2), {\n            registration: error\n          });\n        }\n      }),\n      destroyRefreshToken: assign({\n        refreshToken: function refreshToken(_) {\n          storageSetter(NHOST_REFRESH_TOKEN_KEY, null);\n          return {\n            value: null\n          };\n        }\n      }),\n      cleanUrl: function cleanUrl() {\n        if (autoSignIn && getParameterByName(\"refreshToken\")) {\n          removeParameterFromWindow(\"refreshToken\");\n          removeParameterFromWindow(\"type\");\n        }\n      },\n      broadcastToken: function broadcastToken(context) {\n        if (autoSignIn) {\n          try {\n            var channel = new BroadcastChannel(\"nhost\");\n            channel.postMessage(context.refreshToken.value);\n          } catch (error) {}\n        }\n      }\n    },\n    guards: {\n      isAnonymous: function isAnonymous(ctx, e) {\n        var _a;\n        return !!((_a = ctx.user) == null ? void 0 : _a.isAnonymous);\n      },\n      isSignedIn: function isSignedIn(ctx) {\n        return !!ctx.user && !!ctx.refreshToken.value && !!ctx.accessToken.value;\n      },\n      noToken: function noToken(ctx) {\n        return !ctx.refreshToken.value;\n      },\n      hasRefreshToken: function hasRefreshToken(ctx) {\n        return !!ctx.refreshToken.value;\n      },\n      isAutoRefreshDisabled: function isAutoRefreshDisabled() {\n        return !autoRefreshToken;\n      },\n      refreshTimerShouldRefresh: function refreshTimerShouldRefresh(ctx) {\n        var expiresAt = ctx.accessToken.expiresAt;\n        if (!expiresAt) {\n          return false;\n        }\n        if (ctx.refreshTimer.lastAttempt) {\n          var elapsed = Date.now() - ctx.refreshTimer.lastAttempt.getTime();\n          return elapsed > REFRESH_TOKEN_RETRY_INTERVAL * 1e3;\n        }\n        if (refreshIntervalTime) {\n          var _elapsed = Date.now() - ctx.refreshTimer.startedAt.getTime();\n          if (_elapsed > refreshIntervalTime * 1e3) {\n            return true;\n          }\n        }\n        var expiresIn = expiresAt.getTime() - Date.now();\n        var remaining = expiresIn - 1e3 * TOKEN_REFRESH_MARGIN;\n        return remaining <= 0;\n      },\n      unverified: function unverified(_, _ref40) {\n        var error = _ref40.data.error;\n        return error.status === 401 && (error.message === \"Email is not verified\" || error.error === \"unverified-user\");\n      },\n      hasSession: function hasSession(_, e) {\n        var _a;\n        return !!((_a = e.data) == null ? void 0 : _a.session);\n      },\n      hasMfaTicket: function hasMfaTicket(_, e) {\n        var _a;\n        return !!((_a = e.data) == null ? void 0 : _a.mfa);\n      }\n    },\n    services: {\n      signInPassword: function signInPassword(_, _ref41) {\n        var email = _ref41.email,\n          password = _ref41.password;\n        if (!isValidEmail(email)) {\n          return Promise.reject({\n            error: INVALID_EMAIL_ERROR\n          });\n        }\n        if (!isValidPassword(password)) {\n          return Promise.reject({\n            error: INVALID_PASSWORD_ERROR\n          });\n        }\n        return postRequest(\"/signin/email-password\", {\n          email: email,\n          password: password\n        });\n      },\n      passwordlessSms: function passwordlessSms(context, _ref42) {\n        var phoneNumber = _ref42.phoneNumber,\n          options = _ref42.options;\n        var _a;\n        if (!isValidPhoneNumber(phoneNumber)) {\n          return Promise.reject({\n            error: INVALID_PHONE_NUMBER_ERROR\n          });\n        }\n        if ((_a = context.user) == null ? void 0 : _a.isAnonymous) {\n          console.warn(\"Deanonymisation from a phone number is not yet implemented in hasura-auth\");\n          return postRequest(\"/user/deanonymize\", {\n            signInMethod: \"passwordless\",\n            connection: \"sms\",\n            phoneNumber: phoneNumber,\n            options: rewriteRedirectTo(clientUrl, options)\n          }, {\n            headers: {\n              authorization: \"Bearer \".concat(context.accessToken.value)\n            }\n          });\n        } else {\n          return postRequest(\"/signin/passwordless/sms\", {\n            phoneNumber: phoneNumber,\n            options: rewriteRedirectTo(clientUrl, options)\n          });\n        }\n      },\n      passwordlessSmsOtp: function passwordlessSmsOtp(_, _ref43) {\n        var phoneNumber = _ref43.phoneNumber,\n          otp = _ref43.otp;\n        if (!isValidPhoneNumber(phoneNumber)) {\n          return Promise.reject({\n            error: INVALID_PHONE_NUMBER_ERROR\n          });\n        }\n        return postRequest(\"/signin/passwordless/sms/otp\", {\n          phoneNumber: phoneNumber,\n          otp: otp\n        });\n      },\n      passwordlessEmail: function passwordlessEmail(context, _ref44) {\n        var email = _ref44.email,\n          options = _ref44.options;\n        var _a;\n        if (!isValidEmail(email)) {\n          return Promise.reject({\n            error: INVALID_EMAIL_ERROR\n          });\n        }\n        if ((_a = context.user) == null ? void 0 : _a.isAnonymous) {\n          return postRequest(\"/user/deanonymize\", {\n            signInMethod: \"passwordless\",\n            connection: \"email\",\n            email: email,\n            options: rewriteRedirectTo(clientUrl, options)\n          }, {\n            headers: {\n              authorization: \"Bearer \".concat(context.accessToken.value)\n            }\n          });\n        } else {\n          return postRequest(\"/signin/passwordless/email\", {\n            email: email,\n            options: rewriteRedirectTo(clientUrl, options)\n          });\n        }\n      },\n      signInAnonymous: function signInAnonymous(_) {\n        return postRequest(\"/signin/anonymous\");\n      },\n      signInMfaTotp: function signInMfaTotp(context, data) {\n        var _a;\n        var ticket = data.ticket || ((_a = context.mfa) == null ? void 0 : _a.ticket);\n        if (!ticket) {\n          return Promise.reject({\n            error: NO_MFA_TICKET_ERROR\n          });\n        }\n        if (!isValidTicket(ticket)) {\n          return Promise.reject({\n            error: INVALID_MFA_TICKET_ERROR\n          });\n        }\n        return postRequest(\"/signin/mfa/totp\", {\n          ticket: ticket,\n          otp: data.otp\n        });\n      },\n      signInSecurityKeyEmail: function () {\n        var _signInSecurityKeyEmail = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(_, _ref45) {\n          var email, options, credential;\n          return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  email = _ref45.email;\n                  if (isValidEmail(email)) {\n                    _context7.next = 3;\n                    break;\n                  }\n                  throw new CodifiedError(INVALID_EMAIL_ERROR);\n                case 3:\n                  _context7.next = 5;\n                  return postRequest(\"/signin/webauthn\", {\n                    email: email\n                  });\n                case 5:\n                  options = _context7.sent;\n                  _context7.prev = 6;\n                  _context7.next = 9;\n                  return startAuthentication(options);\n                case 9:\n                  credential = _context7.sent;\n                  _context7.next = 15;\n                  break;\n                case 12:\n                  _context7.prev = 12;\n                  _context7.t0 = _context7[\"catch\"](6);\n                  throw new CodifiedError(_context7.t0);\n                case 15:\n                  return _context7.abrupt(\"return\", postRequest(\"/signin/webauthn/verify\", {\n                    email: email,\n                    credential: credential\n                  }));\n                case 16:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }\n          }, _callee7, null, [[6, 12]]);\n        }));\n        function signInSecurityKeyEmail(_x15, _x16) {\n          return _signInSecurityKeyEmail.apply(this, arguments);\n        }\n        return signInSecurityKeyEmail;\n      }(),\n      refreshToken: function () {\n        var _refreshToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(ctx, event) {\n          var refreshToken, session;\n          return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n            while (1) {\n              switch (_context8.prev = _context8.next) {\n                case 0:\n                  refreshToken = event.type === \"TRY_TOKEN\" ? event.token : ctx.refreshToken.value;\n                  _context8.next = 3;\n                  return postRequest(\"/token\", {\n                    refreshToken: refreshToken\n                  });\n                case 3:\n                  session = _context8.sent;\n                  return _context8.abrupt(\"return\", {\n                    session: session,\n                    error: null\n                  });\n                case 5:\n                case \"end\":\n                  return _context8.stop();\n              }\n            }\n          }, _callee8);\n        }));\n        function refreshToken(_x17, _x18) {\n          return _refreshToken.apply(this, arguments);\n        }\n        return refreshToken;\n      }(),\n      signout: function signout(ctx, e) {\n        return postRequest(\"/signout\", {\n          refreshToken: ctx.refreshToken.value,\n          all: !!e.all\n        });\n      },\n      signUpEmailPassword: function () {\n        var _signUpEmailPassword = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(context, _ref46) {\n          var email, password, options, _a;\n          return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n            while (1) {\n              switch (_context9.prev = _context9.next) {\n                case 0:\n                  email = _ref46.email, password = _ref46.password, options = _ref46.options;\n                  if (isValidEmail(email)) {\n                    _context9.next = 3;\n                    break;\n                  }\n                  return _context9.abrupt(\"return\", Promise.reject({\n                    error: INVALID_EMAIL_ERROR\n                  }));\n                case 3:\n                  if (isValidPassword(password)) {\n                    _context9.next = 5;\n                    break;\n                  }\n                  return _context9.abrupt(\"return\", Promise.reject({\n                    error: INVALID_PASSWORD_ERROR\n                  }));\n                case 5:\n                  if (!((_a = context.user) == null ? void 0 : _a.isAnonymous)) {\n                    _context9.next = 9;\n                    break;\n                  }\n                  return _context9.abrupt(\"return\", postRequest(\"/user/deanonymize\", {\n                    signInMethod: \"email-password\",\n                    email: email,\n                    password: password,\n                    options: rewriteRedirectTo(clientUrl, options)\n                  }, {\n                    headers: {\n                      authorization: \"Bearer \".concat(context.accessToken.value)\n                    }\n                  }));\n                case 9:\n                  return _context9.abrupt(\"return\", postRequest(\"/signup/email-password\", {\n                    email: email,\n                    password: password,\n                    options: rewriteRedirectTo(clientUrl, options)\n                  }));\n                case 10:\n                case \"end\":\n                  return _context9.stop();\n              }\n            }\n          }, _callee9);\n        }));\n        function signUpEmailPassword(_x19, _x20) {\n          return _signUpEmailPassword.apply(this, arguments);\n        }\n        return signUpEmailPassword;\n      }(),\n      signUpSecurityKey: function () {\n        var _signUpSecurityKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(_, _ref47) {\n          var email, options, nickname, webAuthnOptions, credential;\n          return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n            while (1) {\n              switch (_context10.prev = _context10.next) {\n                case 0:\n                  email = _ref47.email, options = _ref47.options;\n                  if (isValidEmail(email)) {\n                    _context10.next = 3;\n                    break;\n                  }\n                  return _context10.abrupt(\"return\", Promise.reject({\n                    error: INVALID_EMAIL_ERROR\n                  }));\n                case 3:\n                  nickname = options == null ? void 0 : options.nickname;\n                  if (nickname) delete options.nickname;\n                  _context10.next = 7;\n                  return postRequest(\"/signup/webauthn\", {\n                    email: email,\n                    options: options\n                  });\n                case 7:\n                  webAuthnOptions = _context10.sent;\n                  _context10.prev = 8;\n                  _context10.next = 11;\n                  return startRegistration(webAuthnOptions);\n                case 11:\n                  credential = _context10.sent;\n                  _context10.next = 17;\n                  break;\n                case 14:\n                  _context10.prev = 14;\n                  _context10.t0 = _context10[\"catch\"](8);\n                  throw new CodifiedError(_context10.t0);\n                case 17:\n                  return _context10.abrupt(\"return\", postRequest(\"/signup/webauthn/verify\", {\n                    credential: credential,\n                    options: {\n                      redirectTo: options == null ? void 0 : options.redirectTo,\n                      nickname: nickname\n                    }\n                  }));\n                case 18:\n                case \"end\":\n                  return _context10.stop();\n              }\n            }\n          }, _callee10, null, [[8, 14]]);\n        }));\n        function signUpSecurityKey(_x21, _x22) {\n          return _signUpSecurityKey.apply(this, arguments);\n        }\n        return signUpSecurityKey;\n      }(),\n      importRefreshToken: function () {\n        var _importRefreshToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n          var error, urlToken, session, error2, storageToken, _session;\n          return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n            while (1) {\n              switch (_context11.prev = _context11.next) {\n                case 0:\n                  error = null;\n                  if (!autoSignIn) {\n                    _context11.next = 19;\n                    break;\n                  }\n                  urlToken = getParameterByName(\"refreshToken\") || null;\n                  if (!urlToken) {\n                    _context11.next = 16;\n                    break;\n                  }\n                  _context11.prev = 4;\n                  _context11.next = 7;\n                  return postRequest(\"/token\", {\n                    refreshToken: urlToken\n                  });\n                case 7:\n                  session = _context11.sent;\n                  return _context11.abrupt(\"return\", {\n                    session: session,\n                    error: null\n                  });\n                case 11:\n                  _context11.prev = 11;\n                  _context11.t0 = _context11[\"catch\"](4);\n                  error = _context11.t0.error;\n                case 14:\n                  _context11.next = 19;\n                  break;\n                case 16:\n                  error2 = getParameterByName(\"error\");\n                  if (!error2) {\n                    _context11.next = 19;\n                    break;\n                  }\n                  return _context11.abrupt(\"return\", Promise.reject({\n                    session: null,\n                    error: {\n                      status: VALIDATION_ERROR_CODE,\n                      error: error2,\n                      message: getParameterByName(\"errorDescription\") || error2\n                    }\n                  }));\n                case 19:\n                  _context11.next = 21;\n                  return storageGetter(NHOST_REFRESH_TOKEN_KEY);\n                case 21:\n                  storageToken = _context11.sent;\n                  if (!storageToken) {\n                    _context11.next = 33;\n                    break;\n                  }\n                  _context11.prev = 23;\n                  _context11.next = 26;\n                  return postRequest(\"/token\", {\n                    refreshToken: storageToken\n                  });\n                case 26:\n                  _session = _context11.sent;\n                  return _context11.abrupt(\"return\", {\n                    session: _session,\n                    error: null\n                  });\n                case 30:\n                  _context11.prev = 30;\n                  _context11.t1 = _context11[\"catch\"](23);\n                  error = _context11.t1.error;\n                case 33:\n                  return _context11.abrupt(\"return\", Promise.reject({\n                    error: error\n                  }));\n                case 34:\n                case \"end\":\n                  return _context11.stop();\n              }\n            }\n          }, _callee11, null, [[4, 11], [23, 30]]);\n        }));\n        function importRefreshToken() {\n          return _importRefreshToken.apply(this, arguments);\n        }\n        return importRefreshToken;\n      }()\n    }\n  });\n};\nvar AuthClient = /*#__PURE__*/function () {\n  function AuthClient(_a) {\n    var _this3 = this;\n    _classCallCheck(this, AuthClient);\n    var _b = _a,\n      _b$clientStorageType = _b.clientStorageType,\n      clientStorageType = _b$clientStorageType === void 0 ? \"web\" : _b$clientStorageType,\n      _b$autoSignIn = _b.autoSignIn,\n      autoSignIn = _b$autoSignIn === void 0 ? true : _b$autoSignIn,\n      _b$autoRefreshToken = _b.autoRefreshToken,\n      autoRefreshToken = _b$autoRefreshToken === void 0 ? true : _b$autoRefreshToken,\n      _b$start = _b.start,\n      start = _b$start === void 0 ? true : _b$start,\n      backendUrl = _b.backendUrl,\n      clientUrl = _b.clientUrl,\n      devTools = _b.devTools,\n      defaultOptions = __objRest(_b, [\"clientStorageType\", \"autoSignIn\", \"autoRefreshToken\", \"start\", \"backendUrl\", \"clientUrl\", \"devTools\"]);\n    this._subscriptions = /* @__PURE__ */new Set();\n    this.backendUrl = backendUrl;\n    this.clientUrl = clientUrl;\n    this.machine = createAuthMachine(__spreadProps(__spreadValues({}, defaultOptions), {\n      backendUrl: backendUrl,\n      clientUrl: clientUrl,\n      clientStorageType: clientStorageType,\n      autoSignIn: autoSignIn,\n      autoRefreshToken: autoRefreshToken\n    }));\n    if (start) {\n      this.interpreter = interpret(this.machine, {\n        devTools: devTools\n      });\n      this.interpreter.start();\n    }\n    if (typeof window !== \"undefined\" && autoSignIn) {\n      try {\n        this._channel = new BroadcastChannel(\"nhost\");\n        this._channel.addEventListener(\"message\", function (token) {\n          var _a2;\n          var existingToken = (_a2 = _this3.interpreter) == null ? void 0 : _a2.state.context.refreshToken.value;\n          if (_this3.interpreter && token.data !== existingToken) {\n            _this3.interpreter.send(\"TRY_TOKEN\", {\n              token: token.data\n            });\n          }\n        });\n      } catch (error) {}\n    }\n  }\n  _createClass(AuthClient, [{\n    key: \"onStart\",\n    value: function onStart(fn) {\n      if (this.interpreter) {\n        fn(this);\n      } else {\n        this._subscriptions.add(fn);\n      }\n    }\n  }, {\n    key: \"interpreter\",\n    get: function get() {\n      return this._interpreter;\n    },\n    set: function set(interpreter) {\n      var _this4 = this;\n      this._interpreter = interpreter;\n      if (interpreter) {\n        this._subscriptions.forEach(function (fn) {\n          return fn(_this4);\n        });\n      }\n    }\n  }]);\n  return AuthClient;\n}();\nvar isBrowser = typeof window !== \"undefined\";\nvar AuthCookieClient = /*#__PURE__*/function (_AuthClient) {\n  _inherits(AuthCookieClient, _AuthClient);\n  function AuthCookieClient(_c) {\n    _classCallCheck(this, AuthCookieClient);\n    var options = __objRest(_c, []);\n    return _possibleConstructorReturn(this, _getPrototypeOf(AuthCookieClient).call(this, __spreadProps(__spreadValues({}, options), {\n      autoSignIn: isBrowser && options.autoSignIn,\n      autoRefreshToken: isBrowser && options.autoRefreshToken,\n      clientStorageType: \"cookie\"\n    })));\n  }\n  return AuthCookieClient;\n}(AuthClient);\nvar AuthClientSSR = AuthCookieClient;\nvar addSecurityKeyPromise = /*#__PURE__*/function () {\n  var _ref49 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(_ref48, nickname) {\n    var backendUrl, interpreter, api, _yield$api$post, options, credential, _yield$api$post2, key, error;\n    return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n      while (1) {\n        switch (_context12.prev = _context12.next) {\n          case 0:\n            backendUrl = _ref48.backendUrl, interpreter = _ref48.interpreter;\n            api = nhostApiClient(backendUrl);\n            _context12.prev = 2;\n            _context12.next = 5;\n            return api.post(\"/user/webauthn/add\", {}, {\n              headers: {\n                authorization: \"Bearer \".concat(interpreter == null ? void 0 : interpreter.state.context.accessToken.value)\n              }\n            });\n          case 5:\n            _yield$api$post = _context12.sent;\n            options = _yield$api$post.data;\n            _context12.prev = 7;\n            _context12.next = 10;\n            return startRegistration(options);\n          case 10:\n            credential = _context12.sent;\n            _context12.next = 16;\n            break;\n          case 13:\n            _context12.prev = 13;\n            _context12.t0 = _context12[\"catch\"](7);\n            throw new CodifiedError(_context12.t0);\n          case 16:\n            _context12.next = 18;\n            return api.post(\"/user/webauthn/verify\", {\n              credential: credential,\n              nickname: nickname\n            }, {\n              headers: {\n                authorization: \"Bearer \".concat(interpreter == null ? void 0 : interpreter.state.context.accessToken.value)\n              }\n            });\n          case 18:\n            _yield$api$post2 = _context12.sent;\n            key = _yield$api$post2.data;\n            return _context12.abrupt(\"return\", {\n              key: key,\n              isError: false,\n              error: null,\n              isSuccess: true\n            });\n          case 23:\n            _context12.prev = 23;\n            _context12.t1 = _context12[\"catch\"](2);\n            error = _context12.t1.error;\n            return _context12.abrupt(\"return\", {\n              isError: true,\n              error: error,\n              isSuccess: false\n            });\n          case 27:\n          case \"end\":\n            return _context12.stop();\n        }\n      }\n    }, _callee12, null, [[2, 23], [7, 13]]);\n  }));\n  return function addSecurityKeyPromise(_x23, _x24) {\n    return _ref49.apply(this, arguments);\n  };\n}();\nvar changeEmailPromise = /*#__PURE__*/function () {\n  var _ref50 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(interpreter, email, options) {\n    return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            return _context13.abrupt(\"return\", new Promise(function (resolve) {\n              interpreter.send(\"REQUEST\", {\n                email: email,\n                options: options\n              });\n              interpreter.onTransition(function (s) {\n                if (s.matches({\n                  idle: \"error\"\n                })) {\n                  resolve({\n                    error: s.context.error,\n                    isError: true,\n                    needsEmailVerification: false\n                  });\n                } else if (s.matches({\n                  idle: \"success\"\n                })) {\n                  resolve({\n                    error: null,\n                    isError: false,\n                    needsEmailVerification: true\n                  });\n                }\n              });\n            }));\n          case 1:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, _callee13);\n  }));\n  return function changeEmailPromise(_x25, _x26, _x27) {\n    return _ref50.apply(this, arguments);\n  };\n}();\nvar changePasswordPromise = /*#__PURE__*/function () {\n  var _ref51 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(interpreter, password, ticket) {\n    return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n      while (1) {\n        switch (_context14.prev = _context14.next) {\n          case 0:\n            return _context14.abrupt(\"return\", new Promise(function (resolve) {\n              interpreter.send(\"REQUEST\", {\n                password: password,\n                ticket: ticket\n              });\n              interpreter.onTransition(function (state) {\n                if (state.matches({\n                  idle: \"error\"\n                })) {\n                  resolve({\n                    error: state.context.error,\n                    isError: true,\n                    isSuccess: false\n                  });\n                } else if (state.matches({\n                  idle: \"success\"\n                })) {\n                  resolve({\n                    error: null,\n                    isError: false,\n                    isSuccess: true\n                  });\n                }\n              });\n            }));\n          case 1:\n          case \"end\":\n            return _context14.stop();\n        }\n      }\n    }, _callee14);\n  }));\n  return function changePasswordPromise(_x28, _x29, _x30) {\n    return _ref51.apply(this, arguments);\n  };\n}();\nvar generateQrCodePromise = function generateQrCodePromise(service) {\n  return new Promise(function (resolve) {\n    service.send(\"GENERATE\");\n    service.onTransition(function (state) {\n      if (state.matches(\"generated\")) {\n        resolve({\n          error: null,\n          isError: false,\n          isGenerated: true,\n          qrCodeDataUrl: state.context.imageUrl || \"\"\n        });\n      } else if (state.matches({\n        idle: \"error\"\n      })) {\n        resolve({\n          error: state.context.error || null,\n          isError: true,\n          isGenerated: false,\n          qrCodeDataUrl: \"\"\n        });\n      }\n    });\n  });\n};\nvar activateMfaPromise = function activateMfaPromise(service, code) {\n  return new Promise(function (resolve) {\n    service.send(\"ACTIVATE\", {\n      activeMfaType: \"totp\",\n      code: code\n    });\n    service.onTransition(function (state) {\n      if (state.matches({\n        generated: \"activated\"\n      })) {\n        resolve({\n          error: null,\n          isActivated: true,\n          isError: false\n        });\n      } else if (state.matches({\n        generated: {\n          idle: \"error\"\n        }\n      })) {\n        resolve({\n          error: state.context.error,\n          isActivated: false,\n          isError: true\n        });\n      }\n    });\n  });\n};\nvar resetPasswordPromise = /*#__PURE__*/function () {\n  var _ref52 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(interpreter, email, options) {\n    return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n      while (1) {\n        switch (_context15.prev = _context15.next) {\n          case 0:\n            return _context15.abrupt(\"return\", new Promise(function (resolve) {\n              interpreter.send(\"REQUEST\", {\n                email: email,\n                options: options\n              });\n              interpreter.onTransition(function (state) {\n                if (state.matches({\n                  idle: \"error\"\n                })) {\n                  resolve({\n                    error: state.context.error,\n                    isError: true,\n                    isSent: false\n                  });\n                } else if (state.matches({\n                  idle: \"success\"\n                })) {\n                  resolve({\n                    error: null,\n                    isError: false,\n                    isSent: true\n                  });\n                }\n              });\n            }));\n          case 1:\n          case \"end\":\n            return _context15.stop();\n        }\n      }\n    }, _callee15);\n  }));\n  return function resetPasswordPromise(_x31, _x32, _x33) {\n    return _ref52.apply(this, arguments);\n  };\n}();\nvar sendVerificationEmailPromise = function sendVerificationEmailPromise(interpreter, email, options) {\n  return new Promise(function (resolve) {\n    interpreter.send(\"REQUEST\", {\n      email: email,\n      options: options\n    });\n    interpreter.onTransition(function (state) {\n      if (state.matches({\n        idle: \"error\"\n      })) {\n        resolve({\n          error: state.context.error,\n          isError: true,\n          isSent: false\n        });\n      } else if (state.matches({\n        idle: \"success\"\n      })) {\n        resolve({\n          error: null,\n          isError: false,\n          isSent: true\n        });\n      }\n    });\n  });\n};\nvar signInAnonymousPromise = function signInAnonymousPromise(interpreter) {\n  return new Promise(function (resolve) {\n    var _interpreter$send = interpreter.send(\"SIGNIN_ANONYMOUS\"),\n      changed = _interpreter$send.changed;\n    if (!changed) {\n      resolve({\n        isSuccess: false,\n        isError: true,\n        error: USER_ALREADY_SIGNED_IN,\n        user: null,\n        accessToken: null\n      });\n    }\n    interpreter.onTransition(function (state) {\n      if (state.matches({\n        authentication: \"signedIn\"\n      })) {\n        resolve({\n          isSuccess: true,\n          isError: false,\n          error: null,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value\n        });\n      }\n      if (state.matches({\n        authentication: {\n          signedOut: \"failed\"\n        }\n      })) {\n        resolve({\n          isSuccess: false,\n          isError: true,\n          error: state.context.errors.authentication || null,\n          user: null,\n          accessToken: null\n        });\n      }\n    });\n  });\n};\nvar signInEmailPasswordPromise = function signInEmailPasswordPromise(interpreter, email, password) {\n  return new Promise(function (resolve) {\n    var _interpreter$send2 = interpreter.send(\"SIGNIN_PASSWORD\", {\n        email: email,\n        password: password\n      }),\n      changed = _interpreter$send2.changed,\n      context = _interpreter$send2.context;\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        needsMfaOtp: false,\n        mfa: null,\n        user: context.user\n      });\n    }\n    interpreter.onTransition(function (state) {\n      if (state.matches({\n        authentication: {\n          signedOut: \"noErrors\"\n        },\n        registration: {\n          incomplete: \"needsEmailVerification\"\n        }\n      })) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: {\n          signedOut: \"needsMfa\"\n        }\n      })) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: true,\n          mfa: state.context.mfa,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: {\n          signedOut: \"failed\"\n        }\n      })) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: \"signedIn\"\n      })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: state.context.user\n        });\n      }\n    });\n  });\n};\nvar signInEmailPasswordlessPromise = function signInEmailPasswordlessPromise(interpreter, email, options) {\n  return new Promise(function (resolve) {\n    var _interpreter$send3 = interpreter.send(\"PASSWORDLESS_EMAIL\", {\n        email: email,\n        options: options\n      }),\n      changed = _interpreter$send3.changed;\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false\n      });\n    }\n    interpreter.onTransition(function (state) {\n      if (state.matches(\"registration.incomplete.failed\")) {\n        resolve({\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false\n        });\n      } else if (state.matches({\n        authentication: {\n          signedOut: \"noErrors\"\n        },\n        registration: {\n          incomplete: \"needsEmailVerification\"\n        }\n      })) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: true\n        });\n      }\n    });\n  });\n};\nvar signInEmailSecurityKeyPromise = function signInEmailSecurityKeyPromise(interpreter, email) {\n  return new Promise(function (resolve) {\n    var _interpreter$send4 = interpreter.send({\n        type: \"SIGNIN_SECURITY_KEY_EMAIL\",\n        email: email\n      }),\n      changed = _interpreter$send4.changed,\n      context = _interpreter$send4.context;\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      });\n    }\n    interpreter.onTransition(function (state) {\n      if (state.matches({\n        authentication: {\n          signedOut: \"noErrors\"\n        },\n        registration: {\n          incomplete: \"needsEmailVerification\"\n        }\n      })) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: {\n          signedOut: \"failed\"\n        }\n      })) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: \"signedIn\"\n      })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        });\n      }\n    });\n  });\n};\nvar signInMfaTotpPromise = function signInMfaTotpPromise(interpreter, otp, ticket) {\n  return new Promise(function (resolve) {\n    var _interpreter$send5 = interpreter.send(\"SIGNIN_MFA_TOTP\", {\n        otp: otp,\n        ticket: ticket\n      }),\n      changed = _interpreter$send5.changed,\n      context = _interpreter$send5.context;\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: context.user\n      });\n    }\n    interpreter.onTransition(function (state) {\n      if (state.matches({\n        authentication: {\n          signedOut: \"failed\"\n        }\n      })) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: \"signedIn\"\n      })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user\n        });\n      }\n    });\n  });\n};\nvar signInSmsPasswordlessPromise = function signInSmsPasswordlessPromise(interpreter, phoneNumber, options) {\n  return new Promise(function (resolve) {\n    var _interpreter$send6 = interpreter.send(\"PASSWORDLESS_SMS\", {\n        phoneNumber: phoneNumber,\n        options: options\n      }),\n      changed = _interpreter$send6.changed;\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsOtp: false\n      });\n    }\n    interpreter.onTransition(function (state) {\n      if (state.matches(\"registration.incomplete.needsOtp\")) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsOtp: true\n        });\n      } else if (state.matches(\"registration.incomplete.failed\")) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsOtp: false\n        });\n      }\n    });\n  });\n};\nvar signInSmsPasswordlessOtpPromise = function signInSmsPasswordlessOtpPromise(interpreter, phoneNumber, otp) {\n  return new Promise(function (resolve) {\n    var _interpreter$send7 = interpreter.send({\n        type: \"PASSWORDLESS_SMS_OTP\",\n        phoneNumber: phoneNumber,\n        otp: otp\n      }),\n      changed = _interpreter$send7.changed;\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: null,\n        accessToken: null\n      });\n    }\n    interpreter.onTransition(function (state) {\n      if (state.matches({\n        authentication: \"signedIn\"\n      })) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value\n        });\n      } else if (state.matches({\n        registration: {\n          incomplete: \"failed\"\n        }\n      })) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null,\n          accessToken: null\n        });\n      }\n    });\n  });\n};\nvar signOutPromise = /*#__PURE__*/function () {\n  var _ref53 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(interpreter, all) {\n    return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n      while (1) {\n        switch (_context16.prev = _context16.next) {\n          case 0:\n            return _context16.abrupt(\"return\", new Promise(function (resolve) {\n              var _interpreter$send8 = interpreter.send(\"SIGNOUT\", {\n                  all: all\n                }),\n                event = _interpreter$send8.event;\n              if (event.type !== \"SIGNED_OUT\") {\n                return resolve({\n                  isSuccess: false,\n                  isError: true,\n                  error: USER_UNAUTHENTICATED\n                });\n              }\n              interpreter.onTransition(function (state) {\n                if (state.matches({\n                  authentication: {\n                    signedOut: \"success\"\n                  }\n                })) {\n                  resolve({\n                    isSuccess: true,\n                    isError: false,\n                    error: null\n                  });\n                } else if (state.matches(\"authentication.signedOut.failed\")) {\n                  resolve({\n                    isSuccess: false,\n                    isError: true,\n                    error: state.context.errors.signout || null\n                  });\n                }\n              });\n            }));\n          case 1:\n          case \"end\":\n            return _context16.stop();\n        }\n      }\n    }, _callee16);\n  }));\n  return function signOutPromise(_x34, _x35) {\n    return _ref53.apply(this, arguments);\n  };\n}();\nvar signUpEmailPasswordPromise = function signUpEmailPasswordPromise(interpreter, email, password, options) {\n  return new Promise(function (resolve) {\n    var _interpreter$send9 = interpreter.send(\"SIGNUP_EMAIL_PASSWORD\", {\n        email: email,\n        password: password,\n        options: options\n      }),\n      changed = _interpreter$send9.changed,\n      context = _interpreter$send9.context;\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      });\n    }\n    interpreter.onTransition(function (state) {\n      if (state.matches(\"registration.incomplete.failed\")) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: {\n          signedOut: \"noErrors\"\n        },\n        registration: {\n          incomplete: \"needsEmailVerification\"\n        }\n      })) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: \"signedIn\",\n        registration: \"complete\"\n      })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        });\n      }\n    });\n  });\n};\nvar signUpEmailSecurityKeyPromise = function signUpEmailSecurityKeyPromise(interpreter, email, options) {\n  return new Promise(function (resolve) {\n    var _interpreter$send10 = interpreter.send(\"SIGNUP_SECURITY_KEY\", {\n        email: email,\n        options: options\n      }),\n      changed = _interpreter$send10.changed,\n      context = _interpreter$send10.context;\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      });\n    }\n    interpreter.onTransition(function (state) {\n      if (state.matches(\"registration.incomplete.failed\")) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: {\n          signedOut: \"noErrors\"\n        },\n        registration: {\n          incomplete: \"needsEmailVerification\"\n        }\n      })) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: \"signedIn\",\n        registration: \"complete\"\n      })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        });\n      }\n    });\n  });\n};\nexport { AuthClient, AuthClientSSR, AuthCookieClient, CodifiedError, EMAIL_NEEDS_VERIFICATION, INVALID_EMAIL_ERROR, INVALID_MFA_CODE_ERROR, INVALID_MFA_TICKET_ERROR, INVALID_MFA_TYPE_ERROR, INVALID_PASSWORD_ERROR, INVALID_PHONE_NUMBER_ERROR, INVALID_REFRESH_TOKEN, MIN_PASSWORD_LENGTH, NETWORK_ERROR_CODE, NHOST_JWT_EXPIRES_AT_KEY, NHOST_REFRESH_TOKEN_KEY, NO_MFA_TICKET_ERROR, NO_REFRESH_TOKEN, OTHER_ERROR_CODE, REFRESH_TOKEN_RETRY_INTERVAL, REFRESH_TOKEN_RETRY_MAX_ATTEMPTS, STATE_ERROR_CODE, TOKEN_REFRESHER_RUNNING_ERROR, TOKEN_REFRESH_MARGIN, USER_ALREADY_SIGNED_IN, USER_NOT_ANONYMOUS, USER_UNAUTHENTICATED, VALIDATION_ERROR_CODE, activateMfaPromise, addSecurityKeyPromise, changeEmailPromise, changePasswordPromise, createAuthMachine, createChangeEmailMachine, createChangePasswordMachine, createEnableMfaMachine, createResetPasswordMachine, createSendVerificationEmailMachine, encodeQueryParameters, generateQrCodePromise, getParameterByName, localStorageGetter, localStorageSetter, removeParameterFromWindow, resetPasswordPromise, rewriteRedirectTo, sendVerificationEmailPromise, signInAnonymousPromise, signInEmailPasswordPromise, signInEmailPasswordlessPromise, signInEmailSecurityKeyPromise, signInMfaTotpPromise, signInSmsPasswordlessOtpPromise, signInSmsPasswordlessPromise, signOutPromise, signUpEmailPasswordPromise, signUpEmailSecurityKeyPromise };","map":null,"metadata":{},"sourceType":"module"}