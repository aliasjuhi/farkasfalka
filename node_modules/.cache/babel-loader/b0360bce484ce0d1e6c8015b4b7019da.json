{"ast":null,"code":"var _slicedToArray = require(\"C:\\\\Users\\\\Alias\\\\weboldal\\\\web-login\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\nvar _toConsumableArray = require(\"C:\\\\Users\\\\Alias\\\\weboldal\\\\web-login\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Alias\\\\weboldal\\\\web-login\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.graphqlWs = {}));\n})(this, function (exports) {\n  'use strict';\n\n  /** @private */\n  function extendedTypeof(val) {\n    if (val === null) {\n      return 'null';\n    }\n    if (Array.isArray(val)) {\n      return 'array';\n    }\n    return typeof val;\n  }\n  /** @private */\n  function isObject(val) {\n    return extendedTypeof(val) === 'object';\n  }\n  /** @private */\n  function areGraphQLErrors(obj) {\n    return Array.isArray(obj) &&\n    // must be at least one error\n    obj.length > 0 &&\n    // error has at least a message\n    obj.every(function (ob) {\n      return 'message' in ob;\n    });\n  }\n  /**\n   * Limits the WebSocket close event reason to not exceed a length of one frame.\n   * Reference: https://datatracker.ietf.org/doc/html/rfc6455#section-5.2.\n   *\n   * @private\n   */\n  function limitCloseReason(reason, whenTooLong) {\n    return reason.length < 124 ? reason : whenTooLong;\n  }\n\n  /**\n   *\n   * common\n   *\n   */\n  /**\n   * The WebSocket sub-protocol used for the [GraphQL over WebSocket Protocol](/PROTOCOL.md).\n   *\n   * @category Common\n   */\n  var GRAPHQL_TRANSPORT_WS_PROTOCOL = 'graphql-transport-ws';\n  /**\n   * The deprecated subprotocol used by [subscriptions-transport-ws](https://github.com/apollographql/subscriptions-transport-ws).\n   *\n   * @private\n   */\n  var DEPRECATED_GRAPHQL_WS_PROTOCOL = 'graphql-ws';\n  /**\n   * `graphql-ws` expected and standard close codes of the [GraphQL over WebSocket Protocol](/PROTOCOL.md).\n   *\n   * @category Common\n   */\n  exports.CloseCode = void 0;\n  (function (CloseCode) {\n    CloseCode[CloseCode[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n    CloseCode[CloseCode[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n    CloseCode[CloseCode[\"BadRequest\"] = 4400] = \"BadRequest\";\n    CloseCode[CloseCode[\"BadResponse\"] = 4004] = \"BadResponse\";\n    /** Tried subscribing before connect ack */\n    CloseCode[CloseCode[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n    CloseCode[CloseCode[\"Forbidden\"] = 4403] = \"Forbidden\";\n    CloseCode[CloseCode[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n    CloseCode[CloseCode[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n    CloseCode[CloseCode[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n    /** Subscriber distinction is very important */\n    CloseCode[CloseCode[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n    CloseCode[CloseCode[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n  })(exports.CloseCode || (exports.CloseCode = {}));\n  /**\n   * Types of messages allowed to be sent by the client/server over the WS protocol.\n   *\n   * @category Common\n   */\n  exports.MessageType = void 0;\n  (function (MessageType) {\n    MessageType[\"ConnectionInit\"] = \"connection_init\";\n    MessageType[\"ConnectionAck\"] = \"connection_ack\";\n    MessageType[\"Ping\"] = \"ping\";\n    MessageType[\"Pong\"] = \"pong\";\n    MessageType[\"Subscribe\"] = \"subscribe\";\n    MessageType[\"Next\"] = \"next\";\n    MessageType[\"Error\"] = \"error\";\n    MessageType[\"Complete\"] = \"complete\";\n  })(exports.MessageType || (exports.MessageType = {}));\n  /**\n   * Validates the message against the GraphQL over WebSocket Protocol.\n   *\n   * Invalid messages will throw descriptive errors.\n   *\n   * @category Common\n   */\n  function validateMessage(val) {\n    if (!isObject(val)) {\n      throw new Error(\"Message is expected to be an object, but got \".concat(extendedTypeof(val)));\n    }\n    if (!val.type) {\n      throw new Error(\"Message is missing the 'type' property\");\n    }\n    if (typeof val.type !== 'string') {\n      throw new Error(\"Message is expects the 'type' property to be a string, but got \".concat(extendedTypeof(val.type)));\n    }\n    switch (val.type) {\n      case exports.MessageType.ConnectionInit:\n      case exports.MessageType.ConnectionAck:\n      case exports.MessageType.Ping:\n      case exports.MessageType.Pong:\n        {\n          if ('payload' in val && !isObject(val.payload)) {\n            throw new Error(\"\\\"\".concat(val.type, \"\\\" message expects the 'payload' property to be an object or missing, but got \\\"\").concat(val.payload, \"\\\"\"));\n          }\n          break;\n        }\n      case exports.MessageType.Subscribe:\n        {\n          if (typeof val.id !== 'string') {\n            throw new Error(\"\\\"\".concat(val.type, \"\\\" message expects the 'id' property to be a string, but got \").concat(extendedTypeof(val.id)));\n          }\n          if (!val.id) {\n            throw new Error(\"\\\"\".concat(val.type, \"\\\" message requires a non-empty 'id' property\"));\n          }\n          if (!isObject(val.payload)) {\n            throw new Error(\"\\\"\".concat(val.type, \"\\\" message expects the 'payload' property to be an object, but got \").concat(extendedTypeof(val.payload)));\n          }\n          if (typeof val.payload.query !== 'string') {\n            throw new Error(\"\\\"\".concat(val.type, \"\\\" message payload expects the 'query' property to be a string, but got \").concat(extendedTypeof(val.payload.query)));\n          }\n          if (val.payload.variables != null && !isObject(val.payload.variables)) {\n            throw new Error(\"\\\"\".concat(val.type, \"\\\" message payload expects the 'variables' property to be a an object or nullish or missing, but got \").concat(extendedTypeof(val.payload.variables)));\n          }\n          if (val.payload.operationName != null && extendedTypeof(val.payload.operationName) !== 'string') {\n            throw new Error(\"\\\"\".concat(val.type, \"\\\" message payload expects the 'operationName' property to be a string or nullish or missing, but got \").concat(extendedTypeof(val.payload.operationName)));\n          }\n          if (val.payload.extensions != null && !isObject(val.payload.extensions)) {\n            throw new Error(\"\\\"\".concat(val.type, \"\\\" message payload expects the 'extensions' property to be a an object or nullish or missing, but got \").concat(extendedTypeof(val.payload.extensions)));\n          }\n          break;\n        }\n      case exports.MessageType.Next:\n        {\n          if (typeof val.id !== 'string') {\n            throw new Error(\"\\\"\".concat(val.type, \"\\\" message expects the 'id' property to be a string, but got \").concat(extendedTypeof(val.id)));\n          }\n          if (!val.id) {\n            throw new Error(\"\\\"\".concat(val.type, \"\\\" message requires a non-empty 'id' property\"));\n          }\n          if (!isObject(val.payload)) {\n            throw new Error(\"\\\"\".concat(val.type, \"\\\" message expects the 'payload' property to be an object, but got \").concat(extendedTypeof(val.payload)));\n          }\n          break;\n        }\n      case exports.MessageType.Error:\n        {\n          if (typeof val.id !== 'string') {\n            throw new Error(\"\\\"\".concat(val.type, \"\\\" message expects the 'id' property to be a string, but got \").concat(extendedTypeof(val.id)));\n          }\n          if (!val.id) {\n            throw new Error(\"\\\"\".concat(val.type, \"\\\" message requires a non-empty 'id' property\"));\n          }\n          if (!areGraphQLErrors(val.payload)) {\n            throw new Error(\"\\\"\".concat(val.type, \"\\\" message expects the 'payload' property to be an array of GraphQL errors, but got \").concat(JSON.stringify(val.payload)));\n          }\n          break;\n        }\n      case exports.MessageType.Complete:\n        {\n          if (typeof val.id !== 'string') {\n            throw new Error(\"\\\"\".concat(val.type, \"\\\" message expects the 'id' property to be a string, but got \").concat(extendedTypeof(val.id)));\n          }\n          if (!val.id) {\n            throw new Error(\"\\\"\".concat(val.type, \"\\\" message requires a non-empty 'id' property\"));\n          }\n          break;\n        }\n      default:\n        throw new Error(\"Invalid message 'type' property \\\"\".concat(val.type, \"\\\"\"));\n    }\n    return val;\n  }\n  /**\n   * Checks if the provided value is a valid GraphQL over WebSocket message.\n   *\n   * @deprecated Use `validateMessage` instead.\n   *\n   * @category Common\n   */\n  function isMessage(val) {\n    try {\n      validateMessage(val);\n      return true;\n    } catch (_a) {\n      return false;\n    }\n  }\n  /**\n   * Parses the raw websocket message data to a valid message.\n   *\n   * @category Common\n   */\n  function parseMessage(data, reviver) {\n    return validateMessage(typeof data === 'string' ? JSON.parse(data, reviver) : data);\n  }\n  /**\n   * Stringifies a valid message ready to be sent through the socket.\n   *\n   * @category Common\n   */\n  function stringifyMessage(msg, replacer) {\n    validateMessage(msg);\n    return JSON.stringify(msg, replacer);\n  }\n\n  /**\n   *\n   * client\n   *\n   */\n  /**\n   * Creates a disposable GraphQL over WebSocket client.\n   *\n   * @category Client\n   */\n  function createClient(options) {\n    var url = options.url,\n      connectionParams = options.connectionParams,\n      _options$lazy = options.lazy,\n      lazy = _options$lazy === void 0 ? true : _options$lazy,\n      _options$onNonLazyErr = options.onNonLazyError,\n      onNonLazyError = _options$onNonLazyErr === void 0 ? console.error : _options$onNonLazyErr,\n      _options$lazyCloseTim = options.lazyCloseTimeout,\n      lazyCloseTimeoutMs = _options$lazyCloseTim === void 0 ? 0 : _options$lazyCloseTim,\n      _options$keepAlive = options.keepAlive,\n      keepAlive = _options$keepAlive === void 0 ? 0 : _options$keepAlive,\n      disablePong = options.disablePong,\n      _options$connectionAc = options.connectionAckWaitTimeout,\n      connectionAckWaitTimeout = _options$connectionAc === void 0 ? 0 : _options$connectionAc,\n      _options$retryAttempt = options.retryAttempts,\n      retryAttempts = _options$retryAttempt === void 0 ? 5 : _options$retryAttempt,\n      _options$retryWait = options.retryWait,\n      retryWait = _options$retryWait === void 0 ? /*#__PURE__*/function () {\n        var _randomisedExponentialBackoff = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(retries) {\n          var retryDelay, i;\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  retryDelay = 1000; // start with 1s delay\n                  for (i = 0; i < retries; i++) {\n                    retryDelay *= 2;\n                  }\n                  _context.next = 4;\n                  return new Promise(function (resolve) {\n                    return setTimeout(resolve, retryDelay +\n                    // add random timeout from 300ms to 3s\n                    Math.floor(Math.random() * (3000 - 300) + 300));\n                  });\n                case 4:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n        function randomisedExponentialBackoff(_x) {\n          return _randomisedExponentialBackoff.apply(this, arguments);\n        }\n        return randomisedExponentialBackoff;\n      }() : _options$retryWait,\n      _options$shouldRetry = options.shouldRetry,\n      shouldRetry = _options$shouldRetry === void 0 ? isLikeCloseEvent : _options$shouldRetry,\n      isFatalConnectionProblem = options.isFatalConnectionProblem,\n      on = options.on,\n      webSocketImpl = options.webSocketImpl,\n      _options$generateID = options.generateID,\n      generateID = _options$generateID === void 0 ? function generateUUID() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n          var r = Math.random() * 16 | 0,\n            v = c == 'x' ? r : r & 0x3 | 0x8;\n          return v.toString(16);\n        });\n      } : _options$generateID,\n      replacer = options.jsonMessageReplacer,\n      reviver = options.jsonMessageReviver;\n    var ws;\n    if (webSocketImpl) {\n      if (!isWebSocket(webSocketImpl)) {\n        throw new Error('Invalid WebSocket implementation provided');\n      }\n      ws = webSocketImpl;\n    } else if (typeof WebSocket !== 'undefined') {\n      ws = WebSocket;\n    } else if (typeof global !== 'undefined') {\n      ws = global.WebSocket ||\n      // @ts-expect-error: Support more browsers\n      global.MozWebSocket;\n    } else if (typeof window !== 'undefined') {\n      ws = window.WebSocket ||\n      // @ts-expect-error: Support more browsers\n      window.MozWebSocket;\n    }\n    if (!ws) throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n    var WebSocketImpl = ws;\n    // websocket status emitter, subscriptions are handled differently\n    var emitter = function () {\n      var message = function () {\n        var listeners = {};\n        return {\n          on: function on(id, listener) {\n            listeners[id] = listener;\n            return function () {\n              delete listeners[id];\n            };\n          },\n          emit: function emit(message) {\n            var _a;\n            if ('id' in message) (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n          }\n        };\n      }();\n      var listeners = {\n        connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n        opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n        connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n        ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n        pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n        message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n        closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n        error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : []\n      };\n      return {\n        onMessage: message.on,\n        on: function on(event, listener) {\n          var l = listeners[event];\n          l.push(listener);\n          return function () {\n            l.splice(l.indexOf(listener), 1);\n          };\n        },\n        emit: function emit(event) {\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n          // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n          for (var _i = 0, _arr = _toConsumableArray(listeners[event]); _i < _arr.length; _i++) {\n            var listener = _arr[_i];\n            // @ts-expect-error: The args should fit\n            listener.apply(void 0, args);\n          }\n        }\n      };\n    }();\n    // invokes the callback either when an error or closed event is emitted,\n    // first one that gets called prevails, other emissions are ignored\n    function errorOrClosed(cb) {\n      var listening = [\n      // errors are fatal and more critical than close events, throw them first\n      emitter.on('error', function (err) {\n        listening.forEach(function (unlisten) {\n          return unlisten();\n        });\n        cb(err);\n      }),\n      // closes can be graceful and not fatal, throw them second (if error didnt throw)\n      emitter.on('closed', function (event) {\n        listening.forEach(function (unlisten) {\n          return unlisten();\n        });\n        cb(event);\n      })];\n    }\n    var connecting,\n      locks = 0,\n      lazyCloseTimeout,\n      retrying = false,\n      retries = 0,\n      disposed = false;\n    function connect() {\n      return _connect.apply(this, arguments);\n    }\n    /**\n     * Checks the `connect` problem and evaluates if the client should retry.\n     */\n    function _connect() {\n      _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var _yield, _yield2, socket, throwOnClose, release, released;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                // clear the lazy close timeout immediatelly so that close gets debounced\n                // see: https://github.com/enisdenjo/graphql-ws/issues/388\n                clearTimeout(lazyCloseTimeout);\n                _context8.next = 3;\n                return connecting !== null && connecting !== void 0 ? connecting : connecting = new Promise(function (connected, denied) {\n                  return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n                    var socket, connectionAckTimeout, queuedPing, enqueuePing, acknowledged;\n                    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n                      while (1) {\n                        switch (_context7.prev = _context7.next) {\n                          case 0:\n                            enqueuePing = function _enqueuePing() {\n                              if (isFinite(keepAlive) && keepAlive > 0) {\n                                clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n                                queuedPing = setTimeout(function () {\n                                  if (socket.readyState === WebSocketImpl.OPEN) {\n                                    socket.send(stringifyMessage({\n                                      type: exports.MessageType.Ping\n                                    }));\n                                    emitter.emit('ping', false, undefined);\n                                  }\n                                }, keepAlive);\n                              }\n                            };\n                            if (!retrying) {\n                              _context7.next = 8;\n                              break;\n                            }\n                            _context7.next = 4;\n                            return retryWait(retries);\n                          case 4:\n                            if (locks) {\n                              _context7.next = 7;\n                              break;\n                            }\n                            connecting = undefined;\n                            return _context7.abrupt(\"return\", denied({\n                              code: 1000,\n                              reason: 'All Subscriptions Gone'\n                            }));\n                          case 7:\n                            retries++;\n                          case 8:\n                            emitter.emit('connecting');\n                            _context7.t0 = WebSocketImpl;\n                            if (!(typeof url === 'function')) {\n                              _context7.next = 16;\n                              break;\n                            }\n                            _context7.next = 13;\n                            return url();\n                          case 13:\n                            _context7.t1 = _context7.sent;\n                            _context7.next = 17;\n                            break;\n                          case 16:\n                            _context7.t1 = url;\n                          case 17:\n                            _context7.t2 = _context7.t1;\n                            _context7.t3 = GRAPHQL_TRANSPORT_WS_PROTOCOL;\n                            socket = new _context7.t0(_context7.t2, _context7.t3);\n                            errorOrClosed(function (errOrEvent) {\n                              connecting = undefined;\n                              clearTimeout(connectionAckTimeout);\n                              clearTimeout(queuedPing);\n                              denied(errOrEvent);\n                              if (isLikeCloseEvent(errOrEvent) && errOrEvent.code === 4499) {\n                                socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n                                socket.onerror = null;\n                                socket.onclose = null;\n                              }\n                            });\n                            socket.onerror = function (err) {\n                              return emitter.emit('error', err);\n                            };\n                            socket.onclose = function (event) {\n                              return emitter.emit('closed', event);\n                            };\n                            socket.onopen = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n                              var payload;\n                              return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n                                while (1) {\n                                  switch (_context6.prev = _context6.next) {\n                                    case 0:\n                                      _context6.prev = 0;\n                                      emitter.emit('opened', socket);\n                                      if (!(typeof connectionParams === 'function')) {\n                                        _context6.next = 8;\n                                        break;\n                                      }\n                                      _context6.next = 5;\n                                      return connectionParams();\n                                    case 5:\n                                      _context6.t0 = _context6.sent;\n                                      _context6.next = 9;\n                                      break;\n                                    case 8:\n                                      _context6.t0 = connectionParams;\n                                    case 9:\n                                      payload = _context6.t0;\n                                      if (!(socket.readyState !== WebSocketImpl.OPEN)) {\n                                        _context6.next = 12;\n                                        break;\n                                      }\n                                      return _context6.abrupt(\"return\");\n                                    case 12:\n                                      socket.send(stringifyMessage(payload ? {\n                                        type: exports.MessageType.ConnectionInit,\n                                        payload: payload\n                                      } : {\n                                        type: exports.MessageType.ConnectionInit\n                                        // payload is completely absent if not provided\n                                      }, replacer));\n                                      if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {\n                                        connectionAckTimeout = setTimeout(function () {\n                                          socket.close(exports.CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n                                        }, connectionAckWaitTimeout);\n                                      }\n                                      enqueuePing(); // enqueue ping (noop if disabled)\n                                      _context6.next = 21;\n                                      break;\n                                    case 17:\n                                      _context6.prev = 17;\n                                      _context6.t1 = _context6[\"catch\"](0);\n                                      emitter.emit('error', _context6.t1);\n                                      socket.close(exports.CloseCode.InternalClientError, limitCloseReason(_context6.t1 instanceof Error ? _context6.t1.message : new Error(_context6.t1).message, 'Internal client error'));\n                                    case 21:\n                                    case \"end\":\n                                      return _context6.stop();\n                                  }\n                                }\n                              }, _callee6, null, [[0, 17]]);\n                            }));\n                            acknowledged = false;\n                            socket.onmessage = function (_ref5) {\n                              var data = _ref5.data;\n                              try {\n                                var message = parseMessage(data, reviver);\n                                emitter.emit('message', message);\n                                if (message.type === 'ping' || message.type === 'pong') {\n                                  emitter.emit(message.type, true, message.payload); // received\n                                  if (message.type === 'pong') {\n                                    enqueuePing(); // enqueue next ping (noop if disabled)\n                                  } else if (!disablePong) {\n                                    // respond with pong on ping\n                                    socket.send(stringifyMessage(message.payload ? {\n                                      type: exports.MessageType.Pong,\n                                      payload: message.payload\n                                    } : {\n                                      type: exports.MessageType.Pong\n                                      // payload is completely absent if not provided\n                                    }));\n\n                                    emitter.emit('pong', false, message.payload);\n                                  }\n                                  return; // ping and pongs can be received whenever\n                                }\n\n                                if (acknowledged) return; // already connected and acknowledged\n                                if (message.type !== exports.MessageType.ConnectionAck) throw new Error(\"First message cannot be of type \".concat(message.type));\n                                clearTimeout(connectionAckTimeout);\n                                acknowledged = true;\n                                emitter.emit('connected', socket, message.payload); // connected = socket opened + acknowledged\n                                retrying = false; // future lazy connects are not retries\n                                retries = 0; // reset the retries on connect\n                                connected([socket, new Promise(function (_, reject) {\n                                  return errorOrClosed(reject);\n                                })]);\n                              } catch (err) {\n                                socket.onmessage = null; // stop reading messages as soon as reading breaks once\n                                emitter.emit('error', err);\n                                socket.close(exports.CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n                              }\n                            };\n                          case 26:\n                          case \"end\":\n                            return _context7.stop();\n                        }\n                      }\n                    }, _callee7);\n                  }))();\n                });\n              case 3:\n                _yield = _context8.sent;\n                _yield2 = _slicedToArray(_yield, 2);\n                socket = _yield2[0];\n                throwOnClose = _yield2[1];\n                if (!(socket.readyState === WebSocketImpl.CLOSING)) {\n                  _context8.next = 10;\n                  break;\n                }\n                _context8.next = 10;\n                return throwOnClose;\n              case 10:\n                release = function release() {\n                  // releases this connection\n                };\n                released = new Promise(function (resolve) {\n                  return release = resolve;\n                });\n                return _context8.abrupt(\"return\", [socket, release, Promise.race([\n                // wait for\n                released.then(function () {\n                  if (!locks) {\n                    // and if no more locks are present, complete the connection\n                    var complete = function complete() {\n                      return socket.close(1000, 'Normal Closure');\n                    };\n                    if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n                      // if the keepalive is set, allow for the specified calmdown time and\n                      // then complete if the socket is still open.\n                      lazyCloseTimeout = setTimeout(function () {\n                        if (socket.readyState === WebSocketImpl.OPEN) complete();\n                      }, lazyCloseTimeoutMs);\n                    } else {\n                      // otherwise complete immediately\n                      complete();\n                    }\n                  }\n                }),\n                // or\n                throwOnClose])]);\n              case 13:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n      return _connect.apply(this, arguments);\n    }\n    function shouldRetryConnectOrThrow(errOrCloseEvent) {\n      // some close codes are worth reporting immediately\n      if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [exports.CloseCode.InternalServerError, exports.CloseCode.InternalClientError, exports.CloseCode.BadRequest, exports.CloseCode.BadResponse, exports.CloseCode.Unauthorized,\n      // CloseCode.Forbidden, might grant access out after retry\n      exports.CloseCode.SubprotocolNotAcceptable,\n      // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n      // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n      exports.CloseCode.SubscriberAlreadyExists, exports.CloseCode.TooManyInitialisationRequests\n      // 4499, // Terminated, probably because the socket froze, we want to retry\n      ].includes(errOrCloseEvent.code))) throw errOrCloseEvent;\n      // client was disposed, no retries should proceed regardless\n      if (disposed) return false;\n      // normal closure (possibly all subscriptions have completed)\n      // if no locks were acquired in the meantime, shouldnt try again\n      if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000) return locks > 0;\n      // retries are not allowed or we tried to many times, report error\n      if (!retryAttempts || retries >= retryAttempts) throw errOrCloseEvent;\n      // throw non-retryable connection problems\n      if (!shouldRetry(errOrCloseEvent)) throw errOrCloseEvent;\n      // @deprecated throw fatal connection problems immediately\n      if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent)) throw errOrCloseEvent;\n      // looks good, start retrying\n      return retrying = true;\n    }\n    // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n    if (!lazy) {\n      _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _yield$connect, _yield$connect2, throwOnClose;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                locks++;\n              case 1:\n                _context2.prev = 1;\n                _context2.next = 4;\n                return connect();\n              case 4:\n                _yield$connect = _context2.sent;\n                _yield$connect2 = _slicedToArray(_yield$connect, 3);\n                throwOnClose = _yield$connect2[2];\n                _context2.next = 9;\n                return throwOnClose;\n              case 9:\n                _context2.next = 21;\n                break;\n              case 11:\n                _context2.prev = 11;\n                _context2.t0 = _context2[\"catch\"](1);\n                _context2.prev = 13;\n                if (shouldRetryConnectOrThrow(_context2.t0)) {\n                  _context2.next = 16;\n                  break;\n                }\n                return _context2.abrupt(\"return\");\n              case 16:\n                _context2.next = 21;\n                break;\n              case 18:\n                _context2.prev = 18;\n                _context2.t1 = _context2[\"catch\"](13);\n                return _context2.abrupt(\"return\", onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(_context2.t1));\n              case 21:\n                _context2.next = 1;\n                break;\n              case 23:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[1, 11], [13, 18]]);\n      }))();\n    }\n    return {\n      on: emitter.on,\n      subscribe: function subscribe(payload, sink) {\n        var id = generateID(payload);\n        var done = false,\n          errored = false,\n          releaser = function releaser() {\n            // for handling completions before connect\n            locks--;\n            done = true;\n          };\n        _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n          var _ret;\n          return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  locks++;\n                case 1:\n                  _context4.prev = 1;\n                  return _context4.delegateYield( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                    var _yield$connect3, _yield$connect4, socket, release, waitForReleaseOrThrowOnClose, unlisten;\n                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            _context3.next = 2;\n                            return connect();\n                          case 2:\n                            _yield$connect3 = _context3.sent;\n                            _yield$connect4 = _slicedToArray(_yield$connect3, 3);\n                            socket = _yield$connect4[0];\n                            release = _yield$connect4[1];\n                            waitForReleaseOrThrowOnClose = _yield$connect4[2];\n                            if (!done) {\n                              _context3.next = 9;\n                              break;\n                            }\n                            return _context3.abrupt(\"return\", {\n                              v: release()\n                            });\n                          case 9:\n                            unlisten = emitter.onMessage(id, function (message) {\n                              switch (message.type) {\n                                case exports.MessageType.Next:\n                                  {\n                                    sink.next(message.payload);\n                                    return;\n                                  }\n                                case exports.MessageType.Error:\n                                  {\n                                    errored = true, done = true;\n                                    sink.error(message.payload);\n                                    releaser();\n                                    return;\n                                  }\n                                case exports.MessageType.Complete:\n                                  {\n                                    done = true;\n                                    releaser(); // release completes the sink\n                                    return;\n                                  }\n                              }\n                            });\n                            socket.send(stringifyMessage({\n                              id: id,\n                              type: exports.MessageType.Subscribe,\n                              payload: payload\n                            }, replacer));\n                            releaser = function releaser() {\n                              if (!done && socket.readyState === WebSocketImpl.OPEN)\n                                // if not completed already and socket is open, send complete message to server on release\n                                socket.send(stringifyMessage({\n                                  id: id,\n                                  type: exports.MessageType.Complete\n                                }, replacer));\n                              locks--;\n                              done = true;\n                              release();\n                            };\n                            // either the releaser will be called, connection completed and\n                            // the promise resolved or the socket closed and the promise rejected.\n                            // whatever happens though, we want to stop listening for messages\n                            _context3.next = 14;\n                            return waitForReleaseOrThrowOnClose.finally(unlisten);\n                          case 14:\n                            return _context3.abrupt(\"return\", {\n                              v: void 0\n                            });\n                          case 15:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3);\n                  })(), \"t0\", 3);\n                case 3:\n                  _ret = _context4.t0;\n                  if (!(typeof _ret === \"object\")) {\n                    _context4.next = 6;\n                    break;\n                  }\n                  return _context4.abrupt(\"return\", _ret.v);\n                case 6:\n                  _context4.next = 12;\n                  break;\n                case 8:\n                  _context4.prev = 8;\n                  _context4.t1 = _context4[\"catch\"](1);\n                  if (shouldRetryConnectOrThrow(_context4.t1)) {\n                    _context4.next = 12;\n                    break;\n                  }\n                  return _context4.abrupt(\"return\");\n                case 12:\n                  _context4.next = 1;\n                  break;\n                case 14:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, null, [[1, 8]]);\n        }))().then(function () {\n          // delivering either an error or a complete terminates the sequence\n          if (!errored) sink.complete();\n        }) // resolves on release or normal closure\n        .catch(function (err) {\n          sink.error(err);\n        }); // rejects on close events and errors\n        return function () {\n          // dispose only of active subscriptions\n          if (!done) releaser();\n        };\n      },\n      dispose: function () {\n        var _dispose = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n          var _yield$connecting, _yield$connecting2, socket;\n          return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  disposed = true;\n                  if (!connecting) {\n                    _context5.next = 8;\n                    break;\n                  }\n                  _context5.next = 4;\n                  return connecting;\n                case 4:\n                  _yield$connecting = _context5.sent;\n                  _yield$connecting2 = _slicedToArray(_yield$connecting, 1);\n                  socket = _yield$connecting2[0];\n                  socket.close(1000, 'Normal Closure');\n                case 8:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5);\n        }));\n        function dispose() {\n          return _dispose.apply(this, arguments);\n        }\n        return dispose;\n      }(),\n      terminate: function terminate() {\n        if (connecting) {\n          // only if there is a connection\n          emitter.emit('closed', {\n            code: 4499,\n            reason: 'Terminated',\n            wasClean: false\n          });\n        }\n      }\n    };\n  }\n  function isLikeCloseEvent(val) {\n    return isObject(val) && 'code' in val && 'reason' in val;\n  }\n  function isFatalInternalCloseCode(code) {\n    if ([1000, 1001, 1006, 1005, 1012, 1013, 1013 // Bad Gateway\n    ].includes(code)) return false;\n    // all other internal errors are fatal\n    return code >= 1000 && code <= 1999;\n  }\n  function isWebSocket(val) {\n    return typeof val === 'function' && 'constructor' in val && 'CLOSED' in val && 'CLOSING' in val && 'CONNECTING' in val && 'OPEN' in val;\n  }\n  exports.DEPRECATED_GRAPHQL_WS_PROTOCOL = DEPRECATED_GRAPHQL_WS_PROTOCOL;\n  exports.GRAPHQL_TRANSPORT_WS_PROTOCOL = GRAPHQL_TRANSPORT_WS_PROTOCOL;\n  exports.createClient = createClient;\n  exports.isMessage = isMessage;\n  exports.parseMessage = parseMessage;\n  exports.stringifyMessage = stringifyMessage;\n  exports.validateMessage = validateMessage;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}