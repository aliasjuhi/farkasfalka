{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nimport jwt_decode from \"jwt-decode\";\nimport { interpret } from \"xstate\";\nimport { AuthClient, signUpEmailSecurityKeyPromise, signUpEmailPasswordPromise, encodeQueryParameters, rewriteRedirectTo, signInEmailPasswordPromise, EMAIL_NEEDS_VERIFICATION, signInEmailSecurityKeyPromise, signInEmailPasswordlessPromise, signInSmsPasswordlessOtpPromise, signInSmsPasswordlessPromise, signInMfaTotpPromise, signInAnonymousPromise, signOutPromise, createResetPasswordMachine, resetPasswordPromise, createChangePasswordMachine, changePasswordPromise, createSendVerificationEmailMachine, sendVerificationEmailPromise, createChangeEmailMachine, changeEmailPromise, addSecurityKeyPromise, NO_REFRESH_TOKEN, TOKEN_REFRESHER_RUNNING_ERROR, INVALID_REFRESH_TOKEN } from \"@nhost/core\";\nconst isBrowser = () => typeof window !== \"undefined\";\nconst getSession = context => {\n  if (!context || !context.accessToken.value || !context.refreshToken.value || !context.accessToken.expiresAt || !context.user) {\n    return null;\n  }\n  return {\n    accessToken: context.accessToken.value,\n    accessTokenExpiresIn: (context.accessToken.expiresAt.getTime() - Date.now()) / 1e3,\n    refreshToken: context.refreshToken.value,\n    user: context.user\n  };\n};\nconst getAuthenticationResult = _ref => {\n  let {\n    accessToken,\n    isError,\n    user,\n    error\n  } = _ref;\n  if (isError) {\n    return {\n      session: null,\n      error\n    };\n  }\n  if (user && accessToken) {\n    return {\n      session: {\n        accessToken,\n        accessTokenExpiresIn: 0,\n        refreshToken: \"\",\n        user\n      },\n      error: null\n    };\n  }\n  return {\n    session: null,\n    error: null\n  };\n};\nclass HasuraAuthClient {\n  constructor(_ref2) {\n    let {\n      url,\n      autoRefreshToken = true,\n      autoSignIn = true,\n      autoLogin,\n      clientStorage,\n      clientStorageType,\n      clientStorageGetter,\n      clientStorageSetter,\n      refreshIntervalTime,\n      start = true\n    } = _ref2;\n    var _a;\n    this.url = url;\n    this._client = new AuthClient({\n      backendUrl: url,\n      clientUrl: typeof window !== \"undefined\" && ((_a = window.location) == null ? void 0 : _a.origin) || \"\",\n      autoRefreshToken,\n      autoSignIn: typeof autoLogin === \"boolean\" ? autoLogin : autoSignIn,\n      start,\n      clientStorage,\n      clientStorageType,\n      clientStorageGetter,\n      clientStorageSetter,\n      refreshIntervalTime\n    });\n  }\n  async signUp(params) {\n    const interpreter = await this.waitUntilReady();\n    const {\n      email,\n      options\n    } = params;\n    if (\"securityKey\" in params) {\n      return getAuthenticationResult(await signUpEmailSecurityKeyPromise(interpreter, email, options));\n    }\n    return getAuthenticationResult(await signUpEmailPasswordPromise(interpreter, email, params.password, options));\n  }\n  async signIn(params) {\n    const interpreter = await this.waitUntilReady();\n    if (\"provider\" in params) {\n      const {\n        provider,\n        options\n      } = params;\n      const providerUrl = encodeQueryParameters(`${this._client.backendUrl}/signin/provider/${provider}`, rewriteRedirectTo(this._client.clientUrl, options));\n      if (isBrowser()) {\n        window.location.href = providerUrl;\n      }\n      return {\n        providerUrl,\n        provider,\n        session: null,\n        mfa: null,\n        error: null\n      };\n    }\n    if (\"email\" in params && \"password\" in params) {\n      const res = await signInEmailPasswordPromise(interpreter, params.email, params.password);\n      if (res.needsEmailVerification) {\n        return {\n          session: null,\n          mfa: null,\n          error: EMAIL_NEEDS_VERIFICATION\n        };\n      }\n      if (res.needsMfaOtp) {\n        return {\n          session: null,\n          mfa: res.mfa,\n          error: null\n        };\n      }\n      return __spreadProps(__spreadValues({}, getAuthenticationResult(res)), {\n        mfa: null\n      });\n    }\n    if (\"email\" in params && \"securityKey\" in params) {\n      if (params.securityKey !== true) {\n        throw Error(\"securityKey must be true\");\n      }\n      const res = await signInEmailSecurityKeyPromise(interpreter, params.email);\n      return __spreadProps(__spreadValues({}, getAuthenticationResult(res)), {\n        mfa: null\n      });\n    }\n    if (\"email\" in params) {\n      const {\n        email,\n        options\n      } = params;\n      const {\n        error\n      } = await signInEmailPasswordlessPromise(interpreter, email, options);\n      return {\n        session: null,\n        mfa: null,\n        error\n      };\n    }\n    if (\"phoneNumber\" in params && \"otp\" in params) {\n      const res = await signInSmsPasswordlessOtpPromise(interpreter, params.phoneNumber, params.otp);\n      return __spreadProps(__spreadValues({}, getAuthenticationResult(res)), {\n        mfa: null\n      });\n    }\n    if (\"phoneNumber\" in params) {\n      const {\n        error\n      } = await signInSmsPasswordlessPromise(interpreter, params.phoneNumber, params.options);\n      return {\n        error,\n        mfa: null,\n        session: null\n      };\n    }\n    if (\"otp\" in params) {\n      const res = await signInMfaTotpPromise(interpreter, params.otp, params.ticket);\n      return __spreadProps(__spreadValues({}, getAuthenticationResult(res)), {\n        mfa: null\n      });\n    }\n    const anonymousResult = await signInAnonymousPromise(interpreter);\n    return __spreadProps(__spreadValues({}, getAuthenticationResult(anonymousResult)), {\n      mfa: null\n    });\n  }\n  async signOut(params) {\n    const interpreter = await this.waitUntilReady();\n    const {\n      error\n    } = await signOutPromise(interpreter, params == null ? void 0 : params.all);\n    return {\n      error\n    };\n  }\n  async resetPassword(_ref3) {\n    let {\n      email,\n      options\n    } = _ref3;\n    const service = interpret(createResetPasswordMachine(this._client)).start();\n    const {\n      error\n    } = await resetPasswordPromise(service, email, options);\n    return {\n      error\n    };\n  }\n  async changePassword(_ref4) {\n    let {\n      newPassword,\n      ticket\n    } = _ref4;\n    const service = interpret(createChangePasswordMachine(this._client)).start();\n    const {\n      error\n    } = await changePasswordPromise(service, newPassword, ticket);\n    return {\n      error\n    };\n  }\n  async sendVerificationEmail(_ref5) {\n    let {\n      email,\n      options\n    } = _ref5;\n    const service = interpret(createSendVerificationEmailMachine(this._client)).start();\n    const {\n      error\n    } = await sendVerificationEmailPromise(service, email, options);\n    return {\n      error\n    };\n  }\n  async changeEmail(_ref6) {\n    let {\n      newEmail,\n      options\n    } = _ref6;\n    const service = interpret(createChangeEmailMachine(this._client)).start();\n    const {\n      error\n    } = await changeEmailPromise(service, newEmail, options);\n    return {\n      error\n    };\n  }\n  async deanonymize(params) {\n    const interpreter = await this.waitUntilReady();\n    if (params.signInMethod === \"passwordless\") {\n      if (params.connection === \"email\") {\n        const {\n          error\n        } = await signInEmailPasswordlessPromise(interpreter, params.email, params.options);\n        return {\n          error\n        };\n      }\n      if (params.connection === \"sms\") {\n        const {\n          error\n        } = await signInSmsPasswordlessPromise(interpreter, params.phoneNumber, params.options);\n        return {\n          error\n        };\n      }\n    }\n    if (params.signInMethod === \"email-password\") {\n      const {\n        error\n      } = await signUpEmailPasswordPromise(interpreter, params.email, params.password, params.options);\n      return {\n        error\n      };\n    }\n    throw Error(`Unknown deanonymization method`);\n  }\n  async addSecurityKey(nickname) {\n    const {\n      error,\n      key\n    } = await addSecurityKeyPromise(this._client, nickname);\n    return {\n      error,\n      key\n    };\n  }\n  onTokenChanged(fn) {\n    const listen = interpreter => interpreter.onTransition(_ref7 => {\n      let {\n        event,\n        context\n      } = _ref7;\n      if (event.type === \"TOKEN_CHANGED\") {\n        fn(getSession(context));\n      }\n    });\n    if (this._client.interpreter) {\n      const subscription = listen(this._client.interpreter);\n      return () => subscription.stop();\n    } else {\n      this._client.onStart(client => {\n        listen(client.interpreter);\n      });\n      return () => {\n        console.log(\"onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.\");\n      };\n    }\n  }\n  onAuthStateChanged(fn) {\n    const listen = interpreter => interpreter.onTransition(_ref8 => {\n      let {\n        event,\n        context\n      } = _ref8;\n      if (event.type === \"SIGNED_IN\" || event.type === \"SIGNED_OUT\") {\n        fn(event.type, getSession(context));\n      }\n    });\n    if (this._client.interpreter) {\n      const subscription = listen(this._client.interpreter);\n      return () => subscription.stop();\n    } else {\n      this._client.onStart(client => {\n        listen(client.interpreter);\n      });\n      return () => {\n        console.log(\"onAuthStateChanged was added before the interpreter started. Cannot unsubscribe listener.\");\n      };\n    }\n  }\n  isAuthenticated() {\n    var _a;\n    return !!((_a = this._client.interpreter) == null ? void 0 : _a.state.matches({\n      authentication: \"signedIn\"\n    }));\n  }\n  async isAuthenticatedAsync() {\n    const interpreter = await this.waitUntilReady();\n    return interpreter.state.matches({\n      authentication: \"signedIn\"\n    });\n  }\n  getAuthenticationStatus() {\n    if (!this.isReady()) {\n      return {\n        isAuthenticated: false,\n        isLoading: true\n      };\n    }\n    return {\n      isAuthenticated: this.isAuthenticated(),\n      isLoading: false\n    };\n  }\n  getJWTToken() {\n    return this.getAccessToken();\n  }\n  getAccessToken() {\n    var _a, _b;\n    return (_b = (_a = this._client.interpreter) == null ? void 0 : _a.state.context.accessToken.value) != null ? _b : void 0;\n  }\n  getDecodedAccessToken() {\n    const jwt = this.getAccessToken();\n    if (!jwt) return null;\n    return jwt_decode(jwt);\n  }\n  getHasuraClaims() {\n    var _a;\n    return ((_a = this.getDecodedAccessToken()) == null ? void 0 : _a[\"https://hasura.io/jwt/claims\"]) || null;\n  }\n  getHasuraClaim(name) {\n    var _a;\n    return ((_a = this.getHasuraClaims()) == null ? void 0 : _a[name.startsWith(\"x-hasura-\") ? name : `x-hasura-${name}`]) || null;\n  }\n  async refreshSession(refreshToken) {\n    try {\n      const interpreter = await this.waitUntilReady();\n      return new Promise(resolve => {\n        const token = refreshToken || interpreter.state.context.refreshToken.value;\n        if (!token) {\n          return resolve({\n            session: null,\n            error: NO_REFRESH_TOKEN\n          });\n        }\n        const {\n          changed\n        } = interpreter.send(\"TRY_TOKEN\", {\n          token\n        });\n        if (!changed) {\n          return resolve({\n            session: null,\n            error: TOKEN_REFRESHER_RUNNING_ERROR\n          });\n        }\n        interpreter.onTransition(state => {\n          if (state.matches({\n            token: {\n              idle: \"error\"\n            }\n          })) {\n            resolve({\n              session: null,\n              error: INVALID_REFRESH_TOKEN\n            });\n          } else if (state.event.type === \"TOKEN_CHANGED\") {\n            resolve({\n              session: getSession(state.context),\n              error: null\n            });\n          }\n        });\n      });\n    } catch (error) {\n      return {\n        session: null,\n        error: error.message\n      };\n    }\n  }\n  getSession() {\n    var _a, _b;\n    return getSession((_b = (_a = this._client.interpreter) == null ? void 0 : _a.state) == null ? void 0 : _b.context);\n  }\n  getUser() {\n    var _a, _b, _c;\n    return ((_c = (_b = (_a = this._client.interpreter) == null ? void 0 : _a.state) == null ? void 0 : _b.context) == null ? void 0 : _c.user) || null;\n  }\n  waitUntilReady() {\n    const TIMEOUT_IN_SECONS = 15;\n    const interpreter = this._client.interpreter;\n    if (!interpreter) {\n      throw Error(\"Auth interpreter not set\");\n    }\n    if (!interpreter.state.hasTag(\"loading\")) {\n      return Promise.resolve(interpreter);\n    }\n    return new Promise((resolve, reject) => {\n      let timer = setTimeout(() => reject(`The state machine is not yet ready after ${TIMEOUT_IN_SECONS} seconds.`), TIMEOUT_IN_SECONS * 1e3);\n      interpreter.onTransition(state => {\n        if (!state.hasTag(\"loading\")) {\n          clearTimeout(timer);\n          return resolve(interpreter);\n        }\n      });\n    });\n  }\n  isReady() {\n    var _a, _b;\n    return !((_b = (_a = this._client.interpreter) == null ? void 0 : _a.state) == null ? void 0 : _b.hasTag(\"loading\"));\n  }\n  get client() {\n    return this._client;\n  }\n}\nexport { HasuraAuthClient };","map":{"version":3,"mappings":"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","names":["window","context","accessToken","value","refreshToken","expiresAt","user","accessTokenExpiresIn","getTime","Date","now","getAuthenticationResult","isError","error","session","HasuraAuthClient","constructor","url","autoRefreshToken","autoSignIn","autoLogin","clientStorage","clientStorageType","clientStorageGetter","clientStorageSetter","refreshIntervalTime","start","AuthClient","backendUrl","clientUrl","location","origin","signUp","params","waitUntilReady","email","options","signUpEmailSecurityKeyPromise","interpreter","signUpEmailPasswordPromise","password","signIn","provider","providerUrl","encodeQueryParameters","_client","rewriteRedirectTo","isBrowser","href","mfa","res","signInEmailPasswordPromise","needsEmailVerification","EMAIL_NEEDS_VERIFICATION","needsMfaOtp","__spreadProps","securityKey","Error","signInEmailSecurityKeyPromise","signInEmailPasswordlessPromise","signInSmsPasswordlessOtpPromise","phoneNumber","otp","signInSmsPasswordlessPromise","signInMfaTotpPromise","ticket","signInAnonymousPromise","anonymousResult","signOut","signOutPromise","all","resetPassword","service","interpret","createResetPasswordMachine","resetPasswordPromise","changePassword","newPassword","createChangePasswordMachine","changePasswordPromise","sendVerificationEmail","createSendVerificationEmailMachine","sendVerificationEmailPromise","changeEmail","newEmail","createChangeEmailMachine","changeEmailPromise","deanonymize","signInMethod","connection","addSecurityKey","nickname","key","addSecurityKeyPromise","onTokenChanged","fn","onTransition","event","type","subscription","listen","stop","onStart","client","console","log","onAuthStateChanged","getSession","isAuthenticated","state","matches","authentication","isAuthenticatedAsync","getAuthenticationStatus","isReady","isLoading","getJWTToken","getAccessToken","getDecodedAccessToken","jwt","jwt_decode","getHasuraClaims","getHasuraClaim","name","startsWith","refreshSession","Promise","resolve","token","NO_REFRESH_TOKEN","changed","send","TOKEN_REFRESHER_RUNNING_ERROR","idle","INVALID_REFRESH_TOKEN","message","getUser","TIMEOUT_IN_SECONS","hasTag","reject","setTimeout","clearTimeout","timer"],"sources":["C:\\Users\\Alias\\my-nhost-app\\node_modules\\@nhost\\hasura-auth-js\\src\\utils\\helpers.ts","C:\\Users\\Alias\\my-nhost-app\\node_modules\\@nhost\\hasura-auth-js\\src\\hasura-auth-client.ts"],"sourcesContent":["import { AuthContext, NhostSession, SessionActionHandlerResult, SignUpResponse } from '@nhost/core'\n\nexport const isBrowser = () => typeof window !== 'undefined'\n\nexport const getSession = (context?: AuthContext): NhostSession | null => {\n  if (\n    !context ||\n    !context.accessToken.value ||\n    !context.refreshToken.value ||\n    !context.accessToken.expiresAt ||\n    !context.user\n  ) {\n    return null\n  }\n  return {\n    accessToken: context.accessToken.value,\n    accessTokenExpiresIn: (context.accessToken.expiresAt.getTime() - Date.now()) / 1000,\n    refreshToken: context.refreshToken.value,\n    user: context.user\n  }\n}\n\nexport const getAuthenticationResult = ({\n  accessToken,\n  isError,\n  user,\n  error\n}: SessionActionHandlerResult): SignUpResponse => {\n  if (isError) {\n    return {\n      session: null,\n      error\n    }\n  }\n  if (user && accessToken) {\n    return {\n      // TODO either return the refresh token or remove it from the session type\n      session: { accessToken, accessTokenExpiresIn: 0, refreshToken: '', user },\n      error: null\n    }\n  }\n  return { session: null, error: null }\n}\n","import jwt_decode from 'jwt-decode'\nimport { interpret } from 'xstate'\n\nimport {\n  addSecurityKeyPromise,\n  AuthClient,\n  AuthInterpreter,\n  changeEmailPromise,\n  ChangeEmailResponse,\n  changePasswordPromise,\n  ChangePasswordResponse,\n  createChangeEmailMachine,\n  createChangePasswordMachine,\n  createResetPasswordMachine,\n  createSendVerificationEmailMachine,\n  DeanonymizeResponse,\n  EMAIL_NEEDS_VERIFICATION,\n  encodeQueryParameters,\n  ErrorPayload,\n  INVALID_REFRESH_TOKEN,\n  JWTClaims,\n  JWTHasuraClaims,\n  NhostSessionResponse,\n  NO_REFRESH_TOKEN,\n  resetPasswordPromise,\n  ResetPasswordResponse,\n  rewriteRedirectTo,\n  SecurityKey,\n  sendVerificationEmailPromise,\n  SendVerificationEmailResponse,\n  signInAnonymousPromise,\n  signInEmailPasswordlessPromise,\n  signInEmailPasswordPromise,\n  signInEmailSecurityKeyPromise,\n  signInMfaTotpPromise,\n  SignInResponse,\n  signInSmsPasswordlessOtpPromise,\n  signInSmsPasswordlessPromise,\n  signOutPromise,\n  SignOutResponse,\n  signUpEmailPasswordPromise,\n  signUpEmailSecurityKeyPromise,\n  SignUpResponse,\n  TOKEN_REFRESHER_RUNNING_ERROR\n} from '@nhost/core'\n\nimport { getAuthenticationResult, getSession, isBrowser } from './utils/helpers'\nimport {\n  AuthChangedFunction,\n  ChangeEmailParams,\n  ChangePasswordParams,\n  DeanonymizeParams,\n  NhostAuthConstructorParams,\n  OnTokenChangedFunction,\n  ResetPasswordParams,\n  SendVerificationEmailParams,\n  SignInParams,\n  SignUpParams\n} from './utils/types'\n\n/**\n * @alias Auth\n */\nexport class HasuraAuthClient {\n  private _client: AuthClient\n  readonly url: string\n  constructor({\n    url,\n    autoRefreshToken = true,\n    autoSignIn = true,\n    autoLogin,\n    clientStorage,\n    clientStorageType,\n    clientStorageGetter,\n    clientStorageSetter,\n    refreshIntervalTime,\n    start = true\n  }: NhostAuthConstructorParams) {\n    this.url = url\n    this._client = new AuthClient({\n      backendUrl: url,\n      clientUrl: (typeof window !== 'undefined' && window.location?.origin) || '',\n      autoRefreshToken,\n      autoSignIn: typeof autoLogin === 'boolean' ? autoLogin : autoSignIn,\n      start,\n      clientStorage,\n      clientStorageType,\n      clientStorageGetter,\n      clientStorageSetter,\n      refreshIntervalTime\n    })\n  }\n\n  /**\n   * Use `nhost.auth.signUp` to sign up a user using email and password. If you want to sign up a user using passwordless email (Magic Link), SMS, or an OAuth provider, use the `signIn` function instead.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-up\n   */\n  async signUp(params: SignUpParams): Promise<SignUpResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { email, options } = params\n    if ('securityKey' in params) {\n      return getAuthenticationResult(\n        await signUpEmailSecurityKeyPromise(interpreter, email, options)\n      )\n    }\n    return getAuthenticationResult(\n      await signUpEmailPasswordPromise(interpreter, email, params.password, options)\n    )\n  }\n\n  /**\n   * Use `nhost.auth.signIn` to sign in a user using email and password, passwordless (email or sms) or an external provider. `signIn` can be used to sign in a user in various ways depending on the parameters.\n   *\n   * @example\n   * ### Sign in a user using email and password\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using an OAuth provider (e.g: Google or Facebook)\n   * ```ts\n   * nhost.auth.signIn({ provider: 'google' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless email (Magic Link)\n   * ```ts\n   * nhost.auth.signIn({ email: 'joe@example.com' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless SMS\n   * ```ts\n   * // [step 1/2] Passwordless sign in using SMS\n   * nhost.auth.signIn({ phoneNumber: '+11233213123' })\n   *\n   * // [step 2/2] Finish passwordless sign in using SMS (OTP)\n   * nhost.auth.signIn({ phoneNumber: '+11233213123', otp: '123456' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in\n   */\n  async signIn(\n    params: SignInParams\n  ): Promise<SignInResponse & { providerUrl?: string; provider?: string }> {\n    const interpreter = await this.waitUntilReady()\n\n    // * Sign in with a social provider (OAuth)\n    if ('provider' in params) {\n      const { provider, options } = params\n      const providerUrl = encodeQueryParameters(\n        `${this._client.backendUrl}/signin/provider/${provider}`,\n        rewriteRedirectTo(this._client.clientUrl, options as any)\n      )\n      if (isBrowser()) {\n        window.location.href = providerUrl\n      }\n      return { providerUrl, provider, session: null, mfa: null, error: null }\n    }\n\n    // * Email + password\n    if ('email' in params && 'password' in params) {\n      const res = await signInEmailPasswordPromise(interpreter, params.email, params.password)\n      if (res.needsEmailVerification) {\n        return { session: null, mfa: null, error: EMAIL_NEEDS_VERIFICATION }\n      }\n      if (res.needsMfaOtp) {\n        return {\n          session: null,\n          mfa: res.mfa,\n          error: null\n        }\n      }\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    if ('email' in params && 'securityKey' in params) {\n      if (params.securityKey !== true) {\n        throw Error('securityKey must be true')\n      }\n      const res = await signInEmailSecurityKeyPromise(interpreter, params.email)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless Email (magic link)\n    if ('email' in params) {\n      const { email, options } = params\n      const { error } = await signInEmailPasswordlessPromise(interpreter, email, options)\n      return {\n        session: null,\n        mfa: null,\n        error\n      }\n    }\n\n    // * Passwordless SMS: [step 2/2] sign in using SMS OTP\n    if ('phoneNumber' in params && 'otp' in params) {\n      const res = await signInSmsPasswordlessOtpPromise(interpreter, params.phoneNumber, params.otp)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless SMS: [step 1/2] sign in using SMS\n    if ('phoneNumber' in params) {\n      const { error } = await signInSmsPasswordlessPromise(\n        interpreter,\n        params.phoneNumber,\n        params.options\n      )\n      return { error, mfa: null, session: null }\n    }\n\n    // * Email + password MFA TOTP\n    if ('otp' in params) {\n      const res = await signInMfaTotpPromise(interpreter, params.otp, params.ticket)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n    // * Anonymous sign-in\n    const anonymousResult = await signInAnonymousPromise(interpreter)\n    return { ...getAuthenticationResult(anonymousResult), mfa: null }\n  }\n\n  /**\n   * Use `nhost.auth.signOut` to sign out the user.\n   *\n   * @example\n   * ### Sign out the user from current device\n   * ```ts\n   * nhost.auth.signOut()\n   * ```\n   *\n   * @example\n   * ### Sign out the user from all devices\n   * ```ts\n   * nhost.auth.signOut({all: true})\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-out\n   */\n  async signOut(params?: { all?: boolean }): Promise<SignOutResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { error } = await signOutPromise(interpreter, params?.all)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.resetPassword` to reset the password for a user. This will send a reset-password link in an email to the user. When the user clicks the reset-password link the user is automatically signed-in. Once signed-in, the user can change their password using `nhost.auth.changePassword()`.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.resetPassword({email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/reset-password\n   */\n  async resetPassword({ email, options }: ResetPasswordParams): Promise<ResetPasswordResponse> {\n    const service = interpret(createResetPasswordMachine(this._client)).start()\n    const { error } = await resetPasswordPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changePassword` to change the password for the signed-in user. The old password is not needed. In case the user is not signed-in, a password reset ticket needs to be provided.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changePassword({ newPassword: 'new-secret-password' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-password\n   */\n  async changePassword({\n    newPassword,\n    ticket\n  }: ChangePasswordParams): Promise<ChangePasswordResponse> {\n    const service = interpret(createChangePasswordMachine(this._client)).start()\n    const { error } = await changePasswordPromise(service, newPassword, ticket)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.sendVerificationEmail` to send a verification email to the specified email. The email contains a verification-email link. When the user clicks the verification-email link their email is verified.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.sendVerificationEmail({ email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/send-verification-email\n   */\n  async sendVerificationEmail({\n    email,\n    options\n  }: SendVerificationEmailParams): Promise<SendVerificationEmailResponse> {\n    const service = interpret(createSendVerificationEmailMachine(this._client)).start()\n    const { error } = await sendVerificationEmailPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changeEmail` to change a user's email. This will send a confirm-email-change link in an email to the new email. Once the user clicks on the confirm-email-change link the email will be change to the new email.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changeEmail({ newEmail: 'doe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-email\n   */\n  async changeEmail({ newEmail, options }: ChangeEmailParams): Promise<ChangeEmailResponse> {\n    const service = interpret(createChangeEmailMachine(this._client)).start()\n    const { error } = await changeEmailPromise(service, newEmail, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.deanonymize` to deanonymize a user.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.deanonymize({signInMethod: 'email-password', email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/deanonymize\n   */\n  async deanonymize(params: DeanonymizeParams): Promise<DeanonymizeResponse> {\n    const interpreter = await this.waitUntilReady()\n    if (params.signInMethod === 'passwordless') {\n      if (params.connection === 'email') {\n        const { error } = await signInEmailPasswordlessPromise(\n          interpreter,\n          params.email,\n          params.options\n        )\n        return { error }\n      }\n      if (params.connection === 'sms') {\n        const { error } = await signInSmsPasswordlessPromise(\n          interpreter,\n          params.phoneNumber,\n          params.options\n        )\n        return { error }\n      }\n    }\n    if (params.signInMethod === 'email-password') {\n      const { error } = await signUpEmailPasswordPromise(\n        interpreter,\n        params.email,\n        params.password,\n        params.options\n      )\n      return { error }\n    }\n    throw Error(`Unknown deanonymization method`)\n  }\n\n  /**\n   * Use `nhost.auth.addSecurityKey to add a security key to the user, using the WebAuthn API.\n   * @param nickname optional human-readable nickname for the security key\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/add-security-key\n   */\n  async addSecurityKey(\n    nickname?: string\n  ): Promise<{ error: ErrorPayload | null; key?: SecurityKey }> {\n    const { error, key } = await addSecurityKeyPromise(this._client, nickname)\n    return { error, key }\n  }\n\n  /**\n   * Use `nhost.auth.onTokenChanged` to add a custom function that runs every time the access or refresh token is changed.\n   *\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onTokenChanged(() => console.log('The access and refresh token has changed'));\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-token-changed\n   */\n  onTokenChanged(fn: OnTokenChangedFunction): Function {\n    const listen = (interpreter: AuthInterpreter) =>\n      interpreter.onTransition(({ event, context }) => {\n        if (event.type === 'TOKEN_CHANGED') {\n          fn(getSession(context))\n        }\n      })\n\n    if (this._client.interpreter) {\n      const subscription = listen(this._client.interpreter)\n      return () => subscription.stop()\n    } else {\n      this._client.onStart((client) => {\n        listen(client.interpreter as AuthInterpreter)\n      })\n      return () => {\n        console.log(\n          'onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.'\n        )\n      }\n    }\n  }\n\n  /**\n   * Use `nhost.auth.onAuthStateChanged` to add a custom function that runs every time the authentication status of the user changes. E.g. add a custom function that runs every time the authentication status changes from signed-in to signed-out.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onAuthStateChanged((event, session) => {\n   *   console.log(`The auth state has changed. State is now ${event} with session: ${session}`)\n   * });\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-auth-state-changed\n   */\n  onAuthStateChanged(fn: AuthChangedFunction): Function {\n    const listen = (interpreter: AuthInterpreter) =>\n      interpreter.onTransition(({ event, context }) => {\n        if (event.type === 'SIGNED_IN' || event.type === 'SIGNED_OUT') {\n          fn(event.type, getSession(context))\n        }\n      })\n    if (this._client.interpreter) {\n      const subscription = listen(this._client.interpreter)\n      return () => subscription.stop()\n    } else {\n      this._client.onStart((client) => {\n        listen(client.interpreter as AuthInterpreter)\n      })\n      return () => {\n        console.log(\n          'onAuthStateChanged was added before the interpreter started. Cannot unsubscribe listener.'\n        )\n      }\n    }\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticated` to check if the user is authenticated or not.\n   *\n   * Note: `nhost.auth.isAuthenticated()` can return `false` for two reasons:\n   * 1. The user is not authenticated\n   * 2. The user is not authenticated but _might_ be authenticated soon (loading) because there is a network request in transit.\n   *\n   * Use `nhost.auth.getAuthenticationStatus` to get both authentication and loading status.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated = nhost.auth.isAuthenticated();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated\n   */\n  isAuthenticated(): boolean {\n    return !!this._client.interpreter?.state.matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticatedAsync` to wait (await) for any internal authentication network requests to finish and then return the authentication status.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated  = await nhost.auth.isAuthenticatedAsync();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated-async\n   */\n  async isAuthenticatedAsync(): Promise<boolean> {\n    const interpreter = await this.waitUntilReady()\n    return interpreter.state.matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.getAuthenticationStatus` to get the authentication status of the user.\n   *\n   * If `isLoading` is `true`, the client doesn't know whether the user is authenticated yet or not\n   * because some internal authentication network requests have not been resolved yet.\n   *\n   * @example\n   * ```ts\n   * const { isAuthenticated, isLoading } = nhost.auth.getAuthenticationStatus();\n   *\n   * if (isLoading) {\n   *   console.log('Loading...')\n   * }\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-authentication-status\n   */\n  getAuthenticationStatus(): {\n    isAuthenticated: boolean\n    isLoading: boolean\n  } {\n    if (!this.isReady()) {\n      return { isAuthenticated: false, isLoading: true }\n    }\n    return { isAuthenticated: this.isAuthenticated(), isLoading: false }\n  }\n\n  /**\n   * @internal\n   * @deprecated Use `nhost.auth.getAccessToken()` instead.\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token\n   */\n\n  getJWTToken(): string | undefined {\n    return this.getAccessToken()\n  }\n\n  /**\n   * Use `nhost.auth.getAccessToken` to get the access token of the user.\n   *\n   * @example\n   * ```ts\n   * const accessToken = nhost.auth.getAccessToken();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token\n   */\n  getAccessToken(): string | undefined {\n    return this._client.interpreter?.state.context.accessToken.value ?? undefined\n  }\n\n  /**\n   * Use `nhost.auth.getDecodedAccessToken` to get the decoded access token of the user.\n   *\n   * @example\n   * ```ts\n   * const decodedAccessToken = nhost.auth.getDecodedAccessToken();\n   * ```\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-decoded-access-token\n   */\n  public getDecodedAccessToken(): JWTClaims | null {\n    const jwt = this.getAccessToken()\n    if (!jwt) return null\n    return jwt_decode<JWTClaims>(jwt)\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaims` to get the Hasura claims of the user.\n   *\n   * @example\n   * ```ts\n   * const hasuraClaims = nhost.auth.getHasuraClaims();\n   * ```\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claims\n   */\n  public getHasuraClaims(): JWTHasuraClaims | null {\n    return this.getDecodedAccessToken()?.['https://hasura.io/jwt/claims'] || null\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaim` to get the value of a specific Hasura claim of the user.\n   *\n   * @example\n   * ```ts\n   * // if `x-hasura-company-id` exists as a custom claim\n   * const companyId = nhost.auth.getHsauraClaim('company-id')\n   * ```\n   *\n   * @param name Name of the variable. You don't have to specify `x-hasura-`.\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claim\n   */\n  public getHasuraClaim(name: string): string | string[] | null {\n    return (\n      this.getHasuraClaims()?.[name.startsWith('x-hasura-') ? name : `x-hasura-${name}`] || null\n    )\n  }\n\n  /**\n   *\n   * Use `nhost.auth.refreshSession` to refresh the session with either the current internal refresh token or an external refresh token.\n   *\n   * Note: The Nhost client automatically refreshes the session when the user is authenticated but `nhost.auth.refreshSession` can be useful in some special cases.\n   *\n   * @example\n   * ```ts\n   * // Refresh the session with the the current internal refresh token.\n   * nhost.auth.refreshToken();\n   *\n   * // Refresh the session with an external refresh token.\n   * nhost.auth.refreshToken(refreshToken);\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/refresh-session\n   */\n  async refreshSession(refreshToken?: string): Promise<NhostSessionResponse> {\n    try {\n      const interpreter = await this.waitUntilReady()\n      return new Promise((resolve) => {\n        const token = refreshToken || interpreter.state.context.refreshToken.value\n        if (!token) {\n          return resolve({ session: null, error: NO_REFRESH_TOKEN })\n        }\n        const { changed } = interpreter.send('TRY_TOKEN', { token })\n        if (!changed) {\n          return resolve({ session: null, error: TOKEN_REFRESHER_RUNNING_ERROR })\n        }\n        interpreter.onTransition((state) => {\n          if (state.matches({ token: { idle: 'error' } })) {\n            resolve({\n              session: null,\n              // * TODO get the error from xstate once it is implemented\n              error: INVALID_REFRESH_TOKEN\n            })\n          } else if (state.event.type === 'TOKEN_CHANGED') {\n            resolve({ session: getSession(state.context), error: null })\n          }\n        })\n      })\n    } catch (error: any) {\n      // TODO return error in the correct format\n      return { session: null, error: error.message }\n    }\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getSession()` to get the session of the user.\n   *\n   * @example\n   * ```ts\n   * const session = nhost.auth.getSession();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-session\n   */\n  getSession() {\n    return getSession(this._client.interpreter?.state?.context)\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getUser()` to get the signed-in user.\n   *\n   * @example\n   * ```ts\n   * const user = nhost.auth.getUser();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-user\n   */\n  getUser() {\n    return this._client.interpreter?.state?.context?.user || null\n  }\n\n  /**\n   * Make sure the state machine is set, and wait for it to be ready\n   * @returns\n   */\n  private waitUntilReady(): Promise<AuthInterpreter> {\n    const TIMEOUT_IN_SECONS = 15\n    const interpreter = this._client.interpreter\n    if (!interpreter) {\n      throw Error('Auth interpreter not set')\n    }\n    if (!interpreter.state.hasTag('loading')) {\n      return Promise.resolve(interpreter)\n    }\n    return new Promise((resolve, reject) => {\n      let timer: ReturnType<typeof setTimeout> = setTimeout(\n        () => reject(`The state machine is not yet ready after ${TIMEOUT_IN_SECONS} seconds.`),\n        TIMEOUT_IN_SECONS * 1_000\n      )\n      interpreter.onTransition((state) => {\n        if (!state.hasTag('loading')) {\n          clearTimeout(timer)\n          return resolve(interpreter)\n        }\n      })\n    })\n  }\n\n  private isReady() {\n    return !this._client.interpreter?.state?.hasTag('loading')\n  }\n\n  get client() {\n    return this._client\n  }\n}\n"]},"metadata":{},"sourceType":"module"}