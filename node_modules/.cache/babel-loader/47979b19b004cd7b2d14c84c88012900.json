{"ast":null,"code":"import _slicedToArray from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n *\n * client\n *\n */\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, parseMessage, stringifyMessage } from './common.mjs';\nimport { isObject, limitCloseReason } from './utils.mjs';\n/** This file is the entry point for browsers, re-export common elements. */\nexport * from './common.mjs';\n/**\n * Creates a disposable GraphQL over WebSocket client.\n *\n * @category Client\n */\nexport function createClient(options) {\n  var url = options.url,\n    connectionParams = options.connectionParams,\n    _options$lazy = options.lazy,\n    lazy = _options$lazy === void 0 ? true : _options$lazy,\n    _options$onNonLazyErr = options.onNonLazyError,\n    onNonLazyError = _options$onNonLazyErr === void 0 ? console.error : _options$onNonLazyErr,\n    _options$lazyCloseTim = options.lazyCloseTimeout,\n    lazyCloseTimeoutMs = _options$lazyCloseTim === void 0 ? 0 : _options$lazyCloseTim,\n    _options$keepAlive = options.keepAlive,\n    keepAlive = _options$keepAlive === void 0 ? 0 : _options$keepAlive,\n    disablePong = options.disablePong,\n    _options$connectionAc = options.connectionAckWaitTimeout,\n    connectionAckWaitTimeout = _options$connectionAc === void 0 ? 0 : _options$connectionAc,\n    _options$retryAttempt = options.retryAttempts,\n    retryAttempts = _options$retryAttempt === void 0 ? 5 : _options$retryAttempt,\n    _options$retryWait = options.retryWait,\n    retryWait = _options$retryWait === void 0 ? /*#__PURE__*/function () {\n      var _randomisedExponentialBackoff = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(retries) {\n        var retryDelay, i;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                retryDelay = 1000; // start with 1s delay\n                for (i = 0; i < retries; i++) {\n                  retryDelay *= 2;\n                }\n                _context.next = 4;\n                return new Promise(function (resolve) {\n                  return setTimeout(resolve, retryDelay +\n                  // add random timeout from 300ms to 3s\n                  Math.floor(Math.random() * (3000 - 300) + 300));\n                });\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      function randomisedExponentialBackoff(_x) {\n        return _randomisedExponentialBackoff.apply(this, arguments);\n      }\n      return randomisedExponentialBackoff;\n    }() : _options$retryWait,\n    _options$shouldRetry = options.shouldRetry,\n    shouldRetry = _options$shouldRetry === void 0 ? isLikeCloseEvent : _options$shouldRetry,\n    isFatalConnectionProblem = options.isFatalConnectionProblem,\n    on = options.on,\n    webSocketImpl = options.webSocketImpl,\n    _options$generateID = options.generateID,\n    generateID = _options$generateID === void 0 ? function generateUUID() {\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0,\n          v = c == 'x' ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n      });\n    } : _options$generateID,\n    replacer = options.jsonMessageReplacer,\n    reviver = options.jsonMessageReviver;\n  var ws;\n  if (webSocketImpl) {\n    if (!isWebSocket(webSocketImpl)) {\n      throw new Error('Invalid WebSocket implementation provided');\n    }\n    ws = webSocketImpl;\n  } else if (typeof WebSocket !== 'undefined') {\n    ws = WebSocket;\n  } else if (typeof global !== 'undefined') {\n    ws = global.WebSocket ||\n    // @ts-expect-error: Support more browsers\n    global.MozWebSocket;\n  } else if (typeof window !== 'undefined') {\n    ws = window.WebSocket ||\n    // @ts-expect-error: Support more browsers\n    window.MozWebSocket;\n  }\n  if (!ws) throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n  var WebSocketImpl = ws;\n  // websocket status emitter, subscriptions are handled differently\n  var emitter = function () {\n    var message = function () {\n      var listeners = {};\n      return {\n        on: function on(id, listener) {\n          listeners[id] = listener;\n          return function () {\n            delete listeners[id];\n          };\n        },\n        emit: function emit(message) {\n          var _a;\n          if ('id' in message) (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n        }\n      };\n    }();\n    var listeners = {\n      connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n      opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n      connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n      ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n      pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n      message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n      closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n      error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : []\n    };\n    return {\n      onMessage: message.on,\n      on: function on(event, listener) {\n        var l = listeners[event];\n        l.push(listener);\n        return function () {\n          l.splice(l.indexOf(listener), 1);\n        };\n      },\n      emit: function emit(event) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n        for (var _i = 0, _arr = _toConsumableArray(listeners[event]); _i < _arr.length; _i++) {\n          var listener = _arr[_i];\n          // @ts-expect-error: The args should fit\n          listener.apply(void 0, args);\n        }\n      }\n    };\n  }();\n  // invokes the callback either when an error or closed event is emitted,\n  // first one that gets called prevails, other emissions are ignored\n  function errorOrClosed(cb) {\n    var listening = [\n    // errors are fatal and more critical than close events, throw them first\n    emitter.on('error', function (err) {\n      listening.forEach(function (unlisten) {\n        return unlisten();\n      });\n      cb(err);\n    }),\n    // closes can be graceful and not fatal, throw them second (if error didnt throw)\n    emitter.on('closed', function (event) {\n      listening.forEach(function (unlisten) {\n        return unlisten();\n      });\n      cb(event);\n    })];\n  }\n  var connecting,\n    locks = 0,\n    lazyCloseTimeout,\n    retrying = false,\n    retries = 0,\n    disposed = false;\n  function connect() {\n    return _connect.apply(this, arguments);\n  }\n  /**\n   * Checks the `connect` problem and evaluates if the client should retry.\n   */\n  function _connect() {\n    _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n      var _yield, _yield2, socket, throwOnClose, release, released;\n      return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              // clear the lazy close timeout immediatelly so that close gets debounced\n              // see: https://github.com/enisdenjo/graphql-ws/issues/388\n              clearTimeout(lazyCloseTimeout);\n              _context8.next = 3;\n              return connecting !== null && connecting !== void 0 ? connecting : connecting = new Promise(function (connected, denied) {\n                return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n                  var socket, connectionAckTimeout, queuedPing, enqueuePing, acknowledged;\n                  return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n                    while (1) {\n                      switch (_context7.prev = _context7.next) {\n                        case 0:\n                          enqueuePing = function _enqueuePing() {\n                            if (isFinite(keepAlive) && keepAlive > 0) {\n                              clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n                              queuedPing = setTimeout(function () {\n                                if (socket.readyState === WebSocketImpl.OPEN) {\n                                  socket.send(stringifyMessage({\n                                    type: MessageType.Ping\n                                  }));\n                                  emitter.emit('ping', false, undefined);\n                                }\n                              }, keepAlive);\n                            }\n                          };\n                          if (!retrying) {\n                            _context7.next = 8;\n                            break;\n                          }\n                          _context7.next = 4;\n                          return retryWait(retries);\n                        case 4:\n                          if (locks) {\n                            _context7.next = 7;\n                            break;\n                          }\n                          connecting = undefined;\n                          return _context7.abrupt(\"return\", denied({\n                            code: 1000,\n                            reason: 'All Subscriptions Gone'\n                          }));\n                        case 7:\n                          retries++;\n                        case 8:\n                          emitter.emit('connecting');\n                          _context7.t0 = WebSocketImpl;\n                          if (!(typeof url === 'function')) {\n                            _context7.next = 16;\n                            break;\n                          }\n                          _context7.next = 13;\n                          return url();\n                        case 13:\n                          _context7.t1 = _context7.sent;\n                          _context7.next = 17;\n                          break;\n                        case 16:\n                          _context7.t1 = url;\n                        case 17:\n                          _context7.t2 = _context7.t1;\n                          _context7.t3 = GRAPHQL_TRANSPORT_WS_PROTOCOL;\n                          socket = new _context7.t0(_context7.t2, _context7.t3);\n                          errorOrClosed(function (errOrEvent) {\n                            connecting = undefined;\n                            clearTimeout(connectionAckTimeout);\n                            clearTimeout(queuedPing);\n                            denied(errOrEvent);\n                            if (isLikeCloseEvent(errOrEvent) && errOrEvent.code === 4499) {\n                              socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n                              socket.onerror = null;\n                              socket.onclose = null;\n                            }\n                          });\n                          socket.onerror = function (err) {\n                            return emitter.emit('error', err);\n                          };\n                          socket.onclose = function (event) {\n                            return emitter.emit('closed', event);\n                          };\n                          socket.onopen = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n                            var payload;\n                            return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n                              while (1) {\n                                switch (_context6.prev = _context6.next) {\n                                  case 0:\n                                    _context6.prev = 0;\n                                    emitter.emit('opened', socket);\n                                    if (!(typeof connectionParams === 'function')) {\n                                      _context6.next = 8;\n                                      break;\n                                    }\n                                    _context6.next = 5;\n                                    return connectionParams();\n                                  case 5:\n                                    _context6.t0 = _context6.sent;\n                                    _context6.next = 9;\n                                    break;\n                                  case 8:\n                                    _context6.t0 = connectionParams;\n                                  case 9:\n                                    payload = _context6.t0;\n                                    if (!(socket.readyState !== WebSocketImpl.OPEN)) {\n                                      _context6.next = 12;\n                                      break;\n                                    }\n                                    return _context6.abrupt(\"return\");\n                                  case 12:\n                                    socket.send(stringifyMessage(payload ? {\n                                      type: MessageType.ConnectionInit,\n                                      payload: payload\n                                    } : {\n                                      type: MessageType.ConnectionInit\n                                      // payload is completely absent if not provided\n                                    }, replacer));\n                                    if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {\n                                      connectionAckTimeout = setTimeout(function () {\n                                        socket.close(CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n                                      }, connectionAckWaitTimeout);\n                                    }\n                                    enqueuePing(); // enqueue ping (noop if disabled)\n                                    _context6.next = 21;\n                                    break;\n                                  case 17:\n                                    _context6.prev = 17;\n                                    _context6.t1 = _context6[\"catch\"](0);\n                                    emitter.emit('error', _context6.t1);\n                                    socket.close(CloseCode.InternalClientError, limitCloseReason(_context6.t1 instanceof Error ? _context6.t1.message : new Error(_context6.t1).message, 'Internal client error'));\n                                  case 21:\n                                  case \"end\":\n                                    return _context6.stop();\n                                }\n                              }\n                            }, _callee6, null, [[0, 17]]);\n                          }));\n                          acknowledged = false;\n                          socket.onmessage = function (_ref5) {\n                            var data = _ref5.data;\n                            try {\n                              var message = parseMessage(data, reviver);\n                              emitter.emit('message', message);\n                              if (message.type === 'ping' || message.type === 'pong') {\n                                emitter.emit(message.type, true, message.payload); // received\n                                if (message.type === 'pong') {\n                                  enqueuePing(); // enqueue next ping (noop if disabled)\n                                } else if (!disablePong) {\n                                  // respond with pong on ping\n                                  socket.send(stringifyMessage(message.payload ? {\n                                    type: MessageType.Pong,\n                                    payload: message.payload\n                                  } : {\n                                    type: MessageType.Pong\n                                    // payload is completely absent if not provided\n                                  }));\n\n                                  emitter.emit('pong', false, message.payload);\n                                }\n                                return; // ping and pongs can be received whenever\n                              }\n\n                              if (acknowledged) return; // already connected and acknowledged\n                              if (message.type !== MessageType.ConnectionAck) throw new Error(\"First message cannot be of type \".concat(message.type));\n                              clearTimeout(connectionAckTimeout);\n                              acknowledged = true;\n                              emitter.emit('connected', socket, message.payload); // connected = socket opened + acknowledged\n                              retrying = false; // future lazy connects are not retries\n                              retries = 0; // reset the retries on connect\n                              connected([socket, new Promise(function (_, reject) {\n                                return errorOrClosed(reject);\n                              })]);\n                            } catch (err) {\n                              socket.onmessage = null; // stop reading messages as soon as reading breaks once\n                              emitter.emit('error', err);\n                              socket.close(CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n                            }\n                          };\n                        case 26:\n                        case \"end\":\n                          return _context7.stop();\n                      }\n                    }\n                  }, _callee7);\n                }))();\n              });\n            case 3:\n              _yield = _context8.sent;\n              _yield2 = _slicedToArray(_yield, 2);\n              socket = _yield2[0];\n              throwOnClose = _yield2[1];\n              if (!(socket.readyState === WebSocketImpl.CLOSING)) {\n                _context8.next = 10;\n                break;\n              }\n              _context8.next = 10;\n              return throwOnClose;\n            case 10:\n              release = function release() {\n                // releases this connection\n              };\n              released = new Promise(function (resolve) {\n                return release = resolve;\n              });\n              return _context8.abrupt(\"return\", [socket, release, Promise.race([\n              // wait for\n              released.then(function () {\n                if (!locks) {\n                  // and if no more locks are present, complete the connection\n                  var complete = function complete() {\n                    return socket.close(1000, 'Normal Closure');\n                  };\n                  if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n                    // if the keepalive is set, allow for the specified calmdown time and\n                    // then complete if the socket is still open.\n                    lazyCloseTimeout = setTimeout(function () {\n                      if (socket.readyState === WebSocketImpl.OPEN) complete();\n                    }, lazyCloseTimeoutMs);\n                  } else {\n                    // otherwise complete immediately\n                    complete();\n                  }\n                }\n              }),\n              // or\n              throwOnClose])]);\n            case 13:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _callee8);\n    }));\n    return _connect.apply(this, arguments);\n  }\n  function shouldRetryConnectOrThrow(errOrCloseEvent) {\n    // some close codes are worth reporting immediately\n    if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [CloseCode.InternalServerError, CloseCode.InternalClientError, CloseCode.BadRequest, CloseCode.BadResponse, CloseCode.Unauthorized,\n    // CloseCode.Forbidden, might grant access out after retry\n    CloseCode.SubprotocolNotAcceptable,\n    // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n    // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n    CloseCode.SubscriberAlreadyExists, CloseCode.TooManyInitialisationRequests\n    // 4499, // Terminated, probably because the socket froze, we want to retry\n    ].includes(errOrCloseEvent.code))) throw errOrCloseEvent;\n    // client was disposed, no retries should proceed regardless\n    if (disposed) return false;\n    // normal closure (possibly all subscriptions have completed)\n    // if no locks were acquired in the meantime, shouldnt try again\n    if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000) return locks > 0;\n    // retries are not allowed or we tried to many times, report error\n    if (!retryAttempts || retries >= retryAttempts) throw errOrCloseEvent;\n    // throw non-retryable connection problems\n    if (!shouldRetry(errOrCloseEvent)) throw errOrCloseEvent;\n    // @deprecated throw fatal connection problems immediately\n    if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent)) throw errOrCloseEvent;\n    // looks good, start retrying\n    return retrying = true;\n  }\n  // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n  if (!lazy) {\n    _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n      var _yield$connect, _yield$connect2, throwOnClose;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              locks++;\n            case 1:\n              _context2.prev = 1;\n              _context2.next = 4;\n              return connect();\n            case 4:\n              _yield$connect = _context2.sent;\n              _yield$connect2 = _slicedToArray(_yield$connect, 3);\n              throwOnClose = _yield$connect2[2];\n              _context2.next = 9;\n              return throwOnClose;\n            case 9:\n              _context2.next = 21;\n              break;\n            case 11:\n              _context2.prev = 11;\n              _context2.t0 = _context2[\"catch\"](1);\n              _context2.prev = 13;\n              if (shouldRetryConnectOrThrow(_context2.t0)) {\n                _context2.next = 16;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 16:\n              _context2.next = 21;\n              break;\n            case 18:\n              _context2.prev = 18;\n              _context2.t1 = _context2[\"catch\"](13);\n              return _context2.abrupt(\"return\", onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(_context2.t1));\n            case 21:\n              _context2.next = 1;\n              break;\n            case 23:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[1, 11], [13, 18]]);\n    }))();\n  }\n  return {\n    on: emitter.on,\n    subscribe: function subscribe(payload, sink) {\n      var id = generateID(payload);\n      var done = false,\n        errored = false,\n        releaser = function releaser() {\n          // for handling completions before connect\n          locks--;\n          done = true;\n        };\n      _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _ret;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                locks++;\n              case 1:\n                _context4.prev = 1;\n                return _context4.delegateYield( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                  var _yield$connect3, _yield$connect4, socket, release, waitForReleaseOrThrowOnClose, unlisten;\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) {\n                      switch (_context3.prev = _context3.next) {\n                        case 0:\n                          _context3.next = 2;\n                          return connect();\n                        case 2:\n                          _yield$connect3 = _context3.sent;\n                          _yield$connect4 = _slicedToArray(_yield$connect3, 3);\n                          socket = _yield$connect4[0];\n                          release = _yield$connect4[1];\n                          waitForReleaseOrThrowOnClose = _yield$connect4[2];\n                          if (!done) {\n                            _context3.next = 9;\n                            break;\n                          }\n                          return _context3.abrupt(\"return\", {\n                            v: release()\n                          });\n                        case 9:\n                          unlisten = emitter.onMessage(id, function (message) {\n                            switch (message.type) {\n                              case MessageType.Next:\n                                {\n                                  sink.next(message.payload);\n                                  return;\n                                }\n                              case MessageType.Error:\n                                {\n                                  errored = true, done = true;\n                                  sink.error(message.payload);\n                                  releaser();\n                                  return;\n                                }\n                              case MessageType.Complete:\n                                {\n                                  done = true;\n                                  releaser(); // release completes the sink\n                                  return;\n                                }\n                            }\n                          });\n                          socket.send(stringifyMessage({\n                            id: id,\n                            type: MessageType.Subscribe,\n                            payload: payload\n                          }, replacer));\n                          releaser = function releaser() {\n                            if (!done && socket.readyState === WebSocketImpl.OPEN)\n                              // if not completed already and socket is open, send complete message to server on release\n                              socket.send(stringifyMessage({\n                                id: id,\n                                type: MessageType.Complete\n                              }, replacer));\n                            locks--;\n                            done = true;\n                            release();\n                          };\n                          // either the releaser will be called, connection completed and\n                          // the promise resolved or the socket closed and the promise rejected.\n                          // whatever happens though, we want to stop listening for messages\n                          _context3.next = 14;\n                          return waitForReleaseOrThrowOnClose.finally(unlisten);\n                        case 14:\n                          return _context3.abrupt(\"return\", {\n                            v: void 0\n                          });\n                        case 15:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }\n                  }, _callee3);\n                })(), \"t0\", 3);\n              case 3:\n                _ret = _context4.t0;\n                if (!(typeof _ret === \"object\")) {\n                  _context4.next = 6;\n                  break;\n                }\n                return _context4.abrupt(\"return\", _ret.v);\n              case 6:\n                _context4.next = 12;\n                break;\n              case 8:\n                _context4.prev = 8;\n                _context4.t1 = _context4[\"catch\"](1);\n                if (shouldRetryConnectOrThrow(_context4.t1)) {\n                  _context4.next = 12;\n                  break;\n                }\n                return _context4.abrupt(\"return\");\n              case 12:\n                _context4.next = 1;\n                break;\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, null, [[1, 8]]);\n      }))().then(function () {\n        // delivering either an error or a complete terminates the sequence\n        if (!errored) sink.complete();\n      }) // resolves on release or normal closure\n      .catch(function (err) {\n        sink.error(err);\n      }); // rejects on close events and errors\n      return function () {\n        // dispose only of active subscriptions\n        if (!done) releaser();\n      };\n    },\n    dispose: function dispose() {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _yield$connecting, _yield$connecting2, socket;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                disposed = true;\n                if (!connecting) {\n                  _context5.next = 8;\n                  break;\n                }\n                _context5.next = 4;\n                return connecting;\n              case 4:\n                _yield$connecting = _context5.sent;\n                _yield$connecting2 = _slicedToArray(_yield$connecting, 1);\n                socket = _yield$connecting2[0];\n                socket.close(1000, 'Normal Closure');\n              case 8:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }))();\n    },\n    terminate: function terminate() {\n      if (connecting) {\n        // only if there is a connection\n        emitter.emit('closed', {\n          code: 4499,\n          reason: 'Terminated',\n          wasClean: false\n        });\n      }\n    }\n  };\n}\nfunction isLikeCloseEvent(val) {\n  return isObject(val) && 'code' in val && 'reason' in val;\n}\nfunction isFatalInternalCloseCode(code) {\n  if ([1000, 1001, 1006, 1005, 1012, 1013, 1013 // Bad Gateway\n  ].includes(code)) return false;\n  // all other internal errors are fatal\n  return code >= 1000 && code <= 1999;\n}\nfunction isWebSocket(val) {\n  return typeof val === 'function' && 'constructor' in val && 'CLOSED' in val && 'CLOSING' in val && 'CONNECTING' in val && 'OPEN' in val;\n}","map":{"version":3,"names":["GRAPHQL_TRANSPORT_WS_PROTOCOL","CloseCode","MessageType","parseMessage","stringifyMessage","isObject","limitCloseReason","createClient","options","url","connectionParams","lazy","onNonLazyError","console","error","lazyCloseTimeout","lazyCloseTimeoutMs","keepAlive","disablePong","connectionAckWaitTimeout","retryAttempts","retryWait","retries","retryDelay","i","Promise","resolve","setTimeout","Math","floor","random","randomisedExponentialBackoff","shouldRetry","isLikeCloseEvent","isFatalConnectionProblem","on","webSocketImpl","generateID","generateUUID","replace","c","r","v","toString","replacer","jsonMessageReplacer","reviver","jsonMessageReviver","ws","isWebSocket","Error","WebSocket","global","MozWebSocket","window","WebSocketImpl","emitter","message","listeners","id","listener","emit","_a","call","connecting","opened","connected","ping","pong","closed","onMessage","event","l","push","splice","indexOf","args","errorOrClosed","cb","listening","err","forEach","unlisten","locks","retrying","disposed","connect","clearTimeout","denied","enqueuePing","isFinite","queuedPing","socket","readyState","OPEN","send","type","Ping","undefined","code","reason","errOrEvent","connectionAckTimeout","close","onerror","onclose","onopen","payload","ConnectionInit","ConnectionAcknowledgementTimeout","InternalClientError","acknowledged","onmessage","data","Pong","ConnectionAck","_","reject","BadResponse","throwOnClose","CLOSING","release","released","race","then","complete","shouldRetryConnectOrThrow","errOrCloseEvent","isFatalInternalCloseCode","InternalServerError","BadRequest","Unauthorized","SubprotocolNotAcceptable","SubscriberAlreadyExists","TooManyInitialisationRequests","includes","subscribe","sink","done","errored","releaser","waitForReleaseOrThrowOnClose","Next","next","Complete","Subscribe","finally","catch","dispose","terminate","wasClean","val"],"sources":["C:/Users/Alias/weboldal/web-login/node_modules/graphql-ws/lib/client.mjs"],"sourcesContent":["/**\n *\n * client\n *\n */\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, parseMessage, stringifyMessage, } from './common.mjs';\nimport { isObject, limitCloseReason } from './utils.mjs';\n/** This file is the entry point for browsers, re-export common elements. */\nexport * from './common.mjs';\n/**\n * Creates a disposable GraphQL over WebSocket client.\n *\n * @category Client\n */\nexport function createClient(options) {\n    const { url, connectionParams, lazy = true, onNonLazyError = console.error, lazyCloseTimeout: lazyCloseTimeoutMs = 0, keepAlive = 0, disablePong, connectionAckWaitTimeout = 0, retryAttempts = 5, retryWait = async function randomisedExponentialBackoff(retries) {\n        let retryDelay = 1000; // start with 1s delay\n        for (let i = 0; i < retries; i++) {\n            retryDelay *= 2;\n        }\n        await new Promise((resolve) => setTimeout(resolve, retryDelay +\n            // add random timeout from 300ms to 3s\n            Math.floor(Math.random() * (3000 - 300) + 300)));\n    }, shouldRetry = isLikeCloseEvent, isFatalConnectionProblem, on, webSocketImpl, \n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }, jsonMessageReplacer: replacer, jsonMessageReviver: reviver, } = options;\n    let ws;\n    if (webSocketImpl) {\n        if (!isWebSocket(webSocketImpl)) {\n            throw new Error('Invalid WebSocket implementation provided');\n        }\n        ws = webSocketImpl;\n    }\n    else if (typeof WebSocket !== 'undefined') {\n        ws = WebSocket;\n    }\n    else if (typeof global !== 'undefined') {\n        ws =\n            global.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                global.MozWebSocket;\n    }\n    else if (typeof window !== 'undefined') {\n        ws =\n            window.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                window.MozWebSocket;\n    }\n    if (!ws)\n        throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n    const WebSocketImpl = ws;\n    // websocket status emitter, subscriptions are handled differently\n    const emitter = (() => {\n        const message = (() => {\n            const listeners = {};\n            return {\n                on(id, listener) {\n                    listeners[id] = listener;\n                    return () => {\n                        delete listeners[id];\n                    };\n                },\n                emit(message) {\n                    var _a;\n                    if ('id' in message)\n                        (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n                },\n            };\n        })();\n        const listeners = {\n            connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n            opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n            connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n            ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n            pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n            message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n            closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n            error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : [],\n        };\n        return {\n            onMessage: message.on,\n            on(event, listener) {\n                const l = listeners[event];\n                l.push(listener);\n                return () => {\n                    l.splice(l.indexOf(listener), 1);\n                };\n            },\n            emit(event, ...args) {\n                // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n                for (const listener of [...listeners[event]]) {\n                    // @ts-expect-error: The args should fit\n                    listener(...args);\n                }\n            },\n        };\n    })();\n    // invokes the callback either when an error or closed event is emitted,\n    // first one that gets called prevails, other emissions are ignored\n    function errorOrClosed(cb) {\n        const listening = [\n            // errors are fatal and more critical than close events, throw them first\n            emitter.on('error', (err) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(err);\n            }),\n            // closes can be graceful and not fatal, throw them second (if error didnt throw)\n            emitter.on('closed', (event) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(event);\n            }),\n        ];\n    }\n    let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;\n    async function connect() {\n        // clear the lazy close timeout immediatelly so that close gets debounced\n        // see: https://github.com/enisdenjo/graphql-ws/issues/388\n        clearTimeout(lazyCloseTimeout);\n        const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : (connecting = new Promise((connected, denied) => (async () => {\n            if (retrying) {\n                await retryWait(retries);\n                // subscriptions might complete while waiting for retry\n                if (!locks) {\n                    connecting = undefined;\n                    return denied({ code: 1000, reason: 'All Subscriptions Gone' });\n                }\n                retries++;\n            }\n            emitter.emit('connecting');\n            const socket = new WebSocketImpl(typeof url === 'function' ? await url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);\n            let connectionAckTimeout, queuedPing;\n            function enqueuePing() {\n                if (isFinite(keepAlive) && keepAlive > 0) {\n                    clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n                    queuedPing = setTimeout(() => {\n                        if (socket.readyState === WebSocketImpl.OPEN) {\n                            socket.send(stringifyMessage({ type: MessageType.Ping }));\n                            emitter.emit('ping', false, undefined);\n                        }\n                    }, keepAlive);\n                }\n            }\n            errorOrClosed((errOrEvent) => {\n                connecting = undefined;\n                clearTimeout(connectionAckTimeout);\n                clearTimeout(queuedPing);\n                denied(errOrEvent);\n                if (isLikeCloseEvent(errOrEvent) && errOrEvent.code === 4499) {\n                    socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n                    socket.onerror = null;\n                    socket.onclose = null;\n                }\n            });\n            socket.onerror = (err) => emitter.emit('error', err);\n            socket.onclose = (event) => emitter.emit('closed', event);\n            socket.onopen = async () => {\n                try {\n                    emitter.emit('opened', socket);\n                    const payload = typeof connectionParams === 'function'\n                        ? await connectionParams()\n                        : connectionParams;\n                    // connectionParams might take too long causing the server to kick off the client\n                    // the necessary error/close event is already reported - simply stop execution\n                    if (socket.readyState !== WebSocketImpl.OPEN)\n                        return;\n                    socket.send(stringifyMessage(payload\n                        ? {\n                            type: MessageType.ConnectionInit,\n                            payload,\n                        }\n                        : {\n                            type: MessageType.ConnectionInit,\n                            // payload is completely absent if not provided\n                        }, replacer));\n                    if (isFinite(connectionAckWaitTimeout) &&\n                        connectionAckWaitTimeout > 0) {\n                        connectionAckTimeout = setTimeout(() => {\n                            socket.close(CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n                        }, connectionAckWaitTimeout);\n                    }\n                    enqueuePing(); // enqueue ping (noop if disabled)\n                }\n                catch (err) {\n                    emitter.emit('error', err);\n                    socket.close(CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n                }\n            };\n            let acknowledged = false;\n            socket.onmessage = ({ data }) => {\n                try {\n                    const message = parseMessage(data, reviver);\n                    emitter.emit('message', message);\n                    if (message.type === 'ping' || message.type === 'pong') {\n                        emitter.emit(message.type, true, message.payload); // received\n                        if (message.type === 'pong') {\n                            enqueuePing(); // enqueue next ping (noop if disabled)\n                        }\n                        else if (!disablePong) {\n                            // respond with pong on ping\n                            socket.send(stringifyMessage(message.payload\n                                ? {\n                                    type: MessageType.Pong,\n                                    payload: message.payload,\n                                }\n                                : {\n                                    type: MessageType.Pong,\n                                    // payload is completely absent if not provided\n                                }));\n                            emitter.emit('pong', false, message.payload);\n                        }\n                        return; // ping and pongs can be received whenever\n                    }\n                    if (acknowledged)\n                        return; // already connected and acknowledged\n                    if (message.type !== MessageType.ConnectionAck)\n                        throw new Error(`First message cannot be of type ${message.type}`);\n                    clearTimeout(connectionAckTimeout);\n                    acknowledged = true;\n                    emitter.emit('connected', socket, message.payload); // connected = socket opened + acknowledged\n                    retrying = false; // future lazy connects are not retries\n                    retries = 0; // reset the retries on connect\n                    connected([\n                        socket,\n                        new Promise((_, reject) => errorOrClosed(reject)),\n                    ]);\n                }\n                catch (err) {\n                    socket.onmessage = null; // stop reading messages as soon as reading breaks once\n                    emitter.emit('error', err);\n                    socket.close(CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n                }\n            };\n        })())));\n        // if the provided socket is in a closing state, wait for the throw on close\n        if (socket.readyState === WebSocketImpl.CLOSING)\n            await throwOnClose;\n        let release = () => {\n            // releases this connection\n        };\n        const released = new Promise((resolve) => (release = resolve));\n        return [\n            socket,\n            release,\n            Promise.race([\n                // wait for\n                released.then(() => {\n                    if (!locks) {\n                        // and if no more locks are present, complete the connection\n                        const complete = () => socket.close(1000, 'Normal Closure');\n                        if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n                            // if the keepalive is set, allow for the specified calmdown time and\n                            // then complete if the socket is still open.\n                            lazyCloseTimeout = setTimeout(() => {\n                                if (socket.readyState === WebSocketImpl.OPEN)\n                                    complete();\n                            }, lazyCloseTimeoutMs);\n                        }\n                        else {\n                            // otherwise complete immediately\n                            complete();\n                        }\n                    }\n                }),\n                // or\n                throwOnClose,\n            ]),\n        ];\n    }\n    /**\n     * Checks the `connect` problem and evaluates if the client should retry.\n     */\n    function shouldRetryConnectOrThrow(errOrCloseEvent) {\n        // some close codes are worth reporting immediately\n        if (isLikeCloseEvent(errOrCloseEvent) &&\n            (isFatalInternalCloseCode(errOrCloseEvent.code) ||\n                [\n                    CloseCode.InternalServerError,\n                    CloseCode.InternalClientError,\n                    CloseCode.BadRequest,\n                    CloseCode.BadResponse,\n                    CloseCode.Unauthorized,\n                    // CloseCode.Forbidden, might grant access out after retry\n                    CloseCode.SubprotocolNotAcceptable,\n                    // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n                    // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n                    CloseCode.SubscriberAlreadyExists,\n                    CloseCode.TooManyInitialisationRequests,\n                    // 4499, // Terminated, probably because the socket froze, we want to retry\n                ].includes(errOrCloseEvent.code)))\n            throw errOrCloseEvent;\n        // client was disposed, no retries should proceed regardless\n        if (disposed)\n            return false;\n        // normal closure (possibly all subscriptions have completed)\n        // if no locks were acquired in the meantime, shouldnt try again\n        if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000)\n            return locks > 0;\n        // retries are not allowed or we tried to many times, report error\n        if (!retryAttempts || retries >= retryAttempts)\n            throw errOrCloseEvent;\n        // throw non-retryable connection problems\n        if (!shouldRetry(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // @deprecated throw fatal connection problems immediately\n        if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // looks good, start retrying\n        return (retrying = true);\n    }\n    // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n    if (!lazy) {\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const [, , throwOnClose] = await connect();\n                    await throwOnClose; // will always throw because releaser is not used\n                }\n                catch (errOrCloseEvent) {\n                    try {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                            return;\n                    }\n                    catch (errOrCloseEvent) {\n                        // report thrown error, no further retries\n                        return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n                    }\n                }\n            }\n        })();\n    }\n    return {\n        on: emitter.on,\n        subscribe(payload, sink) {\n            const id = generateID(payload);\n            let done = false, errored = false, releaser = () => {\n                // for handling completions before connect\n                locks--;\n                done = true;\n            };\n            (async () => {\n                locks++;\n                for (;;) {\n                    try {\n                        const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n                        // if done while waiting for connect, release the connection lock right away\n                        if (done)\n                            return release();\n                        const unlisten = emitter.onMessage(id, (message) => {\n                            switch (message.type) {\n                                case MessageType.Next: {\n                                    sink.next(message.payload);\n                                    return;\n                                }\n                                case MessageType.Error: {\n                                    (errored = true), (done = true);\n                                    sink.error(message.payload);\n                                    releaser();\n                                    return;\n                                }\n                                case MessageType.Complete: {\n                                    done = true;\n                                    releaser(); // release completes the sink\n                                    return;\n                                }\n                            }\n                        });\n                        socket.send(stringifyMessage({\n                            id,\n                            type: MessageType.Subscribe,\n                            payload,\n                        }, replacer));\n                        releaser = () => {\n                            if (!done && socket.readyState === WebSocketImpl.OPEN)\n                                // if not completed already and socket is open, send complete message to server on release\n                                socket.send(stringifyMessage({\n                                    id,\n                                    type: MessageType.Complete,\n                                }, replacer));\n                            locks--;\n                            done = true;\n                            release();\n                        };\n                        // either the releaser will be called, connection completed and\n                        // the promise resolved or the socket closed and the promise rejected.\n                        // whatever happens though, we want to stop listening for messages\n                        await waitForReleaseOrThrowOnClose.finally(unlisten);\n                        return; // completed, shouldnt try again\n                    }\n                    catch (errOrCloseEvent) {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                            return;\n                    }\n                }\n            })()\n                .then(() => {\n                // delivering either an error or a complete terminates the sequence\n                if (!errored)\n                    sink.complete();\n            }) // resolves on release or normal closure\n                .catch((err) => {\n                sink.error(err);\n            }); // rejects on close events and errors\n            return () => {\n                // dispose only of active subscriptions\n                if (!done)\n                    releaser();\n            };\n        },\n        async dispose() {\n            disposed = true;\n            if (connecting) {\n                // if there is a connection, close it\n                const [socket] = await connecting;\n                socket.close(1000, 'Normal Closure');\n            }\n        },\n        terminate() {\n            if (connecting) {\n                // only if there is a connection\n                emitter.emit('closed', {\n                    code: 4499,\n                    reason: 'Terminated',\n                    wasClean: false,\n                });\n            }\n        },\n    };\n}\nfunction isLikeCloseEvent(val) {\n    return isObject(val) && 'code' in val && 'reason' in val;\n}\nfunction isFatalInternalCloseCode(code) {\n    if ([\n        1000,\n        1001,\n        1006,\n        1005,\n        1012,\n        1013,\n        1013, // Bad Gateway\n    ].includes(code))\n        return false;\n    // all other internal errors are fatal\n    return code >= 1000 && code <= 1999;\n}\nfunction isWebSocket(val) {\n    return (typeof val === 'function' &&\n        'constructor' in val &&\n        'CLOSED' in val &&\n        'CLOSING' in val &&\n        'CONNECTING' in val &&\n        'OPEN' in val);\n}\n"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA,SAASA,6BAA6B,EAAEC,SAAS,EAAEC,WAAW,EAAEC,YAAY,EAAEC,gBAAgB,QAAS,cAAc;AACrH,SAASC,QAAQ,EAAEC,gBAAgB,QAAQ,aAAa;AACxD;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,YAAY,CAACC,OAAO,EAAE;EAClC,IAAQC,GAAG,GAqBwDD,OAAO,CArBlEC,GAAG;IAAEC,gBAAgB,GAqBsCF,OAAO,CArB7DE,gBAAgB;IAAA,gBAqBsCF,OAAO,CArB3CG,IAAI;IAAJA,IAAI,8BAAG,IAAI;IAAA,wBAqByBH,OAAO,CArB9BI,cAAc;IAAdA,cAAc,sCAAGC,OAAO,CAACC,KAAK;IAAA,wBAqBPN,OAAO,CArBEO,gBAAgB;IAAEC,kBAAkB,sCAAG,CAAC;IAAA,qBAqBjDR,OAAO,CArB4CS,SAAS;IAATA,SAAS,mCAAG,CAAC;IAAEC,WAAW,GAqB7EV,OAAO,CArB2DU,WAAW;IAAA,wBAqB7EV,OAAO,CArBwEW,wBAAwB;IAAxBA,wBAAwB,sCAAG,CAAC;IAAA,wBAqB3GX,OAAO,CArBsGY,aAAa;IAAbA,aAAa,sCAAG,CAAC;IAAA,qBAqB9HZ,OAAO,CArByHa,SAAS;IAATA,SAAS;MAAA,+FAAG,iBAA4CC,OAAO;QAAA;QAAA;UAAA;YAAA;cAAA;gBAC1PC,UAAU,GAAG,IAAI,EAAE;gBACvB,KAASC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,OAAO,EAAEE,CAAC,EAAE,EAAE;kBAC9BD,UAAU,IAAI,CAAC;gBACnB;gBAAC;gBAAA,OACK,IAAIE,OAAO,CAAC,UAACC,OAAO;kBAAA,OAAKC,UAAU,CAACD,OAAO,EAAEH,UAAU;kBACzD;kBACAK,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,EAAE,IAAI,IAAI,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;gBAAA,EAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACvD;MAAA,SAR6NC,4BAA4B;QAAA;MAAA;MAAA,OAA5BA,4BAA4B;IAAA;IAAA,uBAqBvLvB,OAAO,CAbvEwB,WAAW;IAAXA,WAAW,qCAAGC,gBAAgB;IAAEC,wBAAwB,GAaQ1B,OAAO,CAbvC0B,wBAAwB;IAAEC,EAAE,GAaI3B,OAAO,CAbb2B,EAAE;IAAEC,aAAa,GAaX5B,OAAO,CAbT4B,aAAa;IAAA,sBAaX5B,OAAO,CAL1E6B,UAAU;IAAVA,UAAU,oCAAG,SAASC,YAAY,GAAG;MACjC,OAAO,sCAAsC,CAACC,OAAO,CAAC,OAAO,EAAE,UAACC,CAAC,EAAK;QAClE,IAAMC,CAAC,GAAIb,IAAI,CAACE,MAAM,EAAE,GAAG,EAAE,GAAI,CAAC;UAAEY,CAAC,GAAGF,CAAC,IAAI,GAAG,GAAGC,CAAC,GAAIA,CAAC,GAAG,GAAG,GAAI,GAAG;QACtE,OAAOC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC;MACzB,CAAC,CAAC;IACN,CAAC;IAAuBC,QAAQ,GAAmCpC,OAAO,CAAvEqC,mBAAmB;IAAgCC,OAAO,GAAMtC,OAAO,CAAxCuC,kBAAkB;EACpD,IAAIC,EAAE;EACN,IAAIZ,aAAa,EAAE;IACf,IAAI,CAACa,WAAW,CAACb,aAAa,CAAC,EAAE;MAC7B,MAAM,IAAIc,KAAK,CAAC,2CAA2C,CAAC;IAChE;IACAF,EAAE,GAAGZ,aAAa;EACtB,CAAC,MACI,IAAI,OAAOe,SAAS,KAAK,WAAW,EAAE;IACvCH,EAAE,GAAGG,SAAS;EAClB,CAAC,MACI,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;IACpCJ,EAAE,GACEI,MAAM,CAACD,SAAS;IACZ;IACAC,MAAM,CAACC,YAAY;EAC/B,CAAC,MACI,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;IACpCN,EAAE,GACEM,MAAM,CAACH,SAAS;IACZ;IACAG,MAAM,CAACD,YAAY;EAC/B;EACA,IAAI,CAACL,EAAE,EACH,MAAM,IAAIE,KAAK,CAAC,uIAAuI,CAAC;EAC5J,IAAMK,aAAa,GAAGP,EAAE;EACxB;EACA,IAAMQ,OAAO,GAAI,YAAM;IACnB,IAAMC,OAAO,GAAI,YAAM;MACnB,IAAMC,SAAS,GAAG,CAAC,CAAC;MACpB,OAAO;QACHvB,EAAE,cAACwB,EAAE,EAAEC,QAAQ,EAAE;UACbF,SAAS,CAACC,EAAE,CAAC,GAAGC,QAAQ;UACxB,OAAO,YAAM;YACT,OAAOF,SAAS,CAACC,EAAE,CAAC;UACxB,CAAC;QACL,CAAC;QACDE,IAAI,gBAACJ,OAAO,EAAE;UACV,IAAIK,EAAE;UACN,IAAI,IAAI,IAAIL,OAAO,EACf,CAACK,EAAE,GAAGJ,SAAS,CAACD,OAAO,CAACE,EAAE,CAAC,MAAM,IAAI,IAAIG,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACC,IAAI,CAACL,SAAS,EAAED,OAAO,CAAC;QACrG;MACJ,CAAC;IACL,CAAC,EAAG;IACJ,IAAMC,SAAS,GAAG;MACdM,UAAU,EAAE,CAAC7B,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC6B,UAAU,IAAI,CAAC7B,EAAE,CAAC6B,UAAU,CAAC,GAAG,EAAE;MAC1FC,MAAM,EAAE,CAAC9B,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC8B,MAAM,IAAI,CAAC9B,EAAE,CAAC8B,MAAM,CAAC,GAAG,EAAE;MAC9EC,SAAS,EAAE,CAAC/B,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC+B,SAAS,IAAI,CAAC/B,EAAE,CAAC+B,SAAS,CAAC,GAAG,EAAE;MACvFC,IAAI,EAAE,CAAChC,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACgC,IAAI,IAAI,CAAChC,EAAE,CAACgC,IAAI,CAAC,GAAG,EAAE;MACxEC,IAAI,EAAE,CAACjC,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACiC,IAAI,IAAI,CAACjC,EAAE,CAACiC,IAAI,CAAC,GAAG,EAAE;MACxEX,OAAO,EAAE,CAACtB,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACsB,OAAO,IAAI,CAACA,OAAO,CAACI,IAAI,EAAE1B,EAAE,CAACsB,OAAO,CAAC,GAAG,CAACA,OAAO,CAACI,IAAI,CAAC;MAC3GQ,MAAM,EAAE,CAAClC,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACkC,MAAM,IAAI,CAAClC,EAAE,CAACkC,MAAM,CAAC,GAAG,EAAE;MAC9EvD,KAAK,EAAE,CAACqB,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACrB,KAAK,IAAI,CAACqB,EAAE,CAACrB,KAAK,CAAC,GAAG;IAC7E,CAAC;IACD,OAAO;MACHwD,SAAS,EAAEb,OAAO,CAACtB,EAAE;MACrBA,EAAE,cAACoC,KAAK,EAAEX,QAAQ,EAAE;QAChB,IAAMY,CAAC,GAAGd,SAAS,CAACa,KAAK,CAAC;QAC1BC,CAAC,CAACC,IAAI,CAACb,QAAQ,CAAC;QAChB,OAAO,YAAM;UACTY,CAAC,CAACE,MAAM,CAACF,CAAC,CAACG,OAAO,CAACf,QAAQ,CAAC,EAAE,CAAC,CAAC;QACpC,CAAC;MACL,CAAC;MACDC,IAAI,gBAACU,KAAK,EAAW;QAAA,kCAANK,IAAI;UAAJA,IAAI;QAAA;QACf;QACA,2CAA2BlB,SAAS,CAACa,KAAK,CAAC,2BAAG;UAAzC,IAAMX,QAAQ;UACf;UACAA,QAAQ,eAAIgB,IAAI,CAAC;QACrB;MACJ;IACJ,CAAC;EACL,CAAC,EAAG;EACJ;EACA;EACA,SAASC,aAAa,CAACC,EAAE,EAAE;IACvB,IAAMC,SAAS,GAAG;IACd;IACAvB,OAAO,CAACrB,EAAE,CAAC,OAAO,EAAE,UAAC6C,GAAG,EAAK;MACzBD,SAAS,CAACE,OAAO,CAAC,UAACC,QAAQ;QAAA,OAAKA,QAAQ,EAAE;MAAA,EAAC;MAC3CJ,EAAE,CAACE,GAAG,CAAC;IACX,CAAC,CAAC;IACF;IACAxB,OAAO,CAACrB,EAAE,CAAC,QAAQ,EAAE,UAACoC,KAAK,EAAK;MAC5BQ,SAAS,CAACE,OAAO,CAAC,UAACC,QAAQ;QAAA,OAAKA,QAAQ,EAAE;MAAA,EAAC;MAC3CJ,EAAE,CAACP,KAAK,CAAC;IACb,CAAC,CAAC,CACL;EACL;EACA,IAAIP,UAAU;IAAEmB,KAAK,GAAG,CAAC;IAAEpE,gBAAgB;IAAEqE,QAAQ,GAAG,KAAK;IAAE9D,OAAO,GAAG,CAAC;IAAE+D,QAAQ,GAAG,KAAK;EAAC,SAC9EC,OAAO;IAAA;EAAA;EA0JtB;AACJ;AACA;EAFI;IAAA,sEA1JA;MAAA;MAAA;QAAA;UAAA;YAAA;cACI;cACA;cACAC,YAAY,CAACxE,gBAAgB,CAAC;cAAC;cAAA,OACOiD,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAGA,UAAU,GAAIA,UAAU,GAAG,IAAIvC,OAAO,CAAC,UAACyC,SAAS,EAAEsB,MAAM;gBAAA,OAAK,2DAAC;kBAAA,8CAavIC,WAAW;kBAAA;oBAAA;sBAAA;wBAAA;0BAAXA,WAAW,2BAAG;4BACnB,IAAIC,QAAQ,CAACzE,SAAS,CAAC,IAAIA,SAAS,GAAG,CAAC,EAAE;8BACtCsE,YAAY,CAACI,UAAU,CAAC,CAAC,CAAC;8BAC1BA,UAAU,GAAGhE,UAAU,CAAC,YAAM;gCAC1B,IAAIiE,MAAM,CAACC,UAAU,KAAKtC,aAAa,CAACuC,IAAI,EAAE;kCAC1CF,MAAM,CAACG,IAAI,CAAC3F,gBAAgB,CAAC;oCAAE4F,IAAI,EAAE9F,WAAW,CAAC+F;kCAAK,CAAC,CAAC,CAAC;kCACzDzC,OAAO,CAACK,IAAI,CAAC,MAAM,EAAE,KAAK,EAAEqC,SAAS,CAAC;gCAC1C;8BACJ,CAAC,EAAEjF,SAAS,CAAC;4BACjB;0BACJ,CAAC;0BAAA,KAtBGmE,QAAQ;4BAAA;4BAAA;0BAAA;0BAAA;0BAAA,OACF/D,SAAS,CAACC,OAAO,CAAC;wBAAA;0BAAA,IAEnB6D,KAAK;4BAAA;4BAAA;0BAAA;0BACNnB,UAAU,GAAGkC,SAAS;0BAAC,kCAChBV,MAAM,CAAC;4BAAEW,IAAI,EAAE,IAAI;4BAAEC,MAAM,EAAE;0BAAyB,CAAC,CAAC;wBAAA;0BAEnE9E,OAAO,EAAE;wBAAC;0BAEdkC,OAAO,CAACK,IAAI,CAAC,YAAY,CAAC;0BAAC,eACRN,aAAa;0BAAA,MAAC,OAAO9C,GAAG,KAAK,UAAU;4BAAA;4BAAA;0BAAA;0BAAA;0BAAA,OAASA,GAAG,EAAE;wBAAA;0BAAA;0BAAA;0BAAA;wBAAA;0BAAA,eAAGA,GAAG;wBAAA;0BAAA;0BAAA,eAAET,6BAA6B;0BAAvG4F,MAAM;0BAaZf,aAAa,CAAC,UAACwB,UAAU,EAAK;4BAC1BrC,UAAU,GAAGkC,SAAS;4BACtBX,YAAY,CAACe,oBAAoB,CAAC;4BAClCf,YAAY,CAACI,UAAU,CAAC;4BACxBH,MAAM,CAACa,UAAU,CAAC;4BAClB,IAAIpE,gBAAgB,CAACoE,UAAU,CAAC,IAAIA,UAAU,CAACF,IAAI,KAAK,IAAI,EAAE;8BAC1DP,MAAM,CAACW,KAAK,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC,CAAC;8BAClCX,MAAM,CAACY,OAAO,GAAG,IAAI;8BACrBZ,MAAM,CAACa,OAAO,GAAG,IAAI;4BACzB;0BACJ,CAAC,CAAC;0BACFb,MAAM,CAACY,OAAO,GAAG,UAACxB,GAAG;4BAAA,OAAKxB,OAAO,CAACK,IAAI,CAAC,OAAO,EAAEmB,GAAG,CAAC;0BAAA;0BACpDY,MAAM,CAACa,OAAO,GAAG,UAAClC,KAAK;4BAAA,OAAKf,OAAO,CAACK,IAAI,CAAC,QAAQ,EAAEU,KAAK,CAAC;0BAAA;0BACzDqB,MAAM,CAACc,MAAM,2EAAG;4BAAA;4BAAA;8BAAA;gCAAA;kCAAA;oCAAA;oCAERlD,OAAO,CAACK,IAAI,CAAC,QAAQ,EAAE+B,MAAM,CAAC;oCAAC,MACf,OAAOlF,gBAAgB,KAAK,UAAU;sCAAA;sCAAA;oCAAA;oCAAA;oCAAA,OAC1CA,gBAAgB,EAAE;kCAAA;oCAAA;oCAAA;oCAAA;kCAAA;oCAAA,eACxBA,gBAAgB;kCAAA;oCAFhBiG,OAAO;oCAAA,MAKTf,MAAM,CAACC,UAAU,KAAKtC,aAAa,CAACuC,IAAI;sCAAA;sCAAA;oCAAA;oCAAA;kCAAA;oCAE5CF,MAAM,CAACG,IAAI,CAAC3F,gBAAgB,CAACuG,OAAO,GAC9B;sCACEX,IAAI,EAAE9F,WAAW,CAAC0G,cAAc;sCAChCD,OAAO,EAAPA;oCACJ,CAAC,GACC;sCACEX,IAAI,EAAE9F,WAAW,CAAC0G;sCAClB;oCACJ,CAAC,EAAEhE,QAAQ,CAAC,CAAC;oCACjB,IAAI8C,QAAQ,CAACvE,wBAAwB,CAAC,IAClCA,wBAAwB,GAAG,CAAC,EAAE;sCAC9BmF,oBAAoB,GAAG3E,UAAU,CAAC,YAAM;wCACpCiE,MAAM,CAACW,KAAK,CAACtG,SAAS,CAAC4G,gCAAgC,EAAE,oCAAoC,CAAC;sCAClG,CAAC,EAAE1F,wBAAwB,CAAC;oCAChC;oCACAsE,WAAW,EAAE,CAAC,CAAC;oCAAA;oCAAA;kCAAA;oCAAA;oCAAA;oCAGfjC,OAAO,CAACK,IAAI,CAAC,OAAO,eAAM;oCAC1B+B,MAAM,CAACW,KAAK,CAACtG,SAAS,CAAC6G,mBAAmB,EAAExG,gBAAgB,CAAC,wBAAe4C,KAAK,GAAG,aAAIO,OAAO,GAAG,IAAIP,KAAK,cAAK,CAACO,OAAO,EAAE,uBAAuB,CAAC,CAAC;kCAAC;kCAAA;oCAAA;gCAAA;8BAAA;4BAAA;0BAAA,CAE3J;0BACGsD,YAAY,GAAG,KAAK;0BACxBnB,MAAM,CAACoB,SAAS,GAAG,iBAAc;4BAAA,IAAXC,IAAI,SAAJA,IAAI;4BACtB,IAAI;8BACA,IAAMxD,OAAO,GAAGtD,YAAY,CAAC8G,IAAI,EAAEnE,OAAO,CAAC;8BAC3CU,OAAO,CAACK,IAAI,CAAC,SAAS,EAAEJ,OAAO,CAAC;8BAChC,IAAIA,OAAO,CAACuC,IAAI,KAAK,MAAM,IAAIvC,OAAO,CAACuC,IAAI,KAAK,MAAM,EAAE;gCACpDxC,OAAO,CAACK,IAAI,CAACJ,OAAO,CAACuC,IAAI,EAAE,IAAI,EAAEvC,OAAO,CAACkD,OAAO,CAAC,CAAC,CAAC;gCACnD,IAAIlD,OAAO,CAACuC,IAAI,KAAK,MAAM,EAAE;kCACzBP,WAAW,EAAE,CAAC,CAAC;gCACnB,CAAC,MACI,IAAI,CAACvE,WAAW,EAAE;kCACnB;kCACA0E,MAAM,CAACG,IAAI,CAAC3F,gBAAgB,CAACqD,OAAO,CAACkD,OAAO,GACtC;oCACEX,IAAI,EAAE9F,WAAW,CAACgH,IAAI;oCACtBP,OAAO,EAAElD,OAAO,CAACkD;kCACrB,CAAC,GACC;oCACEX,IAAI,EAAE9F,WAAW,CAACgH;oCAClB;kCACJ,CAAC,CAAC,CAAC;;kCACP1D,OAAO,CAACK,IAAI,CAAC,MAAM,EAAE,KAAK,EAAEJ,OAAO,CAACkD,OAAO,CAAC;gCAChD;gCACA,OAAO,CAAC;8BACZ;;8BACA,IAAII,YAAY,EACZ,OAAO,CAAC;8BACZ,IAAItD,OAAO,CAACuC,IAAI,KAAK9F,WAAW,CAACiH,aAAa,EAC1C,MAAM,IAAIjE,KAAK,2CAAoCO,OAAO,CAACuC,IAAI,EAAG;8BACtET,YAAY,CAACe,oBAAoB,CAAC;8BAClCS,YAAY,GAAG,IAAI;8BACnBvD,OAAO,CAACK,IAAI,CAAC,WAAW,EAAE+B,MAAM,EAAEnC,OAAO,CAACkD,OAAO,CAAC,CAAC,CAAC;8BACpDvB,QAAQ,GAAG,KAAK,CAAC,CAAC;8BAClB9D,OAAO,GAAG,CAAC,CAAC,CAAC;8BACb4C,SAAS,CAAC,CACN0B,MAAM,EACN,IAAInE,OAAO,CAAC,UAAC2F,CAAC,EAAEC,MAAM;gCAAA,OAAKxC,aAAa,CAACwC,MAAM,CAAC;8BAAA,EAAC,CACpD,CAAC;4BACN,CAAC,CACD,OAAOrC,GAAG,EAAE;8BACRY,MAAM,CAACoB,SAAS,GAAG,IAAI,CAAC,CAAC;8BACzBxD,OAAO,CAACK,IAAI,CAAC,OAAO,EAAEmB,GAAG,CAAC;8BAC1BY,MAAM,CAACW,KAAK,CAACtG,SAAS,CAACqH,WAAW,EAAEhH,gBAAgB,CAAC0E,GAAG,YAAY9B,KAAK,GAAG8B,GAAG,CAACvB,OAAO,GAAG,IAAIP,KAAK,CAAC8B,GAAG,CAAC,CAACvB,OAAO,EAAE,cAAc,CAAC,CAAC;4BACtI;0BACJ,CAAC;wBAAC;wBAAA;0BAAA;sBAAA;oBAAA;kBAAA;gBAAA,CACL,IAAG;cAAA,EAAE;YAAA;cAAA;cAAA;cAlHCmC,MAAM;cAAE2B,YAAY;cAAA,MAoHvB3B,MAAM,CAACC,UAAU,KAAKtC,aAAa,CAACiE,OAAO;gBAAA;gBAAA;cAAA;cAAA;cAAA,OACrCD,YAAY;YAAA;cAClBE,OAAO,GAAG,mBAAM;gBAChB;cACJ,CAAC;cACKC,QAAQ,GAAG,IAAIjG,OAAO,CAAC,UAACC,OAAO;gBAAA,OAAM+F,OAAO,GAAG/F,OAAO;cAAA,CAAC,CAAC;cAAA,kCACvD,CACHkE,MAAM,EACN6B,OAAO,EACPhG,OAAO,CAACkG,IAAI,CAAC;cACT;cACAD,QAAQ,CAACE,IAAI,CAAC,YAAM;gBAChB,IAAI,CAACzC,KAAK,EAAE;kBACR;kBACA,IAAM0C,QAAQ,GAAG,SAAXA,QAAQ;oBAAA,OAASjC,MAAM,CAACW,KAAK,CAAC,IAAI,EAAE,gBAAgB,CAAC;kBAAA;kBAC3D,IAAIb,QAAQ,CAAC1E,kBAAkB,CAAC,IAAIA,kBAAkB,GAAG,CAAC,EAAE;oBACxD;oBACA;oBACAD,gBAAgB,GAAGY,UAAU,CAAC,YAAM;sBAChC,IAAIiE,MAAM,CAACC,UAAU,KAAKtC,aAAa,CAACuC,IAAI,EACxC+B,QAAQ,EAAE;oBAClB,CAAC,EAAE7G,kBAAkB,CAAC;kBAC1B,CAAC,MACI;oBACD;oBACA6G,QAAQ,EAAE;kBACd;gBACJ;cACJ,CAAC,CAAC;cACF;cACAN,YAAY,CACf,CAAC,CACL;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CACJ;IAAA;EAAA;EAID,SAASO,yBAAyB,CAACC,eAAe,EAAE;IAChD;IACA,IAAI9F,gBAAgB,CAAC8F,eAAe,CAAC,KAChCC,wBAAwB,CAACD,eAAe,CAAC5B,IAAI,CAAC,IAC3C,CACIlG,SAAS,CAACgI,mBAAmB,EAC7BhI,SAAS,CAAC6G,mBAAmB,EAC7B7G,SAAS,CAACiI,UAAU,EACpBjI,SAAS,CAACqH,WAAW,EACrBrH,SAAS,CAACkI,YAAY;IACtB;IACAlI,SAAS,CAACmI,wBAAwB;IAClC;IACA;IACAnI,SAAS,CAACoI,uBAAuB,EACjCpI,SAAS,CAACqI;IACV;IAAA,CACH,CAACC,QAAQ,CAACR,eAAe,CAAC5B,IAAI,CAAC,CAAC,EACrC,MAAM4B,eAAe;IACzB;IACA,IAAI1C,QAAQ,EACR,OAAO,KAAK;IAChB;IACA;IACA,IAAIpD,gBAAgB,CAAC8F,eAAe,CAAC,IAAIA,eAAe,CAAC5B,IAAI,KAAK,IAAI,EAClE,OAAOhB,KAAK,GAAG,CAAC;IACpB;IACA,IAAI,CAAC/D,aAAa,IAAIE,OAAO,IAAIF,aAAa,EAC1C,MAAM2G,eAAe;IACzB;IACA,IAAI,CAAC/F,WAAW,CAAC+F,eAAe,CAAC,EAC7B,MAAMA,eAAe;IACzB;IACA,IAAI7F,wBAAwB,KAAK,IAAI,IAAIA,wBAAwB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,wBAAwB,CAAC6F,eAAe,CAAC,EAC7H,MAAMA,eAAe;IACzB;IACA,OAAQ3C,QAAQ,GAAG,IAAI;EAC3B;EACA;EACA,IAAI,CAACzE,IAAI,EAAE;IACP,2DAAC;MAAA;MAAA;QAAA;UAAA;YAAA;cACGwE,KAAK,EAAE;YAAC;cAAA;cAAA;cAAA,OAGiCG,OAAO,EAAE;YAAA;cAAA;cAAA;cAA/BiC,YAAY;cAAA;cAAA,OACjBA,YAAY;YAAA;cAAA;cAAA;YAAA;cAAA;cAAA;cAAA;cAAA,IAITO,yBAAyB,cAAiB;gBAAA;gBAAA;cAAA;cAAA;YAAA;cAAA;cAAA;YAAA;cAAA;cAAA;cAAA,kCAKxClH,cAAc,KAAK,IAAI,IAAIA,cAAc,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,cAAc,cAAiB;YAAA;cAAA;cAAA;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAIrH,IAAG;EACR;EACA,OAAO;IACHuB,EAAE,EAAEqB,OAAO,CAACrB,EAAE;IACdqG,SAAS,qBAAC7B,OAAO,EAAE8B,IAAI,EAAE;MACrB,IAAM9E,EAAE,GAAGtB,UAAU,CAACsE,OAAO,CAAC;MAC9B,IAAI+B,IAAI,GAAG,KAAK;QAAEC,OAAO,GAAG,KAAK;QAAEC,QAAQ,GAAG,oBAAM;UAChD;UACAzD,KAAK,EAAE;UACPuD,IAAI,GAAG,IAAI;QACf,CAAC;MACD,2DAAC;QAAA;QAAA;UAAA;YAAA;cAAA;gBACGvD,KAAK,EAAE;cAAC;gBAAA;gBAAA;kBAAA;kBAAA;oBAAA;sBAAA;wBAAA;0BAAA;0BAAA,OAG8DG,OAAO,EAAE;wBAAA;0BAAA;0BAAA;0BAAhEM,MAAM;0BAAE6B,OAAO;0BAAEoB,4BAA4B;0BAAA,KAEhDH,IAAI;4BAAA;4BAAA;0BAAA;0BAAA;4BAAA,GACGjB,OAAO;0BAAE;wBAAA;0BACdvC,QAAQ,GAAG1B,OAAO,CAACc,SAAS,CAACX,EAAE,EAAE,UAACF,OAAO,EAAK;4BAChD,QAAQA,OAAO,CAACuC,IAAI;8BAChB,KAAK9F,WAAW,CAAC4I,IAAI;gCAAE;kCACnBL,IAAI,CAACM,IAAI,CAACtF,OAAO,CAACkD,OAAO,CAAC;kCAC1B;gCACJ;8BACA,KAAKzG,WAAW,CAACgD,KAAK;gCAAE;kCACnByF,OAAO,GAAG,IAAI,EAAID,IAAI,GAAG,IAAK;kCAC/BD,IAAI,CAAC3H,KAAK,CAAC2C,OAAO,CAACkD,OAAO,CAAC;kCAC3BiC,QAAQ,EAAE;kCACV;gCACJ;8BACA,KAAK1I,WAAW,CAAC8I,QAAQ;gCAAE;kCACvBN,IAAI,GAAG,IAAI;kCACXE,QAAQ,EAAE,CAAC,CAAC;kCACZ;gCACJ;4BAAC;0BAET,CAAC,CAAC;0BACFhD,MAAM,CAACG,IAAI,CAAC3F,gBAAgB,CAAC;4BACzBuD,EAAE,EAAFA,EAAE;4BACFqC,IAAI,EAAE9F,WAAW,CAAC+I,SAAS;4BAC3BtC,OAAO,EAAPA;0BACJ,CAAC,EAAE/D,QAAQ,CAAC,CAAC;0BACbgG,QAAQ,GAAG,oBAAM;4BACb,IAAI,CAACF,IAAI,IAAI9C,MAAM,CAACC,UAAU,KAAKtC,aAAa,CAACuC,IAAI;8BACjD;8BACAF,MAAM,CAACG,IAAI,CAAC3F,gBAAgB,CAAC;gCACzBuD,EAAE,EAAFA,EAAE;gCACFqC,IAAI,EAAE9F,WAAW,CAAC8I;8BACtB,CAAC,EAAEpG,QAAQ,CAAC,CAAC;4BACjBuC,KAAK,EAAE;4BACPuD,IAAI,GAAG,IAAI;4BACXjB,OAAO,EAAE;0BACb,CAAC;0BACD;0BACA;0BACA;0BAAA;0BAAA,OACMoB,4BAA4B,CAACK,OAAO,CAAChE,QAAQ,CAAC;wBAAA;0BAAA;4BAAA;0BAAA;wBAAA;wBAAA;0BAAA;sBAAA;oBAAA;kBAAA;gBAAA;cAAA;gBAAA;gBAAA;kBAAA;kBAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAAA,IAI/C4C,yBAAyB,cAAiB;kBAAA;kBAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAI1D,IAAG,CACCF,IAAI,CAAC,YAAM;QACZ;QACA,IAAI,CAACe,OAAO,EACRF,IAAI,CAACZ,QAAQ,EAAE;MACvB,CAAC,CAAC,CAAC;MAAA,CACEsB,KAAK,CAAC,UAACnE,GAAG,EAAK;QAChByD,IAAI,CAAC3H,KAAK,CAACkE,GAAG,CAAC;MACnB,CAAC,CAAC,CAAC,CAAC;MACJ,OAAO,YAAM;QACT;QACA,IAAI,CAAC0D,IAAI,EACLE,QAAQ,EAAE;MAClB,CAAC;IACL,CAAC;IACKQ,OAAO,qBAAG;MAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBACZ/D,QAAQ,GAAG,IAAI;gBAAC,KACZrB,UAAU;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OAEaA,UAAU;cAAA;gBAAA;gBAAA;gBAA1B4B,MAAM;gBACbA,MAAM,CAACW,KAAK,CAAC,IAAI,EAAE,gBAAgB,CAAC;cAAC;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IAE7C,CAAC;IACD8C,SAAS,uBAAG;MACR,IAAIrF,UAAU,EAAE;QACZ;QACAR,OAAO,CAACK,IAAI,CAAC,QAAQ,EAAE;UACnBsC,IAAI,EAAE,IAAI;UACVC,MAAM,EAAE,YAAY;UACpBkD,QAAQ,EAAE;QACd,CAAC,CAAC;MACN;IACJ;EACJ,CAAC;AACL;AACA,SAASrH,gBAAgB,CAACsH,GAAG,EAAE;EAC3B,OAAOlJ,QAAQ,CAACkJ,GAAG,CAAC,IAAI,MAAM,IAAIA,GAAG,IAAI,QAAQ,IAAIA,GAAG;AAC5D;AACA,SAASvB,wBAAwB,CAAC7B,IAAI,EAAE;EACpC,IAAI,CACA,IAAI,EACJ,IAAI,EACJ,IAAI,EACJ,IAAI,EACJ,IAAI,EACJ,IAAI,EACJ,IAAI,CAAE;EAAA,CACT,CAACoC,QAAQ,CAACpC,IAAI,CAAC,EACZ,OAAO,KAAK;EAChB;EACA,OAAOA,IAAI,IAAI,IAAI,IAAIA,IAAI,IAAI,IAAI;AACvC;AACA,SAASlD,WAAW,CAACsG,GAAG,EAAE;EACtB,OAAQ,OAAOA,GAAG,KAAK,UAAU,IAC7B,aAAa,IAAIA,GAAG,IACpB,QAAQ,IAAIA,GAAG,IACf,SAAS,IAAIA,GAAG,IAChB,YAAY,IAAIA,GAAG,IACnB,MAAM,IAAIA,GAAG;AACrB"},"metadata":{},"sourceType":"module"}