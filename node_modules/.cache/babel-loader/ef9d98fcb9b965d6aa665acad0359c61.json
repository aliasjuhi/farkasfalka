{"ast":null,"code":"import _slicedToArray from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _assertThisInitialized from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _asyncToGenerator from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createClass from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  if (__getOwnPropSymbols) {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols(b)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return a;\n};\nvar __spreadProps = function __spreadProps(a, b) {\n  return __defProps(a, __getOwnPropDescs(b));\n};\nvar __objRest = function __objRest(source, exclude) {\n  var target = {};\n  for (var prop in source) {\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  }\n  if (source != null && __getOwnPropSymbols) {\n    var _iterator2 = _createForOfIteratorHelper(__getOwnPropSymbols(source)),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var prop = _step2.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  return target;\n};\nimport { createMachine, assign, send, interpret } from \"xstate\";\nimport axios from \"axios\";\nimport Cookies from \"js-cookie\";\nfunction utf8StringToBuffer(value) {\n  return new TextEncoder().encode(value);\n}\nfunction bufferToBase64URLString(buffer) {\n  var bytes = new Uint8Array(buffer);\n  var str = \"\";\n  var _iterator3 = _createForOfIteratorHelper(bytes),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var charCode = _step3.value;\n      str += String.fromCharCode(charCode);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  var base64String = btoa(str);\n  return base64String.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\nfunction base64URLStringToBuffer(base64URLString) {\n  var base64 = base64URLString.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  var padLength = (4 - base64.length % 4) % 4;\n  var padded = base64.padEnd(base64.length + padLength, \"=\");\n  var binary = atob(padded);\n  var buffer = new ArrayBuffer(binary.length);\n  var bytes = new Uint8Array(buffer);\n  for (var i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return buffer;\n}\nfunction browserSupportsWebAuthn() {\n  return (window === null || window === void 0 ? void 0 : window.PublicKeyCredential) !== void 0 && typeof window.PublicKeyCredential === \"function\";\n}\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n  var id = descriptor.id;\n  return __spreadProps(__spreadValues({}, descriptor), {\n    id: base64URLStringToBuffer(id),\n    transports: descriptor.transports\n  });\n}\nfunction isValidDomain(hostname) {\n  return hostname === \"localhost\" || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname);\n}\nvar WebAuthnError = /*#__PURE__*/function (_Error) {\n  _inherits(WebAuthnError, _Error);\n  var _super = _createSuper(WebAuthnError);\n  function WebAuthnError(message) {\n    var _this;\n    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"WebAuthnError\";\n    _classCallCheck(this, WebAuthnError);\n    _this = _super.call(this, message);\n    _this.name = name;\n    return _this;\n  }\n  return _createClass(WebAuthnError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nfunction identifyRegistrationError(_ref) {\n  var error = _ref.error,\n    options = _ref.options;\n  var _a, _b;\n  var publicKey = options.publicKey;\n  if (!publicKey) {\n    throw Error(\"options was missing required publicKey property\");\n  }\n  if (error.name === \"AbortError\") {\n    if (options.signal === new AbortController().signal) {\n      return new WebAuthnError(\"Registration ceremony was sent an abort signal\", \"AbortError\");\n    }\n  } else if (error.name === \"ConstraintError\") {\n    if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {\n      return new WebAuthnError(\"Discoverable credentials were required but no available authenticator supported it\", \"ConstraintError\");\n    } else if (((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === \"required\") {\n      return new WebAuthnError(\"User verification was required but no available authenticator supported it\", \"ConstraintError\");\n    }\n  } else if (error.name === \"InvalidStateError\") {\n    return new WebAuthnError(\"The authenticator was previously registered\", \"InvalidStateError\");\n  } else if (error.name === \"NotAllowedError\") {\n    return new WebAuthnError(\"User clicked cancel, or the registration ceremony timed out\", \"NotAllowedError\");\n  } else if (error.name === \"NotSupportedError\") {\n    var validPubKeyCredParams = publicKey.pubKeyCredParams.filter(function (param) {\n      return param.type === \"public-key\";\n    });\n    if (validPubKeyCredParams.length === 0) {\n      return new WebAuthnError('No entry in pubKeyCredParams was of type \"public-key\"', \"NotSupportedError\");\n    }\n    return new WebAuthnError(\"No available authenticator supported any of the specified pubKeyCredParams algorithms\", \"NotSupportedError\");\n  } else if (error.name === \"SecurityError\") {\n    var effectiveDomain = window.location.hostname;\n    if (!isValidDomain(effectiveDomain)) {\n      return new WebAuthnError(\"\".concat(window.location.hostname, \" is an invalid domain\"), \"SecurityError\");\n    } else if (publicKey.rp.id !== effectiveDomain) {\n      return new WebAuthnError(\"The RP ID \\\"\".concat(publicKey.rp.id, \"\\\" is invalid for this domain\"), \"SecurityError\");\n    }\n  } else if (error.name === \"TypeError\") {\n    if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n      return new WebAuthnError(\"User ID was not between 1 and 64 characters\", \"TypeError\");\n    }\n  } else if (error.name === \"UnknownError\") {\n    return new WebAuthnError(\"The authenticator was unable to process the specified options, or could not create a new credential\", \"UnknownError\");\n  }\n  return error;\n}\nvar WebAuthnAbortService = /*#__PURE__*/function () {\n  function WebAuthnAbortService() {\n    _classCallCheck(this, WebAuthnAbortService);\n  }\n  _createClass(WebAuthnAbortService, [{\n    key: \"createNewAbortSignal\",\n    value: function createNewAbortSignal() {\n      if (this.controller) {\n        this.controller.abort();\n      }\n      this.controller = new AbortController();\n      return this.controller.signal;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.controller = void 0;\n    }\n  }]);\n  return WebAuthnAbortService;\n}();\nvar webauthnAbortService = new WebAuthnAbortService();\nfunction startRegistration(_x) {\n  return _startRegistration.apply(this, arguments);\n}\nfunction _startRegistration() {\n  _startRegistration = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(creationOptionsJSON) {\n    var publicKey, options, credential, _credential, id, rawId, response, type, credentialJSON;\n    return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n      while (1) {\n        switch (_context17.prev = _context17.next) {\n          case 0:\n            if (browserSupportsWebAuthn()) {\n              _context17.next = 2;\n              break;\n            }\n            throw new Error(\"WebAuthn is not supported in this browser\");\n          case 2:\n            publicKey = __spreadProps(__spreadValues({}, creationOptionsJSON), {\n              challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n              user: __spreadProps(__spreadValues({}, creationOptionsJSON.user), {\n                id: utf8StringToBuffer(creationOptionsJSON.user.id)\n              }),\n              excludeCredentials: creationOptionsJSON.excludeCredentials.map(toPublicKeyCredentialDescriptor)\n            });\n            options = {\n              publicKey: publicKey\n            };\n            options.signal = webauthnAbortService.createNewAbortSignal();\n            _context17.prev = 5;\n            _context17.next = 8;\n            return navigator.credentials.create(options);\n          case 8:\n            credential = _context17.sent;\n            _context17.next = 14;\n            break;\n          case 11:\n            _context17.prev = 11;\n            _context17.t0 = _context17[\"catch\"](5);\n            throw identifyRegistrationError({\n              error: _context17.t0,\n              options: options\n            });\n          case 14:\n            _context17.prev = 14;\n            webauthnAbortService.reset();\n            return _context17.finish(14);\n          case 17:\n            if (credential) {\n              _context17.next = 19;\n              break;\n            }\n            throw new Error(\"Registration was not completed\");\n          case 19:\n            _credential = credential, id = _credential.id, rawId = _credential.rawId, response = _credential.response, type = _credential.type;\n            credentialJSON = {\n              id: id,\n              rawId: bufferToBase64URLString(rawId),\n              response: {\n                attestationObject: bufferToBase64URLString(response.attestationObject),\n                clientDataJSON: bufferToBase64URLString(response.clientDataJSON)\n              },\n              type: type,\n              clientExtensionResults: credential.getClientExtensionResults(),\n              authenticatorAttachment: credential.authenticatorAttachment\n            };\n            if (typeof response.getTransports === \"function\") {\n              credentialJSON.transports = response.getTransports();\n            }\n            return _context17.abrupt(\"return\", credentialJSON);\n          case 23:\n          case \"end\":\n            return _context17.stop();\n        }\n      }\n    }, _callee17, null, [[5, 11, 14, 17]]);\n  }));\n  return _startRegistration.apply(this, arguments);\n}\nfunction bufferToUTF8String(value) {\n  return new TextDecoder(\"utf-8\").decode(value);\n}\nfunction browserSupportsWebAuthnAutofill() {\n  return _browserSupportsWebAuthnAutofill.apply(this, arguments);\n}\nfunction _browserSupportsWebAuthnAutofill() {\n  _browserSupportsWebAuthnAutofill = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n    var globalPublicKeyCredential;\n    return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n      while (1) {\n        switch (_context18.prev = _context18.next) {\n          case 0:\n            if (!navigator.credentials.conditionalMediationSupported) {\n              _context18.next = 2;\n              break;\n            }\n            return _context18.abrupt(\"return\", true);\n          case 2:\n            globalPublicKeyCredential = window.PublicKeyCredential;\n            return _context18.abrupt(\"return\", globalPublicKeyCredential.isConditionalMediationAvailable !== void 0 && globalPublicKeyCredential.isConditionalMediationAvailable());\n          case 4:\n          case \"end\":\n            return _context18.stop();\n        }\n      }\n    }, _callee18);\n  }));\n  return _browserSupportsWebAuthnAutofill.apply(this, arguments);\n}\nfunction identifyAuthenticationError(_ref2) {\n  var error = _ref2.error,\n    options = _ref2.options;\n  var _a;\n  var publicKey = options.publicKey;\n  if (!publicKey) {\n    throw Error(\"options was missing required publicKey property\");\n  }\n  if (error.name === \"AbortError\") {\n    if (options.signal === new AbortController().signal) {\n      return new WebAuthnError(\"Authentication ceremony was sent an abort signal\", \"AbortError\");\n    }\n  } else if (error.name === \"NotAllowedError\") {\n    if ((_a = publicKey.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) {\n      return new WebAuthnError(\"No available authenticator recognized any of the allowed credentials\", \"NotAllowedError\");\n    }\n    return new WebAuthnError(\"User clicked cancel, or the authentication ceremony timed out\", \"NotAllowedError\");\n  } else if (error.name === \"SecurityError\") {\n    var effectiveDomain = window.location.hostname;\n    if (!isValidDomain(effectiveDomain)) {\n      return new WebAuthnError(\"\".concat(window.location.hostname, \" is an invalid domain\"), \"SecurityError\");\n    } else if (publicKey.rpId !== effectiveDomain) {\n      return new WebAuthnError(\"The RP ID \\\"\".concat(publicKey.rpId, \"\\\" is invalid for this domain\"), \"SecurityError\");\n    }\n  } else if (error.name === \"UnknownError\") {\n    return new WebAuthnError(\"The authenticator was unable to process the specified options, or could not create a new assertion signature\", \"UnknownError\");\n  }\n  return error;\n}\nfunction startAuthentication(_x2) {\n  return _startAuthentication.apply(this, arguments);\n}\nfunction _startAuthentication() {\n  _startAuthentication = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(requestOptionsJSON) {\n    var useBrowserAutofill,\n      _a,\n      _b,\n      allowCredentials,\n      publicKey,\n      options,\n      eligibleInputs,\n      credential,\n      _credential2,\n      id,\n      rawId,\n      response,\n      type,\n      userHandle,\n      _args19 = arguments;\n    return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n      while (1) {\n        switch (_context19.prev = _context19.next) {\n          case 0:\n            useBrowserAutofill = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : false;\n            if (browserSupportsWebAuthn()) {\n              _context19.next = 3;\n              break;\n            }\n            throw new Error(\"WebAuthn is not supported in this browser\");\n          case 3:\n            if (((_a = requestOptionsJSON.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) !== 0) {\n              allowCredentials = (_b = requestOptionsJSON.allowCredentials) === null || _b === void 0 ? void 0 : _b.map(toPublicKeyCredentialDescriptor);\n            }\n            publicKey = __spreadProps(__spreadValues({}, requestOptionsJSON), {\n              challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n              allowCredentials: allowCredentials\n            });\n            options = {};\n            if (!useBrowserAutofill) {\n              _context19.next = 16;\n              break;\n            }\n            _context19.next = 9;\n            return browserSupportsWebAuthnAutofill();\n          case 9:\n            if (_context19.sent) {\n              _context19.next = 11;\n              break;\n            }\n            throw Error(\"Browser does not support WebAuthn autofill\");\n          case 11:\n            eligibleInputs = document.querySelectorAll(\"input[autocomplete*='webauthn']\");\n            if (!(eligibleInputs.length < 1)) {\n              _context19.next = 14;\n              break;\n            }\n            throw Error('No <input> with `\"webauthn\"` in its `autocomplete` attribute was detected');\n          case 14:\n            options.mediation = \"conditional\";\n            publicKey.allowCredentials = [];\n          case 16:\n            options.publicKey = publicKey;\n            options.signal = webauthnAbortService.createNewAbortSignal();\n            _context19.prev = 18;\n            _context19.next = 21;\n            return navigator.credentials.get(options);\n          case 21:\n            credential = _context19.sent;\n            _context19.next = 27;\n            break;\n          case 24:\n            _context19.prev = 24;\n            _context19.t0 = _context19[\"catch\"](18);\n            throw identifyAuthenticationError({\n              error: _context19.t0,\n              options: options\n            });\n          case 27:\n            _context19.prev = 27;\n            webauthnAbortService.reset();\n            return _context19.finish(27);\n          case 30:\n            if (credential) {\n              _context19.next = 32;\n              break;\n            }\n            throw new Error(\"Authentication was not completed\");\n          case 32:\n            _credential2 = credential, id = _credential2.id, rawId = _credential2.rawId, response = _credential2.response, type = _credential2.type;\n            userHandle = void 0;\n            if (response.userHandle) {\n              userHandle = bufferToUTF8String(response.userHandle);\n            }\n            return _context19.abrupt(\"return\", {\n              id: id,\n              rawId: bufferToBase64URLString(rawId),\n              response: {\n                authenticatorData: bufferToBase64URLString(response.authenticatorData),\n                clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n                signature: bufferToBase64URLString(response.signature),\n                userHandle: userHandle\n              },\n              type: type,\n              clientExtensionResults: credential.getClientExtensionResults(),\n              authenticatorAttachment: credential.authenticatorAttachment\n            });\n          case 36:\n          case \"end\":\n            return _context19.stop();\n        }\n      }\n    }, _callee19, null, [[18, 24, 27, 30]]);\n  }));\n  return _startAuthentication.apply(this, arguments);\n}\nvar NHOST_REFRESH_TOKEN_KEY = \"nhostRefreshToken\";\nvar NHOST_JWT_EXPIRES_AT_KEY = \"nhostRefreshTokenExpiresAt\";\nvar MIN_PASSWORD_LENGTH = 3;\nvar TOKEN_REFRESH_MARGIN = 300;\nvar REFRESH_TOKEN_RETRY_INTERVAL = 5;\nvar REFRESH_TOKEN_RETRY_MAX_ATTEMPTS = 30;\nvar NETWORK_ERROR_CODE = 0;\nvar OTHER_ERROR_CODE = 1;\nvar VALIDATION_ERROR_CODE = 10;\nvar STATE_ERROR_CODE = 20;\nvar CodifiedError = /*#__PURE__*/function (_Error2) {\n  _inherits(CodifiedError, _Error2);\n  var _super2 = _createSuper(CodifiedError);\n  function CodifiedError(original) {\n    var _this2;\n    _classCallCheck(this, CodifiedError);\n    _this2 = _super2.call(this, original.message);\n    Error.captureStackTrace(_assertThisInitialized(_this2), _this2.constructor);\n    if (original instanceof Error) {\n      _this2.name = original.name;\n      _this2.error = {\n        error: original.name,\n        status: OTHER_ERROR_CODE,\n        message: original.message\n      };\n    } else {\n      _this2.name = original.error;\n      _this2.error = original;\n    }\n    return _this2;\n  }\n  return _createClass(CodifiedError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar INVALID_EMAIL_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-email\",\n  message: \"Email is incorrectly formatted\"\n};\nvar INVALID_MFA_TYPE_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-mfa-type\",\n  message: \"MFA type is invalid\"\n};\nvar INVALID_MFA_CODE_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-mfa-code\",\n  message: \"MFA code is invalid\"\n};\nvar INVALID_PASSWORD_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-password\",\n  message: \"Password is incorrectly formatted\"\n};\nvar INVALID_PHONE_NUMBER_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-phone-number\",\n  message: \"Phone number is incorrectly formatted\"\n};\nvar INVALID_MFA_TICKET_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-mfa-ticket\",\n  message: \"MFA ticket is invalid\"\n};\nvar NO_MFA_TICKET_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"no-mfa-ticket\",\n  message: \"No MFA ticket has been provided\"\n};\nvar NO_REFRESH_TOKEN = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"no-refresh-token\",\n  message: \"No refresh token has been provided\"\n};\nvar TOKEN_REFRESHER_RUNNING_ERROR = {\n  status: STATE_ERROR_CODE,\n  error: \"refresher-already-running\",\n  message: \"The token refresher is already running. You must wait until is has finished before submitting a new token.\"\n};\nvar USER_ALREADY_SIGNED_IN = {\n  status: STATE_ERROR_CODE,\n  error: \"already-signed-in\",\n  message: \"User is already signed in\"\n};\nvar USER_UNAUTHENTICATED = {\n  status: STATE_ERROR_CODE,\n  error: \"unauthenticated-user\",\n  message: \"User is not authenticated\"\n};\nvar USER_NOT_ANONYMOUS = {\n  status: STATE_ERROR_CODE,\n  error: \"user-not-anonymous\",\n  message: \"User is not anonymous\"\n};\nvar EMAIL_NEEDS_VERIFICATION = {\n  status: STATE_ERROR_CODE,\n  error: \"unverified-user\",\n  message: \"Email needs verification\"\n};\nvar INVALID_REFRESH_TOKEN = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-refresh-token\",\n  message: \"Invalid or expired refresh token\"\n};\nvar nhostApiClient = function nhostApiClient(backendUrl) {\n  var client = axios.create({\n    baseURL: backendUrl\n  });\n  client.interceptors.response.use(function (response) {\n    return response;\n  }, function (error) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    return Promise.reject({\n      error: {\n        message: (_e = (_d = (_c = (_b = (_a = error.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message) != null ? _c : error.message) != null ? _d : error.request.responseText) != null ? _e : JSON.stringify(error),\n        status: (_i = (_h = (_f = error.response) == null ? void 0 : _f.status) != null ? _h : (_g = error.response) == null ? void 0 : _g.data.statusCode) != null ? _i : NETWORK_ERROR_CODE,\n        error: ((_j = error.response) == null ? void 0 : _j.data.error) || error.request.statusText || \"network\"\n      }\n    });\n  });\n  return client;\n};\nvar isBrowser$1 = typeof window !== \"undefined\";\nvar inMemoryLocalStorage = /* @__PURE__ */new Map();\nvar defaultClientStorageGetter = function defaultClientStorageGetter(key) {\n  var _a;\n  if (isBrowser$1 && typeof localStorage !== \"undefined\") return localStorage.getItem(key);else return (_a = inMemoryLocalStorage.get(key)) != null ? _a : null;\n};\nvar defaultClientStorageSetter = function defaultClientStorageSetter(key, value) {\n  if (isBrowser$1 && typeof localStorage !== \"undefined\") {\n    if (value) {\n      localStorage.setItem(key, value);\n    } else {\n      localStorage.removeItem(key);\n    }\n  } else {\n    if (value) {\n      inMemoryLocalStorage.set(key, value);\n    } else if (inMemoryLocalStorage.has(key)) {\n      inMemoryLocalStorage.delete(key);\n    }\n  }\n};\nvar localStorageGetter = function localStorageGetter(clientStorageType, clientStorage) {\n  if (clientStorageType === \"localStorage\" || clientStorageType === \"web\") {\n    return defaultClientStorageGetter;\n  }\n  if (clientStorageType === \"cookie\") {\n    return function (key) {\n      var _a;\n      if (isBrowser$1) {\n        return (_a = Cookies.get(key)) != null ? _a : null;\n      } else {\n        return null;\n      }\n    };\n  }\n  if (!clientStorage) {\n    throw Error(\"clientStorageType is set to '\".concat(clientStorageType, \"' but no clientStorage has been given\"));\n  }\n  if (clientStorageType === \"react-native\") {\n    return function (key) {\n      var _a;\n      return (_a = clientStorage.getItem) == null ? void 0 : _a.call(clientStorage, key);\n    };\n  }\n  if (clientStorageType === \"capacitor\") {\n    return function (key) {\n      var _a;\n      return (_a = clientStorage.get) == null ? void 0 : _a.call(clientStorage, {\n        key: key\n      });\n    };\n  }\n  if (clientStorageType === \"expo-secure-storage\") {\n    return function (key) {\n      var _a;\n      return (_a = clientStorage.getItemAsync) == null ? void 0 : _a.call(clientStorage, key);\n    };\n  }\n  if (clientStorageType === \"custom\") {\n    if (clientStorage.getItem && clientStorage.removeItem) {\n      return clientStorage.getItem;\n    }\n    if (clientStorage.getItemAsync) {\n      return clientStorage.getItemAsync;\n    }\n    throw Error(\"clientStorageType is set to 'custom' but clientStorage is missing either \\\"getItem\\\" and \\\"removeItem\\\" properties or \\\"getItemAsync\\\" property\");\n  }\n  throw Error(\"Unknown storage type: \".concat(clientStorageType));\n};\nvar localStorageSetter = function localStorageSetter(clientStorageType, clientStorage) {\n  if (clientStorageType === \"localStorage\" || clientStorageType === \"web\") {\n    return defaultClientStorageSetter;\n  }\n  if (clientStorageType === \"cookie\") {\n    return function (key, value) {\n      if (isBrowser$1) {\n        if (value) {\n          Cookies.set(key, value, {\n            expires: 30\n          });\n        } else {\n          Cookies.remove(key);\n        }\n      }\n    };\n  }\n  if (!clientStorage) {\n    throw Error(\"clientStorageType is set to '\".concat(clientStorageType, \"' but no clienStorage has been given\"));\n  }\n  if (clientStorageType === \"react-native\") {\n    return function (key, value) {\n      var _a, _b;\n      return value ? (_a = clientStorage.setItem) == null ? void 0 : _a.call(clientStorage, key, value) : (_b = clientStorage.removeItem) == null ? void 0 : _b.call(clientStorage, key);\n    };\n  }\n  if (clientStorageType === \"capacitor\") {\n    return function (key, value) {\n      var _a, _b;\n      return value ? (_a = clientStorage.set) == null ? void 0 : _a.call(clientStorage, {\n        key: key,\n        value: value\n      }) : (_b = clientStorage.remove) == null ? void 0 : _b.call(clientStorage, {\n        key: key\n      });\n    };\n  }\n  if (clientStorageType === \"expo-secure-storage\") {\n    return /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key, value) {\n        var _a, _b;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", value ? (_a = clientStorage.setItemAsync) == null ? void 0 : _a.call(clientStorage, key, value) : (_b = clientStorage.deleteItemAsync) == null ? void 0 : _b.call(clientStorage, key));\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function (_x3, _x4) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n  }\n  if (clientStorageType === \"custom\") {\n    if (!clientStorage.removeItem) {\n      throw Error(\"clientStorageType is set to 'custom' but clientStorage is missing a removeItem property\");\n    }\n    if (clientStorage.setItem) {\n      return function (key, value) {\n        var _a, _b;\n        return value ? (_a = clientStorage.setItem) == null ? void 0 : _a.call(clientStorage, key, value) : (_b = clientStorage.removeItem) == null ? void 0 : _b.call(clientStorage, key);\n      };\n    }\n    if (clientStorage.setItemAsync) {\n      return /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key, value) {\n          var _a, _b;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  return _context2.abrupt(\"return\", value ? (_a = clientStorage.setItemAsync) == null ? void 0 : _a.call(clientStorage, key, value) : (_b = clientStorage.removeItem) == null ? void 0 : _b.call(clientStorage, key));\n                case 1:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n        return function (_x5, _x6) {\n          return _ref4.apply(this, arguments);\n        };\n      }();\n    }\n    throw Error(\"clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property\");\n  }\n  throw Error(\"Unknown storage type: \".concat(clientStorageType));\n};\nvar encodeQueryParameters = function encodeQueryParameters(baseUrl, parameters) {\n  var encodedParameters = parameters && Object.entries(parameters).map(function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 2),\n      key = _ref6[0],\n      value = _ref6[1];\n    var stringValue = Array.isArray(value) ? value.join(\",\") : typeof value === \"object\" ? JSON.stringify(value) : value;\n    return \"\".concat(key, \"=\").concat(encodeURIComponent(stringValue));\n  }).join(\"&\");\n  if (encodedParameters) return \"\".concat(baseUrl, \"?\").concat(encodedParameters);else return baseUrl;\n};\nvar rewriteRedirectTo = function rewriteRedirectTo(clientUrl, options) {\n  if (!(options == null ? void 0 : options.redirectTo)) {\n    return options;\n  }\n  var _a = options,\n    redirectTo = _a.redirectTo,\n    otherOptions = __objRest(_a, [\"redirectTo\"]);\n  if (!clientUrl) {\n    if (redirectTo.startsWith(\"/\")) {\n      return otherOptions;\n    } else {\n      return options;\n    }\n  }\n  var baseClientUrl = new URL(clientUrl);\n  var clientParams = Object.fromEntries(new URLSearchParams(baseClientUrl.search));\n  var url = new URL(redirectTo.startsWith(\"/\") ? baseClientUrl.origin + redirectTo : redirectTo);\n  var additionalParams = new URLSearchParams(url.search);\n  var combinedParams = Object.fromEntries(additionalParams);\n  if (redirectTo.startsWith(\"/\")) {\n    combinedParams = __spreadValues(__spreadValues({}, clientParams), combinedParams);\n  }\n  var pathName = baseClientUrl.pathname;\n  if (url.pathname.length > 1) {\n    pathName += url.pathname.slice(1);\n  }\n  return __spreadProps(__spreadValues({}, otherOptions), {\n    redirectTo: encodeQueryParameters(url.origin + pathName, combinedParams)\n  });\n};\nfunction getParameterByName(name, url) {\n  var _a;\n  if (!url) {\n    if (typeof window === \"undefined\") {\n      return;\n    }\n    url = ((_a = window.location) == null ? void 0 : _a.href) || \"\";\n  }\n  name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n  var regex = new RegExp(\"[?&#]\" + name + \"(=([^&#]*)|&|#|$)\"),\n    results = regex.exec(url);\n  if (!results) return null;\n  if (!results[2]) return \"\";\n  return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n}\nfunction removeParameterFromWindow(name) {\n  var _a;\n  if (typeof window === \"undefined\") {\n    return;\n  }\n  var location = window == null ? void 0 : window.location;\n  if (!location) {\n    return;\n  }\n  if (location) {\n    var search = new URLSearchParams(location.search);\n    var hash = new URLSearchParams((_a = location.hash) == null ? void 0 : _a.slice(1));\n    search.delete(name);\n    hash.delete(name);\n    var url = window.location.pathname;\n    if (Array.from(search).length) url += \"?\".concat(search.toString());\n    if (Array.from(hash).length) url += \"#\".concat(hash.toString());\n    window.history.pushState({}, \"\", url);\n  }\n}\nvar isValidEmail = function isValidEmail(email) {\n  return !!email && typeof email === \"string\" && !!String(email).toLowerCase().match(/^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/);\n};\nvar isValidPassword = function isValidPassword(password) {\n  return !!password && typeof password === \"string\" && password.length >= MIN_PASSWORD_LENGTH;\n};\nvar isValidPhoneNumber = function isValidPhoneNumber(phoneNumber) {\n  return !!phoneNumber && typeof phoneNumber === \"string\";\n};\nvar isValidTicket = function isValidTicket(ticket) {\n  return ticket && typeof ticket === \"string\" && ticket.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i);\n};\nvar INITIAL_MACHINE_CONTEXT = {\n  user: null,\n  mfa: null,\n  accessToken: {\n    value: null,\n    expiresAt: null\n  },\n  refreshTimer: {\n    startedAt: null,\n    attempts: 0,\n    lastAttempt: null\n  },\n  refreshToken: {\n    value: null\n  },\n  errors: {}\n};\nvar createChangeEmailMachine = function createChangeEmailMachine(_ref7) {\n  var backendUrl = _ref7.backendUrl,\n    clientUrl = _ref7.clientUrl,\n    interpreter = _ref7.interpreter;\n  var api = nhostApiClient(backendUrl);\n  return createMachine({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    preserveActionOrder: true,\n    id: \"changeEmail\",\n    initial: \"idle\",\n    context: {\n      error: null\n    },\n    states: {\n      idle: {\n        on: {\n          REQUEST: [{\n            cond: \"invalidEmail\",\n            actions: \"saveInvalidEmailError\",\n            target: \".error\"\n          }, {\n            target: \"requesting\"\n          }]\n        },\n        initial: \"initial\",\n        states: {\n          initial: {},\n          success: {},\n          error: {}\n        }\n      },\n      requesting: {\n        invoke: {\n          src: \"requestChange\",\n          id: \"requestChange\",\n          onDone: {\n            target: \"idle.success\",\n            actions: \"reportSuccess\"\n          },\n          onError: {\n            actions: [\"saveRequestError\", \"reportError\"],\n            target: \"idle.error\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidEmailError: assign({\n        error: function error(_) {\n          return INVALID_EMAIL_ERROR;\n        }\n      }),\n      saveRequestError: assign({\n        error: function error(_, _ref8) {\n          var _error = _ref8.data.error;\n          return _error;\n        }\n      }),\n      reportError: send(function (ctx) {\n        return {\n          type: \"ERROR\",\n          error: ctx.error\n        };\n      }),\n      reportSuccess: send(\"SUCCESS\")\n    },\n    guards: {\n      invalidEmail: function invalidEmail(_, _ref9) {\n        var email = _ref9.email;\n        return !isValidEmail(email);\n      }\n    },\n    services: {\n      requestChange: function () {\n        var _requestChange = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_, _ref10) {\n          var email, options, res;\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  email = _ref10.email, options = _ref10.options;\n                  _context3.next = 3;\n                  return api.post(\"/user/email/change\", {\n                    newEmail: email,\n                    options: rewriteRedirectTo(clientUrl, options)\n                  }, {\n                    headers: {\n                      authorization: \"Bearer \".concat(interpreter == null ? void 0 : interpreter.state.context.accessToken.value)\n                    }\n                  });\n                case 3:\n                  res = _context3.sent;\n                  return _context3.abrupt(\"return\", res.data);\n                case 5:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3);\n        }));\n        function requestChange(_x7, _x8) {\n          return _requestChange.apply(this, arguments);\n        }\n        return requestChange;\n      }()\n    }\n  });\n};\nvar createChangePasswordMachine = function createChangePasswordMachine(_ref11) {\n  var backendUrl = _ref11.backendUrl,\n    interpreter = _ref11.interpreter;\n  var api = nhostApiClient(backendUrl);\n  return createMachine({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    preserveActionOrder: true,\n    id: \"changePassword\",\n    initial: \"idle\",\n    context: {\n      error: null\n    },\n    states: {\n      idle: {\n        on: {\n          REQUEST: [{\n            cond: \"invalidPassword\",\n            actions: \"saveInvalidPasswordError\",\n            target: \".error\"\n          }, {\n            target: \"requesting\"\n          }]\n        },\n        initial: \"initial\",\n        states: {\n          initial: {},\n          success: {},\n          error: {}\n        }\n      },\n      requesting: {\n        invoke: {\n          src: \"requestChange\",\n          id: \"requestChange\",\n          onDone: {\n            target: \"idle.success\",\n            actions: \"reportSuccess\"\n          },\n          onError: {\n            actions: [\"saveRequestError\", \"reportError\"],\n            target: \"idle.error\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidPasswordError: assign({\n        error: function error(_) {\n          return INVALID_PASSWORD_ERROR;\n        }\n      }),\n      saveRequestError: assign({\n        error: function error(_, _ref12) {\n          var _error2 = _ref12.data.error;\n          return _error2;\n        }\n      }),\n      reportError: send(function (ctx) {\n        return {\n          type: \"ERROR\",\n          error: ctx.error\n        };\n      }),\n      reportSuccess: send(\"SUCCESS\")\n    },\n    guards: {\n      invalidPassword: function invalidPassword(_, _ref13) {\n        var password = _ref13.password;\n        return !isValidPassword(password);\n      }\n    },\n    services: {\n      requestChange: function requestChange(_, _ref14) {\n        var password = _ref14.password,\n          ticket = _ref14.ticket;\n        return api.post(\"/user/password\", {\n          newPassword: password,\n          ticket: ticket\n        }, {\n          headers: {\n            authorization: \"Bearer \".concat(interpreter == null ? void 0 : interpreter.state.context.accessToken.value)\n          }\n        });\n      }\n    }\n  });\n};\nvar createEnableMfaMachine = function createEnableMfaMachine(_ref15) {\n  var backendUrl = _ref15.backendUrl,\n    interpreter = _ref15.interpreter;\n  var api = nhostApiClient(backendUrl);\n  return createMachine({\n    schema: {\n      context: {},\n      events: {}\n    },\n    tsTypes: {},\n    preserveActionOrder: true,\n    id: \"enableMfa\",\n    initial: \"idle\",\n    context: {\n      error: null,\n      imageUrl: null,\n      secret: null\n    },\n    states: {\n      idle: {\n        initial: \"initial\",\n        on: {\n          GENERATE: \"generating\"\n        },\n        states: {\n          initial: {},\n          error: {}\n        }\n      },\n      generating: {\n        invoke: {\n          src: \"generate\",\n          id: \"generate\",\n          onDone: {\n            target: \"generated\",\n            actions: [\"reportGeneratedSuccess\", \"saveGeneration\"]\n          },\n          onError: {\n            actions: [\"saveError\", \"reportGeneratedError\"],\n            target: \"idle.error\"\n          }\n        }\n      },\n      generated: {\n        initial: \"idle\",\n        states: {\n          idle: {\n            initial: \"idle\",\n            on: {\n              ACTIVATE: [{\n                cond: \"invalidMfaType\",\n                actions: \"saveInvalidMfaTypeError\",\n                target: \".error\"\n              }, {\n                cond: \"invalidMfaCode\",\n                actions: \"saveInvalidMfaCodeError\",\n                target: \".error\"\n              }, {\n                target: \"activating\"\n              }]\n            },\n            states: {\n              idle: {},\n              error: {}\n            }\n          },\n          activating: {\n            invoke: {\n              src: \"activate\",\n              id: \"activate\",\n              onDone: {\n                target: \"activated\",\n                actions: \"reportSuccess\"\n              },\n              onError: {\n                actions: [\"saveError\", \"reportError\"],\n                target: \"idle.error\"\n              }\n            }\n          },\n          activated: {\n            type: \"final\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidMfaTypeError: assign({\n        error: function error(_) {\n          return INVALID_MFA_TYPE_ERROR;\n        }\n      }),\n      saveInvalidMfaCodeError: assign({\n        error: function error(_) {\n          return INVALID_MFA_CODE_ERROR;\n        }\n      }),\n      saveError: assign({\n        error: function error(_, _ref16) {\n          var _error3 = _ref16.data.error;\n          return _error3;\n        }\n      }),\n      saveGeneration: assign({\n        imageUrl: function imageUrl(_, _ref17) {\n          var _imageUrl = _ref17.data.imageUrl;\n          return _imageUrl;\n        },\n        secret: function secret(_, _ref18) {\n          var totpSecret = _ref18.data.totpSecret;\n          return totpSecret;\n        }\n      }),\n      reportError: send(function (ctx) {\n        return {\n          type: \"ERROR\",\n          error: ctx.error\n        };\n      }),\n      reportSuccess: send(\"SUCCESS\"),\n      reportGeneratedSuccess: send(\"GENERATED\"),\n      reportGeneratedError: send(function (ctx) {\n        return {\n          type: \"GENERATED_ERROR\",\n          error: ctx.error\n        };\n      })\n    },\n    guards: {\n      invalidMfaCode: function invalidMfaCode(_, _ref19) {\n        var code = _ref19.code;\n        return !code;\n      },\n      invalidMfaType: function invalidMfaType(_, _ref20) {\n        var activeMfaType = _ref20.activeMfaType;\n        return !activeMfaType || activeMfaType !== \"totp\";\n      }\n    },\n    services: {\n      generate: function () {\n        var _generate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_) {\n          var _yield$api$get, data;\n          return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.next = 2;\n                  return api.get(\"/mfa/totp/generate\", {\n                    headers: {\n                      authorization: \"Bearer \".concat(interpreter == null ? void 0 : interpreter.state.context.accessToken.value)\n                    }\n                  });\n                case 2:\n                  _yield$api$get = _context4.sent;\n                  data = _yield$api$get.data;\n                  return _context4.abrupt(\"return\", data);\n                case 5:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4);\n        }));\n        function generate(_x9) {\n          return _generate.apply(this, arguments);\n        }\n        return generate;\n      }(),\n      activate: function activate(_, _ref21) {\n        var code = _ref21.code,\n          activeMfaType = _ref21.activeMfaType;\n        return api.post(\"/user/mfa\", {\n          code: code,\n          activeMfaType: activeMfaType\n        }, {\n          headers: {\n            authorization: \"Bearer \".concat(interpreter == null ? void 0 : interpreter.state.context.accessToken.value)\n          }\n        });\n      }\n    }\n  });\n};\nvar createResetPasswordMachine = function createResetPasswordMachine(_ref22) {\n  var backendUrl = _ref22.backendUrl,\n    clientUrl = _ref22.clientUrl;\n  var api = nhostApiClient(backendUrl);\n  return createMachine({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    preserveActionOrder: true,\n    id: \"changePassword\",\n    initial: \"idle\",\n    context: {\n      error: null\n    },\n    states: {\n      idle: {\n        on: {\n          REQUEST: [{\n            cond: \"invalidEmail\",\n            actions: \"saveInvalidEmailError\",\n            target: \".error\"\n          }, {\n            target: \"requesting\"\n          }]\n        },\n        initial: \"initial\",\n        states: {\n          initial: {},\n          success: {},\n          error: {}\n        }\n      },\n      requesting: {\n        invoke: {\n          src: \"requestChange\",\n          id: \"requestChange\",\n          onDone: {\n            target: \"idle.success\",\n            actions: \"reportSuccess\"\n          },\n          onError: {\n            actions: [\"saveRequestError\", \"reportError\"],\n            target: \"idle.error\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidEmailError: assign({\n        error: function error(_) {\n          return INVALID_EMAIL_ERROR;\n        }\n      }),\n      saveRequestError: assign({\n        error: function error(_, _ref23) {\n          var _error4 = _ref23.data.error;\n          return _error4;\n        }\n      }),\n      reportError: send(function (ctx) {\n        return {\n          type: \"ERROR\",\n          error: ctx.error\n        };\n      }),\n      reportSuccess: send(\"SUCCESS\")\n    },\n    guards: {\n      invalidEmail: function invalidEmail(_, _ref24) {\n        var email = _ref24.email;\n        return !isValidEmail(email);\n      }\n    },\n    services: {\n      requestChange: function requestChange(_, _ref25) {\n        var email = _ref25.email,\n          options = _ref25.options;\n        return api.post(\"/user/password/reset\", {\n          email: email,\n          options: rewriteRedirectTo(clientUrl, options)\n        });\n      }\n    }\n  });\n};\nvar createSendVerificationEmailMachine = function createSendVerificationEmailMachine(_ref26) {\n  var backendUrl = _ref26.backendUrl,\n    clientUrl = _ref26.clientUrl;\n  var api = nhostApiClient(backendUrl);\n  return createMachine({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    preserveActionOrder: true,\n    id: \"sendVerificationEmail\",\n    initial: \"idle\",\n    context: {\n      error: null\n    },\n    states: {\n      idle: {\n        on: {\n          REQUEST: [{\n            cond: \"invalidEmail\",\n            actions: \"saveInvalidEmailError\",\n            target: \".error\"\n          }, {\n            target: \"requesting\"\n          }]\n        },\n        initial: \"initial\",\n        states: {\n          initial: {},\n          success: {},\n          error: {}\n        }\n      },\n      requesting: {\n        invoke: {\n          src: \"request\",\n          id: \"request\",\n          onDone: {\n            target: \"idle.success\",\n            actions: \"reportSuccess\"\n          },\n          onError: {\n            actions: [\"saveRequestError\", \"reportError\"],\n            target: \"idle.error\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidEmailError: assign({\n        error: function error(_) {\n          return INVALID_EMAIL_ERROR;\n        }\n      }),\n      saveRequestError: assign({\n        error: function error(_, _ref27) {\n          var _error5 = _ref27.data.error;\n          return _error5;\n        }\n      }),\n      reportError: send(function (ctx) {\n        return {\n          type: \"ERROR\",\n          error: ctx.error\n        };\n      }),\n      reportSuccess: send(\"SUCCESS\")\n    },\n    guards: {\n      invalidEmail: function invalidEmail(_, _ref28) {\n        var email = _ref28.email;\n        return !isValidEmail(email);\n      }\n    },\n    services: {\n      request: function () {\n        var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_, _ref29) {\n          var email, options, res;\n          return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  email = _ref29.email, options = _ref29.options;\n                  _context5.next = 3;\n                  return api.post(\"/user/email/send-verification-email\", {\n                    email: email,\n                    options: rewriteRedirectTo(clientUrl, options)\n                  });\n                case 3:\n                  res = _context5.sent;\n                  return _context5.abrupt(\"return\", res.data);\n                case 5:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5);\n        }));\n        function request(_x10, _x11) {\n          return _request.apply(this, arguments);\n        }\n        return request;\n      }()\n    }\n  });\n};\nvar createAuthMachine = function createAuthMachine(_ref30) {\n  var backendUrl = _ref30.backendUrl,\n    clientUrl = _ref30.clientUrl,\n    clientStorageGetter = _ref30.clientStorageGetter,\n    clientStorageSetter = _ref30.clientStorageSetter,\n    _ref30$clientStorageT = _ref30.clientStorageType,\n    clientStorageType = _ref30$clientStorageT === void 0 ? \"web\" : _ref30$clientStorageT,\n    clientStorage = _ref30.clientStorage,\n    refreshIntervalTime = _ref30.refreshIntervalTime,\n    _ref30$autoRefreshTok = _ref30.autoRefreshToken,\n    autoRefreshToken = _ref30$autoRefreshTok === void 0 ? true : _ref30$autoRefreshTok,\n    _ref30$autoSignIn = _ref30.autoSignIn,\n    autoSignIn = _ref30$autoSignIn === void 0 ? true : _ref30$autoSignIn;\n  var storageGetter = clientStorageGetter || localStorageGetter(clientStorageType, clientStorage);\n  var storageSetter = clientStorageSetter || localStorageSetter(clientStorageType, clientStorage);\n  var api = nhostApiClient(backendUrl);\n  var postRequest = /*#__PURE__*/function () {\n    var _ref31 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(url, data, config) {\n      var result;\n      return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return api.post(url, data, config);\n            case 2:\n              result = _context6.sent;\n              return _context6.abrupt(\"return\", result.data);\n            case 4:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }));\n    return function postRequest(_x12, _x13, _x14) {\n      return _ref31.apply(this, arguments);\n    };\n  }();\n  return createMachine({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    context: INITIAL_MACHINE_CONTEXT,\n    preserveActionOrder: true,\n    id: \"nhost\",\n    type: \"parallel\",\n    states: {\n      authentication: {\n        initial: \"starting\",\n        on: {\n          SESSION_UPDATE: [{\n            cond: \"hasSession\",\n            actions: [\"saveSession\", \"resetTimer\", \"reportTokenChanged\"],\n            target: \".signedIn\"\n          }]\n        },\n        states: {\n          starting: {\n            entry: \"resetErrors\",\n            tags: [\"loading\"],\n            always: {\n              cond: \"isSignedIn\",\n              target: \"signedIn\"\n            },\n            invoke: {\n              id: \"importRefreshToken\",\n              src: \"importRefreshToken\",\n              onDone: {\n                actions: [\"saveSession\", \"reportTokenChanged\"],\n                target: \"signedIn\"\n              },\n              onError: {\n                actions: [\"saveAuthenticationError\"],\n                target: \"signedOut\"\n              }\n            }\n          },\n          signedOut: {\n            initial: \"noErrors\",\n            entry: \"reportSignedOut\",\n            states: {\n              noErrors: {},\n              success: {},\n              needsSmsOtp: {},\n              needsMfa: {},\n              failed: {},\n              signingOut: {\n                entry: [\"clearContextExceptRefreshToken\"],\n                exit: [\"destroyRefreshToken\", \"reportTokenChanged\"],\n                invoke: {\n                  src: \"signout\",\n                  id: \"signingOut\",\n                  onDone: {\n                    target: \"success\"\n                  },\n                  onError: {\n                    target: \"failed\",\n                    actions: [\"saveAuthenticationError\"]\n                  }\n                }\n              }\n            },\n            on: {\n              SIGNIN_PASSWORD: \"authenticating.password\",\n              SIGNIN_ANONYMOUS: \"authenticating.anonymous\",\n              SIGNIN_SECURITY_KEY_EMAIL: \"authenticating.securityKeyEmail\",\n              SIGNIN_MFA_TOTP: \"authenticating.mfa.totp\"\n            }\n          },\n          authenticating: {\n            entry: \"resetErrors\",\n            states: {\n              password: {\n                invoke: {\n                  src: \"signInPassword\",\n                  id: \"authenticateUserWithPassword\",\n                  onDone: [{\n                    cond: \"hasMfaTicket\",\n                    actions: [\"saveMfaTicket\"],\n                    target: \"#nhost.authentication.signedOut.needsMfa\"\n                  }, {\n                    actions: [\"saveSession\", \"reportTokenChanged\"],\n                    target: \"#nhost.authentication.signedIn\"\n                  }],\n                  onError: [{\n                    cond: \"unverified\",\n                    target: [\"#nhost.authentication.signedOut\", \"#nhost.registration.incomplete.needsEmailVerification\"]\n                  }, {\n                    actions: \"saveAuthenticationError\",\n                    target: \"#nhost.authentication.signedOut.failed\"\n                  }]\n                }\n              },\n              anonymous: {\n                invoke: {\n                  src: \"signInAnonymous\",\n                  id: \"authenticateAnonymously\",\n                  onDone: {\n                    actions: [\"saveSession\", \"reportTokenChanged\"],\n                    target: \"#nhost.authentication.signedIn\"\n                  },\n                  onError: {\n                    actions: \"saveAuthenticationError\",\n                    target: \"#nhost.authentication.signedOut.failed\"\n                  }\n                }\n              },\n              mfa: {\n                states: {\n                  totp: {\n                    invoke: {\n                      src: \"signInMfaTotp\",\n                      id: \"signInMfaTotp\",\n                      onDone: {\n                        actions: [\"saveSession\", \"reportTokenChanged\"],\n                        target: \"#nhost.authentication.signedIn\"\n                      },\n                      onError: {\n                        actions: [\"saveAuthenticationError\"],\n                        target: \"#nhost.authentication.signedOut.failed\"\n                      }\n                    }\n                  }\n                }\n              },\n              securityKeyEmail: {\n                invoke: {\n                  src: \"signInSecurityKeyEmail\",\n                  id: \"authenticateUserWithSecurityKey\",\n                  onDone: {\n                    actions: [\"saveSession\", \"reportTokenChanged\"],\n                    target: \"#nhost.authentication.signedIn\"\n                  },\n                  onError: [{\n                    cond: \"unverified\",\n                    target: [\"#nhost.authentication.signedOut\", \"#nhost.registration.incomplete.needsEmailVerification\"]\n                  }, {\n                    actions: \"saveAuthenticationError\",\n                    target: \"#nhost.authentication.signedOut.failed\"\n                  }]\n                }\n              }\n            }\n          },\n          signedIn: {\n            type: \"parallel\",\n            entry: [\"reportSignedIn\", \"cleanUrl\", \"broadcastToken\", \"resetErrors\"],\n            on: {\n              SIGNOUT: \"signedOut.signingOut\"\n            },\n            states: {\n              refreshTimer: {\n                id: \"timer\",\n                initial: \"idle\",\n                states: {\n                  disabled: {\n                    type: \"final\"\n                  },\n                  stopped: {\n                    always: {\n                      cond: \"noToken\",\n                      target: \"idle\"\n                    }\n                  },\n                  idle: {\n                    always: [{\n                      cond: \"isAutoRefreshDisabled\",\n                      target: \"disabled\"\n                    }, {\n                      cond: \"hasRefreshToken\",\n                      target: \"running\"\n                    }]\n                  },\n                  running: {\n                    initial: \"pending\",\n                    entry: \"resetTimer\",\n                    states: {\n                      pending: {\n                        after: {\n                          \"1000\": {\n                            internal: false,\n                            target: \"pending\"\n                          }\n                        },\n                        always: {\n                          cond: \"refreshTimerShouldRefresh\",\n                          target: \"refreshing\"\n                        }\n                      },\n                      refreshing: {\n                        invoke: {\n                          src: \"refreshToken\",\n                          id: \"refreshToken\",\n                          onDone: {\n                            actions: [\"saveSession\", \"resetTimer\", \"reportTokenChanged\"],\n                            target: \"pending\"\n                          },\n                          onError: [{\n                            actions: \"saveRefreshAttempt\",\n                            target: \"pending\"\n                          }]\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      token: {\n        initial: \"idle\",\n        states: {\n          idle: {\n            on: {\n              TRY_TOKEN: \"running\"\n            },\n            initial: \"noErrors\",\n            states: {\n              noErrors: {},\n              error: {}\n            }\n          },\n          running: {\n            invoke: {\n              src: \"refreshToken\",\n              id: \"authenticateWithToken\",\n              onDone: {\n                actions: [\"saveSession\", \"reportTokenChanged\"],\n                target: [\"#nhost.authentication.signedIn\", \"idle.noErrors\"]\n              },\n              onError: [{\n                cond: \"isSignedIn\",\n                target: \"idle.error\"\n              }, {\n                actions: \"saveAuthenticationError\",\n                target: [\"#nhost.authentication.signedOut.failed\", \"idle.error\"]\n              }]\n            }\n          }\n        }\n      },\n      registration: {\n        initial: \"incomplete\",\n        on: {\n          SIGNED_IN: [{\n            cond: \"isAnonymous\",\n            target: \".incomplete\"\n          }, \".complete\"]\n        },\n        states: {\n          incomplete: {\n            on: {\n              SIGNUP_EMAIL_PASSWORD: \"emailPassword\",\n              SIGNUP_SECURITY_KEY: \"securityKey\",\n              PASSWORDLESS_EMAIL: \"passwordlessEmail\",\n              PASSWORDLESS_SMS: \"passwordlessSms\",\n              PASSWORDLESS_SMS_OTP: \"passwordlessSmsOtp\"\n            },\n            initial: \"noErrors\",\n            states: {\n              noErrors: {},\n              needsEmailVerification: {},\n              needsOtp: {},\n              failed: {}\n            }\n          },\n          emailPassword: {\n            entry: [\"resetErrors\"],\n            invoke: {\n              src: \"signUpEmailPassword\",\n              id: \"signUpEmailPassword\",\n              onDone: [{\n                cond: \"hasSession\",\n                actions: [\"saveSession\", \"reportTokenChanged\"],\n                target: \"#nhost.authentication.signedIn\"\n              }, {\n                actions: \"clearContext\",\n                target: [\"#nhost.authentication.signedOut\", \"incomplete.needsEmailVerification\"]\n              }],\n              onError: [{\n                cond: \"unverified\",\n                target: \"incomplete.needsEmailVerification\"\n              }, {\n                actions: \"saveRegistrationError\",\n                target: \"incomplete.failed\"\n              }]\n            }\n          },\n          securityKey: {\n            entry: [\"resetErrors\"],\n            invoke: {\n              src: \"signUpSecurityKey\",\n              id: \"signUpSecurityKey\",\n              onDone: [{\n                cond: \"hasSession\",\n                actions: [\"saveSession\", \"reportTokenChanged\"],\n                target: \"#nhost.authentication.signedIn\"\n              }, {\n                actions: \"clearContext\",\n                target: [\"#nhost.authentication.signedOut\", \"incomplete.needsEmailVerification\"]\n              }],\n              onError: [{\n                cond: \"unverified\",\n                target: \"incomplete.needsEmailVerification\"\n              }, {\n                actions: \"saveRegistrationError\",\n                target: \"incomplete.failed\"\n              }]\n            }\n          },\n          passwordlessEmail: {\n            entry: [\"resetErrors\"],\n            invoke: {\n              src: \"passwordlessEmail\",\n              id: \"passwordlessEmail\",\n              onDone: {\n                actions: \"clearContext\",\n                target: [\"#nhost.authentication.signedOut\", \"incomplete.needsEmailVerification\"]\n              },\n              onError: {\n                actions: \"saveRegistrationError\",\n                target: \"incomplete.failed\"\n              }\n            }\n          },\n          passwordlessSms: {\n            entry: [\"resetErrors\"],\n            invoke: {\n              src: \"passwordlessSms\",\n              id: \"passwordlessSms\",\n              onDone: {\n                actions: \"clearContext\",\n                target: [\"#nhost.authentication.signedOut\", \"incomplete.needsOtp\"]\n              },\n              onError: {\n                actions: \"saveRegistrationError\",\n                target: \"incomplete.failed\"\n              }\n            }\n          },\n          passwordlessSmsOtp: {\n            entry: [\"resetErrors\"],\n            invoke: {\n              src: \"passwordlessSmsOtp\",\n              id: \"passwordlessSmsOtp\",\n              onDone: {\n                actions: [\"saveSession\", \"reportTokenChanged\"],\n                target: \"#nhost.authentication.signedIn\"\n              },\n              onError: {\n                actions: \"saveRegistrationError\",\n                target: \"incomplete.failed\"\n              }\n            }\n          },\n          complete: {\n            on: {\n              SIGNED_OUT: \"incomplete\"\n            }\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      reportSignedIn: send(\"SIGNED_IN\"),\n      reportSignedOut: send(\"SIGNED_OUT\"),\n      reportTokenChanged: send(\"TOKEN_CHANGED\"),\n      clearContext: assign(function () {\n        storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null);\n        storageSetter(NHOST_REFRESH_TOKEN_KEY, null);\n        return __spreadValues({}, INITIAL_MACHINE_CONTEXT);\n      }),\n      clearContextExceptRefreshToken: assign(function (_ref32) {\n        var value = _ref32.refreshToken.value;\n        storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null);\n        return __spreadProps(__spreadValues({}, INITIAL_MACHINE_CONTEXT), {\n          refreshToken: {\n            value: value\n          }\n        });\n      }),\n      saveSession: assign({\n        user: function user(_, _ref33) {\n          var data = _ref33.data;\n          var _a;\n          return ((_a = data == null ? void 0 : data.session) == null ? void 0 : _a.user) || null;\n        },\n        accessToken: function accessToken(_, _ref34) {\n          var data = _ref34.data;\n          if (data.session) {\n            var _data$session = data.session,\n              accessTokenExpiresIn = _data$session.accessTokenExpiresIn,\n              accessToken = _data$session.accessToken;\n            var nextRefresh = new Date(Date.now() + accessTokenExpiresIn * 1e3);\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, nextRefresh.toISOString());\n            return {\n              value: accessToken,\n              expiresAt: nextRefresh\n            };\n          }\n          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null);\n          return {\n            value: null,\n            expiresAt: null\n          };\n        },\n        refreshToken: function refreshToken(_, _ref35) {\n          var data = _ref35.data;\n          var _a;\n          var refreshToken = ((_a = data.session) == null ? void 0 : _a.refreshToken) || null;\n          if (refreshToken) {\n            storageSetter(NHOST_REFRESH_TOKEN_KEY, refreshToken);\n          }\n          return {\n            value: refreshToken\n          };\n        }\n      }),\n      saveMfaTicket: assign({\n        mfa: function mfa(_, e) {\n          var _a;\n          return (_a = e.data) == null ? void 0 : _a.mfa;\n        }\n      }),\n      resetTimer: assign({\n        refreshTimer: function refreshTimer(_) {\n          return {\n            startedAt: new Date(),\n            attempts: 0,\n            lastAttempt: null\n          };\n        }\n      }),\n      saveRefreshAttempt: assign({\n        refreshTimer: function refreshTimer(ctx, e) {\n          return {\n            startedAt: ctx.refreshTimer.startedAt,\n            attempts: ctx.refreshTimer.attempts + 1,\n            lastAttempt: new Date()\n          };\n        }\n      }),\n      saveAuthenticationError: assign({\n        errors: function errors(_ref36, _ref37) {\n          var _errors = _ref36.errors;\n          var error = _ref37.data.error;\n          return __spreadProps(__spreadValues({}, _errors), {\n            authentication: error\n          });\n        }\n      }),\n      resetErrors: assign({\n        errors: function errors(_) {\n          return {};\n        }\n      }),\n      saveRegistrationError: assign({\n        errors: function errors(_ref38, _ref39) {\n          var _errors2 = _ref38.errors;\n          var error = _ref39.data.error;\n          return __spreadProps(__spreadValues({}, _errors2), {\n            registration: error\n          });\n        }\n      }),\n      destroyRefreshToken: assign({\n        refreshToken: function refreshToken(_) {\n          storageSetter(NHOST_REFRESH_TOKEN_KEY, null);\n          return {\n            value: null\n          };\n        }\n      }),\n      cleanUrl: function cleanUrl() {\n        if (autoSignIn && getParameterByName(\"refreshToken\")) {\n          removeParameterFromWindow(\"refreshToken\");\n          removeParameterFromWindow(\"type\");\n        }\n      },\n      broadcastToken: function broadcastToken(context) {\n        if (autoSignIn) {\n          try {\n            var channel = new BroadcastChannel(\"nhost\");\n            channel.postMessage(context.refreshToken.value);\n          } catch (error) {}\n        }\n      }\n    },\n    guards: {\n      isAnonymous: function isAnonymous(ctx, e) {\n        var _a;\n        return !!((_a = ctx.user) == null ? void 0 : _a.isAnonymous);\n      },\n      isSignedIn: function isSignedIn(ctx) {\n        return !!ctx.user && !!ctx.refreshToken.value && !!ctx.accessToken.value;\n      },\n      noToken: function noToken(ctx) {\n        return !ctx.refreshToken.value;\n      },\n      hasRefreshToken: function hasRefreshToken(ctx) {\n        return !!ctx.refreshToken.value;\n      },\n      isAutoRefreshDisabled: function isAutoRefreshDisabled() {\n        return !autoRefreshToken;\n      },\n      refreshTimerShouldRefresh: function refreshTimerShouldRefresh(ctx) {\n        var expiresAt = ctx.accessToken.expiresAt;\n        if (!expiresAt) {\n          return false;\n        }\n        if (ctx.refreshTimer.lastAttempt) {\n          var elapsed = Date.now() - ctx.refreshTimer.lastAttempt.getTime();\n          return elapsed > REFRESH_TOKEN_RETRY_INTERVAL * 1e3;\n        }\n        if (refreshIntervalTime) {\n          var _elapsed = Date.now() - ctx.refreshTimer.startedAt.getTime();\n          if (_elapsed > refreshIntervalTime * 1e3) {\n            return true;\n          }\n        }\n        var expiresIn = expiresAt.getTime() - Date.now();\n        var remaining = expiresIn - 1e3 * TOKEN_REFRESH_MARGIN;\n        return remaining <= 0;\n      },\n      unverified: function unverified(_, _ref40) {\n        var error = _ref40.data.error;\n        return error.status === 401 && (error.message === \"Email is not verified\" || error.error === \"unverified-user\");\n      },\n      hasSession: function hasSession(_, e) {\n        var _a;\n        return !!((_a = e.data) == null ? void 0 : _a.session);\n      },\n      hasMfaTicket: function hasMfaTicket(_, e) {\n        var _a;\n        return !!((_a = e.data) == null ? void 0 : _a.mfa);\n      }\n    },\n    services: {\n      signInPassword: function signInPassword(_, _ref41) {\n        var email = _ref41.email,\n          password = _ref41.password;\n        if (!isValidEmail(email)) {\n          return Promise.reject({\n            error: INVALID_EMAIL_ERROR\n          });\n        }\n        if (!isValidPassword(password)) {\n          return Promise.reject({\n            error: INVALID_PASSWORD_ERROR\n          });\n        }\n        return postRequest(\"/signin/email-password\", {\n          email: email,\n          password: password\n        });\n      },\n      passwordlessSms: function passwordlessSms(context, _ref42) {\n        var phoneNumber = _ref42.phoneNumber,\n          options = _ref42.options;\n        var _a;\n        if (!isValidPhoneNumber(phoneNumber)) {\n          return Promise.reject({\n            error: INVALID_PHONE_NUMBER_ERROR\n          });\n        }\n        if ((_a = context.user) == null ? void 0 : _a.isAnonymous) {\n          console.warn(\"Deanonymisation from a phone number is not yet implemented in hasura-auth\");\n          return postRequest(\"/user/deanonymize\", {\n            signInMethod: \"passwordless\",\n            connection: \"sms\",\n            phoneNumber: phoneNumber,\n            options: rewriteRedirectTo(clientUrl, options)\n          }, {\n            headers: {\n              authorization: \"Bearer \".concat(context.accessToken.value)\n            }\n          });\n        } else {\n          return postRequest(\"/signin/passwordless/sms\", {\n            phoneNumber: phoneNumber,\n            options: rewriteRedirectTo(clientUrl, options)\n          });\n        }\n      },\n      passwordlessSmsOtp: function passwordlessSmsOtp(_, _ref43) {\n        var phoneNumber = _ref43.phoneNumber,\n          otp = _ref43.otp;\n        if (!isValidPhoneNumber(phoneNumber)) {\n          return Promise.reject({\n            error: INVALID_PHONE_NUMBER_ERROR\n          });\n        }\n        return postRequest(\"/signin/passwordless/sms/otp\", {\n          phoneNumber: phoneNumber,\n          otp: otp\n        });\n      },\n      passwordlessEmail: function passwordlessEmail(context, _ref44) {\n        var email = _ref44.email,\n          options = _ref44.options;\n        var _a;\n        if (!isValidEmail(email)) {\n          return Promise.reject({\n            error: INVALID_EMAIL_ERROR\n          });\n        }\n        if ((_a = context.user) == null ? void 0 : _a.isAnonymous) {\n          return postRequest(\"/user/deanonymize\", {\n            signInMethod: \"passwordless\",\n            connection: \"email\",\n            email: email,\n            options: rewriteRedirectTo(clientUrl, options)\n          }, {\n            headers: {\n              authorization: \"Bearer \".concat(context.accessToken.value)\n            }\n          });\n        } else {\n          return postRequest(\"/signin/passwordless/email\", {\n            email: email,\n            options: rewriteRedirectTo(clientUrl, options)\n          });\n        }\n      },\n      signInAnonymous: function signInAnonymous(_) {\n        return postRequest(\"/signin/anonymous\");\n      },\n      signInMfaTotp: function signInMfaTotp(context, data) {\n        var _a;\n        var ticket = data.ticket || ((_a = context.mfa) == null ? void 0 : _a.ticket);\n        if (!ticket) {\n          return Promise.reject({\n            error: NO_MFA_TICKET_ERROR\n          });\n        }\n        if (!isValidTicket(ticket)) {\n          return Promise.reject({\n            error: INVALID_MFA_TICKET_ERROR\n          });\n        }\n        return postRequest(\"/signin/mfa/totp\", {\n          ticket: ticket,\n          otp: data.otp\n        });\n      },\n      signInSecurityKeyEmail: function () {\n        var _signInSecurityKeyEmail = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(_, _ref45) {\n          var email, options, credential;\n          return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  email = _ref45.email;\n                  if (isValidEmail(email)) {\n                    _context7.next = 3;\n                    break;\n                  }\n                  throw new CodifiedError(INVALID_EMAIL_ERROR);\n                case 3:\n                  _context7.next = 5;\n                  return postRequest(\"/signin/webauthn\", {\n                    email: email\n                  });\n                case 5:\n                  options = _context7.sent;\n                  _context7.prev = 6;\n                  _context7.next = 9;\n                  return startAuthentication(options);\n                case 9:\n                  credential = _context7.sent;\n                  _context7.next = 15;\n                  break;\n                case 12:\n                  _context7.prev = 12;\n                  _context7.t0 = _context7[\"catch\"](6);\n                  throw new CodifiedError(_context7.t0);\n                case 15:\n                  return _context7.abrupt(\"return\", postRequest(\"/signin/webauthn/verify\", {\n                    email: email,\n                    credential: credential\n                  }));\n                case 16:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }\n          }, _callee7, null, [[6, 12]]);\n        }));\n        function signInSecurityKeyEmail(_x15, _x16) {\n          return _signInSecurityKeyEmail.apply(this, arguments);\n        }\n        return signInSecurityKeyEmail;\n      }(),\n      refreshToken: function () {\n        var _refreshToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(ctx, event) {\n          var refreshToken, session;\n          return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n            while (1) {\n              switch (_context8.prev = _context8.next) {\n                case 0:\n                  refreshToken = event.type === \"TRY_TOKEN\" ? event.token : ctx.refreshToken.value;\n                  _context8.next = 3;\n                  return postRequest(\"/token\", {\n                    refreshToken: refreshToken\n                  });\n                case 3:\n                  session = _context8.sent;\n                  return _context8.abrupt(\"return\", {\n                    session: session,\n                    error: null\n                  });\n                case 5:\n                case \"end\":\n                  return _context8.stop();\n              }\n            }\n          }, _callee8);\n        }));\n        function refreshToken(_x17, _x18) {\n          return _refreshToken.apply(this, arguments);\n        }\n        return refreshToken;\n      }(),\n      signout: function signout(ctx, e) {\n        return postRequest(\"/signout\", {\n          refreshToken: ctx.refreshToken.value,\n          all: !!e.all\n        });\n      },\n      signUpEmailPassword: function () {\n        var _signUpEmailPassword = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(context, _ref46) {\n          var email, password, options, _a;\n          return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n            while (1) {\n              switch (_context9.prev = _context9.next) {\n                case 0:\n                  email = _ref46.email, password = _ref46.password, options = _ref46.options;\n                  if (isValidEmail(email)) {\n                    _context9.next = 3;\n                    break;\n                  }\n                  return _context9.abrupt(\"return\", Promise.reject({\n                    error: INVALID_EMAIL_ERROR\n                  }));\n                case 3:\n                  if (isValidPassword(password)) {\n                    _context9.next = 5;\n                    break;\n                  }\n                  return _context9.abrupt(\"return\", Promise.reject({\n                    error: INVALID_PASSWORD_ERROR\n                  }));\n                case 5:\n                  if (!((_a = context.user) == null ? void 0 : _a.isAnonymous)) {\n                    _context9.next = 9;\n                    break;\n                  }\n                  return _context9.abrupt(\"return\", postRequest(\"/user/deanonymize\", {\n                    signInMethod: \"email-password\",\n                    email: email,\n                    password: password,\n                    options: rewriteRedirectTo(clientUrl, options)\n                  }, {\n                    headers: {\n                      authorization: \"Bearer \".concat(context.accessToken.value)\n                    }\n                  }));\n                case 9:\n                  return _context9.abrupt(\"return\", postRequest(\"/signup/email-password\", {\n                    email: email,\n                    password: password,\n                    options: rewriteRedirectTo(clientUrl, options)\n                  }));\n                case 10:\n                case \"end\":\n                  return _context9.stop();\n              }\n            }\n          }, _callee9);\n        }));\n        function signUpEmailPassword(_x19, _x20) {\n          return _signUpEmailPassword.apply(this, arguments);\n        }\n        return signUpEmailPassword;\n      }(),\n      signUpSecurityKey: function () {\n        var _signUpSecurityKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(_, _ref47) {\n          var email, options, nickname, webAuthnOptions, credential;\n          return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n            while (1) {\n              switch (_context10.prev = _context10.next) {\n                case 0:\n                  email = _ref47.email, options = _ref47.options;\n                  if (isValidEmail(email)) {\n                    _context10.next = 3;\n                    break;\n                  }\n                  return _context10.abrupt(\"return\", Promise.reject({\n                    error: INVALID_EMAIL_ERROR\n                  }));\n                case 3:\n                  nickname = options == null ? void 0 : options.nickname;\n                  if (nickname) delete options.nickname;\n                  _context10.next = 7;\n                  return postRequest(\"/signup/webauthn\", {\n                    email: email,\n                    options: options\n                  });\n                case 7:\n                  webAuthnOptions = _context10.sent;\n                  _context10.prev = 8;\n                  _context10.next = 11;\n                  return startRegistration(webAuthnOptions);\n                case 11:\n                  credential = _context10.sent;\n                  _context10.next = 17;\n                  break;\n                case 14:\n                  _context10.prev = 14;\n                  _context10.t0 = _context10[\"catch\"](8);\n                  throw new CodifiedError(_context10.t0);\n                case 17:\n                  return _context10.abrupt(\"return\", postRequest(\"/signup/webauthn/verify\", {\n                    credential: credential,\n                    options: {\n                      redirectTo: options == null ? void 0 : options.redirectTo,\n                      nickname: nickname\n                    }\n                  }));\n                case 18:\n                case \"end\":\n                  return _context10.stop();\n              }\n            }\n          }, _callee10, null, [[8, 14]]);\n        }));\n        function signUpSecurityKey(_x21, _x22) {\n          return _signUpSecurityKey.apply(this, arguments);\n        }\n        return signUpSecurityKey;\n      }(),\n      importRefreshToken: function () {\n        var _importRefreshToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n          var error, urlToken, session, error2, storageToken, _session;\n          return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n            while (1) {\n              switch (_context11.prev = _context11.next) {\n                case 0:\n                  error = null;\n                  if (!autoSignIn) {\n                    _context11.next = 19;\n                    break;\n                  }\n                  urlToken = getParameterByName(\"refreshToken\") || null;\n                  if (!urlToken) {\n                    _context11.next = 16;\n                    break;\n                  }\n                  _context11.prev = 4;\n                  _context11.next = 7;\n                  return postRequest(\"/token\", {\n                    refreshToken: urlToken\n                  });\n                case 7:\n                  session = _context11.sent;\n                  return _context11.abrupt(\"return\", {\n                    session: session,\n                    error: null\n                  });\n                case 11:\n                  _context11.prev = 11;\n                  _context11.t0 = _context11[\"catch\"](4);\n                  error = _context11.t0.error;\n                case 14:\n                  _context11.next = 19;\n                  break;\n                case 16:\n                  error2 = getParameterByName(\"error\");\n                  if (!error2) {\n                    _context11.next = 19;\n                    break;\n                  }\n                  return _context11.abrupt(\"return\", Promise.reject({\n                    session: null,\n                    error: {\n                      status: VALIDATION_ERROR_CODE,\n                      error: error2,\n                      message: getParameterByName(\"errorDescription\") || error2\n                    }\n                  }));\n                case 19:\n                  _context11.next = 21;\n                  return storageGetter(NHOST_REFRESH_TOKEN_KEY);\n                case 21:\n                  storageToken = _context11.sent;\n                  if (!storageToken) {\n                    _context11.next = 33;\n                    break;\n                  }\n                  _context11.prev = 23;\n                  _context11.next = 26;\n                  return postRequest(\"/token\", {\n                    refreshToken: storageToken\n                  });\n                case 26:\n                  _session = _context11.sent;\n                  return _context11.abrupt(\"return\", {\n                    session: _session,\n                    error: null\n                  });\n                case 30:\n                  _context11.prev = 30;\n                  _context11.t1 = _context11[\"catch\"](23);\n                  error = _context11.t1.error;\n                case 33:\n                  return _context11.abrupt(\"return\", Promise.reject({\n                    error: error\n                  }));\n                case 34:\n                case \"end\":\n                  return _context11.stop();\n              }\n            }\n          }, _callee11, null, [[4, 11], [23, 30]]);\n        }));\n        function importRefreshToken() {\n          return _importRefreshToken.apply(this, arguments);\n        }\n        return importRefreshToken;\n      }()\n    }\n  });\n};\nvar AuthClient = /*#__PURE__*/function () {\n  function AuthClient(_a) {\n    var _this3 = this;\n    _classCallCheck(this, AuthClient);\n    var _b = _a,\n      _b$clientStorageType = _b.clientStorageType,\n      clientStorageType = _b$clientStorageType === void 0 ? \"web\" : _b$clientStorageType,\n      _b$autoSignIn = _b.autoSignIn,\n      autoSignIn = _b$autoSignIn === void 0 ? true : _b$autoSignIn,\n      _b$autoRefreshToken = _b.autoRefreshToken,\n      autoRefreshToken = _b$autoRefreshToken === void 0 ? true : _b$autoRefreshToken,\n      _b$start = _b.start,\n      start = _b$start === void 0 ? true : _b$start,\n      backendUrl = _b.backendUrl,\n      clientUrl = _b.clientUrl,\n      devTools = _b.devTools,\n      defaultOptions = __objRest(_b, [\"clientStorageType\", \"autoSignIn\", \"autoRefreshToken\", \"start\", \"backendUrl\", \"clientUrl\", \"devTools\"]);\n    this._subscriptions = /* @__PURE__ */new Set();\n    this.backendUrl = backendUrl;\n    this.clientUrl = clientUrl;\n    this.machine = createAuthMachine(__spreadProps(__spreadValues({}, defaultOptions), {\n      backendUrl: backendUrl,\n      clientUrl: clientUrl,\n      clientStorageType: clientStorageType,\n      autoSignIn: autoSignIn,\n      autoRefreshToken: autoRefreshToken\n    }));\n    if (start) {\n      this.interpreter = interpret(this.machine, {\n        devTools: devTools\n      });\n      this.interpreter.start();\n    }\n    if (typeof window !== \"undefined\" && autoSignIn) {\n      try {\n        this._channel = new BroadcastChannel(\"nhost\");\n        this._channel.addEventListener(\"message\", function (token) {\n          var _a2;\n          var existingToken = (_a2 = _this3.interpreter) == null ? void 0 : _a2.state.context.refreshToken.value;\n          if (_this3.interpreter && token.data !== existingToken) {\n            _this3.interpreter.send(\"TRY_TOKEN\", {\n              token: token.data\n            });\n          }\n        });\n      } catch (error) {}\n    }\n  }\n  _createClass(AuthClient, [{\n    key: \"interpreter\",\n    get: function get() {\n      return this._interpreter;\n    },\n    set: function set(interpreter) {\n      var _this4 = this;\n      this._interpreter = interpreter;\n      if (interpreter) {\n        this._subscriptions.forEach(function (fn) {\n          return fn(_this4);\n        });\n      }\n    }\n  }, {\n    key: \"onStart\",\n    value: function onStart(fn) {\n      if (this.interpreter) {\n        fn(this);\n      } else {\n        this._subscriptions.add(fn);\n      }\n    }\n  }]);\n  return AuthClient;\n}();\nvar isBrowser = typeof window !== \"undefined\";\nvar AuthCookieClient = /*#__PURE__*/function (_AuthClient) {\n  _inherits(AuthCookieClient, _AuthClient);\n  var _super3 = _createSuper(AuthCookieClient);\n  function AuthCookieClient(_c) {\n    _classCallCheck(this, AuthCookieClient);\n    var options = __objRest(_c, []);\n    return _super3.call(this, __spreadProps(__spreadValues({}, options), {\n      autoSignIn: isBrowser && options.autoSignIn,\n      autoRefreshToken: isBrowser && options.autoRefreshToken,\n      clientStorageType: \"cookie\"\n    }));\n  }\n  return _createClass(AuthCookieClient);\n}(AuthClient);\nvar AuthClientSSR = AuthCookieClient;\nvar addSecurityKeyPromise = /*#__PURE__*/function () {\n  var _ref49 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(_ref48, nickname) {\n    var backendUrl, interpreter, api, _yield$api$post, options, credential, _yield$api$post2, key, error;\n    return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n      while (1) {\n        switch (_context12.prev = _context12.next) {\n          case 0:\n            backendUrl = _ref48.backendUrl, interpreter = _ref48.interpreter;\n            api = nhostApiClient(backendUrl);\n            _context12.prev = 2;\n            _context12.next = 5;\n            return api.post(\"/user/webauthn/add\", {}, {\n              headers: {\n                authorization: \"Bearer \".concat(interpreter == null ? void 0 : interpreter.state.context.accessToken.value)\n              }\n            });\n          case 5:\n            _yield$api$post = _context12.sent;\n            options = _yield$api$post.data;\n            _context12.prev = 7;\n            _context12.next = 10;\n            return startRegistration(options);\n          case 10:\n            credential = _context12.sent;\n            _context12.next = 16;\n            break;\n          case 13:\n            _context12.prev = 13;\n            _context12.t0 = _context12[\"catch\"](7);\n            throw new CodifiedError(_context12.t0);\n          case 16:\n            _context12.next = 18;\n            return api.post(\"/user/webauthn/verify\", {\n              credential: credential,\n              nickname: nickname\n            }, {\n              headers: {\n                authorization: \"Bearer \".concat(interpreter == null ? void 0 : interpreter.state.context.accessToken.value)\n              }\n            });\n          case 18:\n            _yield$api$post2 = _context12.sent;\n            key = _yield$api$post2.data;\n            return _context12.abrupt(\"return\", {\n              key: key,\n              isError: false,\n              error: null,\n              isSuccess: true\n            });\n          case 23:\n            _context12.prev = 23;\n            _context12.t1 = _context12[\"catch\"](2);\n            error = _context12.t1.error;\n            return _context12.abrupt(\"return\", {\n              isError: true,\n              error: error,\n              isSuccess: false\n            });\n          case 27:\n          case \"end\":\n            return _context12.stop();\n        }\n      }\n    }, _callee12, null, [[2, 23], [7, 13]]);\n  }));\n  return function addSecurityKeyPromise(_x23, _x24) {\n    return _ref49.apply(this, arguments);\n  };\n}();\nvar changeEmailPromise = /*#__PURE__*/function () {\n  var _ref50 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(interpreter, email, options) {\n    return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            return _context13.abrupt(\"return\", new Promise(function (resolve) {\n              interpreter.send(\"REQUEST\", {\n                email: email,\n                options: options\n              });\n              interpreter.onTransition(function (s) {\n                if (s.matches({\n                  idle: \"error\"\n                })) {\n                  resolve({\n                    error: s.context.error,\n                    isError: true,\n                    needsEmailVerification: false\n                  });\n                } else if (s.matches({\n                  idle: \"success\"\n                })) {\n                  resolve({\n                    error: null,\n                    isError: false,\n                    needsEmailVerification: true\n                  });\n                }\n              });\n            }));\n          case 1:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, _callee13);\n  }));\n  return function changeEmailPromise(_x25, _x26, _x27) {\n    return _ref50.apply(this, arguments);\n  };\n}();\nvar changePasswordPromise = /*#__PURE__*/function () {\n  var _ref51 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(interpreter, password, ticket) {\n    return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n      while (1) {\n        switch (_context14.prev = _context14.next) {\n          case 0:\n            return _context14.abrupt(\"return\", new Promise(function (resolve) {\n              interpreter.send(\"REQUEST\", {\n                password: password,\n                ticket: ticket\n              });\n              interpreter.onTransition(function (state) {\n                if (state.matches({\n                  idle: \"error\"\n                })) {\n                  resolve({\n                    error: state.context.error,\n                    isError: true,\n                    isSuccess: false\n                  });\n                } else if (state.matches({\n                  idle: \"success\"\n                })) {\n                  resolve({\n                    error: null,\n                    isError: false,\n                    isSuccess: true\n                  });\n                }\n              });\n            }));\n          case 1:\n          case \"end\":\n            return _context14.stop();\n        }\n      }\n    }, _callee14);\n  }));\n  return function changePasswordPromise(_x28, _x29, _x30) {\n    return _ref51.apply(this, arguments);\n  };\n}();\nvar generateQrCodePromise = function generateQrCodePromise(service) {\n  return new Promise(function (resolve) {\n    service.send(\"GENERATE\");\n    service.onTransition(function (state) {\n      if (state.matches(\"generated\")) {\n        resolve({\n          error: null,\n          isError: false,\n          isGenerated: true,\n          qrCodeDataUrl: state.context.imageUrl || \"\"\n        });\n      } else if (state.matches({\n        idle: \"error\"\n      })) {\n        resolve({\n          error: state.context.error || null,\n          isError: true,\n          isGenerated: false,\n          qrCodeDataUrl: \"\"\n        });\n      }\n    });\n  });\n};\nvar activateMfaPromise = function activateMfaPromise(service, code) {\n  return new Promise(function (resolve) {\n    service.send(\"ACTIVATE\", {\n      activeMfaType: \"totp\",\n      code: code\n    });\n    service.onTransition(function (state) {\n      if (state.matches({\n        generated: \"activated\"\n      })) {\n        resolve({\n          error: null,\n          isActivated: true,\n          isError: false\n        });\n      } else if (state.matches({\n        generated: {\n          idle: \"error\"\n        }\n      })) {\n        resolve({\n          error: state.context.error,\n          isActivated: false,\n          isError: true\n        });\n      }\n    });\n  });\n};\nvar resetPasswordPromise = /*#__PURE__*/function () {\n  var _ref52 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(interpreter, email, options) {\n    return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n      while (1) {\n        switch (_context15.prev = _context15.next) {\n          case 0:\n            return _context15.abrupt(\"return\", new Promise(function (resolve) {\n              interpreter.send(\"REQUEST\", {\n                email: email,\n                options: options\n              });\n              interpreter.onTransition(function (state) {\n                if (state.matches({\n                  idle: \"error\"\n                })) {\n                  resolve({\n                    error: state.context.error,\n                    isError: true,\n                    isSent: false\n                  });\n                } else if (state.matches({\n                  idle: \"success\"\n                })) {\n                  resolve({\n                    error: null,\n                    isError: false,\n                    isSent: true\n                  });\n                }\n              });\n            }));\n          case 1:\n          case \"end\":\n            return _context15.stop();\n        }\n      }\n    }, _callee15);\n  }));\n  return function resetPasswordPromise(_x31, _x32, _x33) {\n    return _ref52.apply(this, arguments);\n  };\n}();\nvar sendVerificationEmailPromise = function sendVerificationEmailPromise(interpreter, email, options) {\n  return new Promise(function (resolve) {\n    interpreter.send(\"REQUEST\", {\n      email: email,\n      options: options\n    });\n    interpreter.onTransition(function (state) {\n      if (state.matches({\n        idle: \"error\"\n      })) {\n        resolve({\n          error: state.context.error,\n          isError: true,\n          isSent: false\n        });\n      } else if (state.matches({\n        idle: \"success\"\n      })) {\n        resolve({\n          error: null,\n          isError: false,\n          isSent: true\n        });\n      }\n    });\n  });\n};\nvar signInAnonymousPromise = function signInAnonymousPromise(interpreter) {\n  return new Promise(function (resolve) {\n    var _interpreter$send = interpreter.send(\"SIGNIN_ANONYMOUS\"),\n      changed = _interpreter$send.changed;\n    if (!changed) {\n      resolve({\n        isSuccess: false,\n        isError: true,\n        error: USER_ALREADY_SIGNED_IN,\n        user: null,\n        accessToken: null\n      });\n    }\n    interpreter.onTransition(function (state) {\n      if (state.matches({\n        authentication: \"signedIn\"\n      })) {\n        resolve({\n          isSuccess: true,\n          isError: false,\n          error: null,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value\n        });\n      }\n      if (state.matches({\n        authentication: {\n          signedOut: \"failed\"\n        }\n      })) {\n        resolve({\n          isSuccess: false,\n          isError: true,\n          error: state.context.errors.authentication || null,\n          user: null,\n          accessToken: null\n        });\n      }\n    });\n  });\n};\nvar signInEmailPasswordPromise = function signInEmailPasswordPromise(interpreter, email, password) {\n  return new Promise(function (resolve) {\n    var _interpreter$send2 = interpreter.send(\"SIGNIN_PASSWORD\", {\n        email: email,\n        password: password\n      }),\n      changed = _interpreter$send2.changed,\n      context = _interpreter$send2.context;\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        needsMfaOtp: false,\n        mfa: null,\n        user: context.user\n      });\n    }\n    interpreter.onTransition(function (state) {\n      if (state.matches({\n        authentication: {\n          signedOut: \"noErrors\"\n        },\n        registration: {\n          incomplete: \"needsEmailVerification\"\n        }\n      })) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: {\n          signedOut: \"needsMfa\"\n        }\n      })) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: true,\n          mfa: state.context.mfa,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: {\n          signedOut: \"failed\"\n        }\n      })) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: \"signedIn\"\n      })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: state.context.user\n        });\n      }\n    });\n  });\n};\nvar signInEmailPasswordlessPromise = function signInEmailPasswordlessPromise(interpreter, email, options) {\n  return new Promise(function (resolve) {\n    var _interpreter$send3 = interpreter.send(\"PASSWORDLESS_EMAIL\", {\n        email: email,\n        options: options\n      }),\n      changed = _interpreter$send3.changed;\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false\n      });\n    }\n    interpreter.onTransition(function (state) {\n      if (state.matches(\"registration.incomplete.failed\")) {\n        resolve({\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false\n        });\n      } else if (state.matches({\n        authentication: {\n          signedOut: \"noErrors\"\n        },\n        registration: {\n          incomplete: \"needsEmailVerification\"\n        }\n      })) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: true\n        });\n      }\n    });\n  });\n};\nvar signInEmailSecurityKeyPromise = function signInEmailSecurityKeyPromise(interpreter, email) {\n  return new Promise(function (resolve) {\n    var _interpreter$send4 = interpreter.send({\n        type: \"SIGNIN_SECURITY_KEY_EMAIL\",\n        email: email\n      }),\n      changed = _interpreter$send4.changed,\n      context = _interpreter$send4.context;\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      });\n    }\n    interpreter.onTransition(function (state) {\n      if (state.matches({\n        authentication: {\n          signedOut: \"noErrors\"\n        },\n        registration: {\n          incomplete: \"needsEmailVerification\"\n        }\n      })) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: {\n          signedOut: \"failed\"\n        }\n      })) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: \"signedIn\"\n      })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        });\n      }\n    });\n  });\n};\nvar signInMfaTotpPromise = function signInMfaTotpPromise(interpreter, otp, ticket) {\n  return new Promise(function (resolve) {\n    var _interpreter$send5 = interpreter.send(\"SIGNIN_MFA_TOTP\", {\n        otp: otp,\n        ticket: ticket\n      }),\n      changed = _interpreter$send5.changed,\n      context = _interpreter$send5.context;\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: context.user\n      });\n    }\n    interpreter.onTransition(function (state) {\n      if (state.matches({\n        authentication: {\n          signedOut: \"failed\"\n        }\n      })) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: \"signedIn\"\n      })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user\n        });\n      }\n    });\n  });\n};\nvar signInSmsPasswordlessPromise = function signInSmsPasswordlessPromise(interpreter, phoneNumber, options) {\n  return new Promise(function (resolve) {\n    var _interpreter$send6 = interpreter.send(\"PASSWORDLESS_SMS\", {\n        phoneNumber: phoneNumber,\n        options: options\n      }),\n      changed = _interpreter$send6.changed;\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsOtp: false\n      });\n    }\n    interpreter.onTransition(function (state) {\n      if (state.matches(\"registration.incomplete.needsOtp\")) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsOtp: true\n        });\n      } else if (state.matches(\"registration.incomplete.failed\")) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsOtp: false\n        });\n      }\n    });\n  });\n};\nvar signInSmsPasswordlessOtpPromise = function signInSmsPasswordlessOtpPromise(interpreter, phoneNumber, otp) {\n  return new Promise(function (resolve) {\n    var _interpreter$send7 = interpreter.send({\n        type: \"PASSWORDLESS_SMS_OTP\",\n        phoneNumber: phoneNumber,\n        otp: otp\n      }),\n      changed = _interpreter$send7.changed;\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: null,\n        accessToken: null\n      });\n    }\n    interpreter.onTransition(function (state) {\n      if (state.matches({\n        authentication: \"signedIn\"\n      })) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value\n        });\n      } else if (state.matches({\n        registration: {\n          incomplete: \"failed\"\n        }\n      })) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null,\n          accessToken: null\n        });\n      }\n    });\n  });\n};\nvar signOutPromise = /*#__PURE__*/function () {\n  var _ref53 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(interpreter, all) {\n    return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n      while (1) {\n        switch (_context16.prev = _context16.next) {\n          case 0:\n            return _context16.abrupt(\"return\", new Promise(function (resolve) {\n              var _interpreter$send8 = interpreter.send(\"SIGNOUT\", {\n                  all: all\n                }),\n                event = _interpreter$send8.event;\n              if (event.type !== \"SIGNED_OUT\") {\n                return resolve({\n                  isSuccess: false,\n                  isError: true,\n                  error: USER_UNAUTHENTICATED\n                });\n              }\n              interpreter.onTransition(function (state) {\n                if (state.matches({\n                  authentication: {\n                    signedOut: \"success\"\n                  }\n                })) {\n                  resolve({\n                    isSuccess: true,\n                    isError: false,\n                    error: null\n                  });\n                } else if (state.matches(\"authentication.signedOut.failed\")) {\n                  resolve({\n                    isSuccess: false,\n                    isError: true,\n                    error: state.context.errors.signout || null\n                  });\n                }\n              });\n            }));\n          case 1:\n          case \"end\":\n            return _context16.stop();\n        }\n      }\n    }, _callee16);\n  }));\n  return function signOutPromise(_x34, _x35) {\n    return _ref53.apply(this, arguments);\n  };\n}();\nvar signUpEmailPasswordPromise = function signUpEmailPasswordPromise(interpreter, email, password, options) {\n  return new Promise(function (resolve) {\n    var _interpreter$send9 = interpreter.send(\"SIGNUP_EMAIL_PASSWORD\", {\n        email: email,\n        password: password,\n        options: options\n      }),\n      changed = _interpreter$send9.changed,\n      context = _interpreter$send9.context;\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      });\n    }\n    interpreter.onTransition(function (state) {\n      if (state.matches(\"registration.incomplete.failed\")) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: {\n          signedOut: \"noErrors\"\n        },\n        registration: {\n          incomplete: \"needsEmailVerification\"\n        }\n      })) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: \"signedIn\",\n        registration: \"complete\"\n      })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        });\n      }\n    });\n  });\n};\nvar signUpEmailSecurityKeyPromise = function signUpEmailSecurityKeyPromise(interpreter, email, options) {\n  return new Promise(function (resolve) {\n    var _interpreter$send10 = interpreter.send(\"SIGNUP_SECURITY_KEY\", {\n        email: email,\n        options: options\n      }),\n      changed = _interpreter$send10.changed,\n      context = _interpreter$send10.context;\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      });\n    }\n    interpreter.onTransition(function (state) {\n      if (state.matches(\"registration.incomplete.failed\")) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: {\n          signedOut: \"noErrors\"\n        },\n        registration: {\n          incomplete: \"needsEmailVerification\"\n        }\n      })) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        });\n      } else if (state.matches({\n        authentication: \"signedIn\",\n        registration: \"complete\"\n      })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        });\n      }\n    });\n  });\n};\nexport { AuthClient, AuthClientSSR, AuthCookieClient, CodifiedError, EMAIL_NEEDS_VERIFICATION, INVALID_EMAIL_ERROR, INVALID_MFA_CODE_ERROR, INVALID_MFA_TICKET_ERROR, INVALID_MFA_TYPE_ERROR, INVALID_PASSWORD_ERROR, INVALID_PHONE_NUMBER_ERROR, INVALID_REFRESH_TOKEN, MIN_PASSWORD_LENGTH, NETWORK_ERROR_CODE, NHOST_JWT_EXPIRES_AT_KEY, NHOST_REFRESH_TOKEN_KEY, NO_MFA_TICKET_ERROR, NO_REFRESH_TOKEN, OTHER_ERROR_CODE, REFRESH_TOKEN_RETRY_INTERVAL, REFRESH_TOKEN_RETRY_MAX_ATTEMPTS, STATE_ERROR_CODE, TOKEN_REFRESHER_RUNNING_ERROR, TOKEN_REFRESH_MARGIN, USER_ALREADY_SIGNED_IN, USER_NOT_ANONYMOUS, USER_UNAUTHENTICATED, VALIDATION_ERROR_CODE, activateMfaPromise, addSecurityKeyPromise, changeEmailPromise, changePasswordPromise, createAuthMachine, createChangeEmailMachine, createChangePasswordMachine, createEnableMfaMachine, createResetPasswordMachine, createSendVerificationEmailMachine, encodeQueryParameters, generateQrCodePromise, getParameterByName, localStorageGetter, localStorageSetter, removeParameterFromWindow, resetPasswordPromise, rewriteRedirectTo, sendVerificationEmailPromise, signInAnonymousPromise, signInEmailPasswordPromise, signInEmailPasswordlessPromise, signInEmailSecurityKeyPromise, signInMfaTotpPromise, signInSmsPasswordlessOtpPromise, signInSmsPasswordlessPromise, signOutPromise, signUpEmailPasswordPromise, signUpEmailSecurityKeyPromise };","map":{"version":3,"mappings":"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","names":["value","TextEncoder","encode","buffer","bytes","Uint8Array","str","charCode","String","fromCharCode","base64String","btoa","replace","base64URLString","base64","padLength","length","padded","padEnd","binary","atob","ArrayBuffer","i","charCodeAt","window","PublicKeyCredential","descriptor","id","__spreadProps","base64URLStringToBuffer","transports","hostname","test","WebAuthnError","message","name","Error","error","options","_a","_b","publicKey","signal","AbortController","authenticatorSelection","requireResidentKey","userVerification","validPubKeyCredParams","pubKeyCredParams","filter","param","type","effectiveDomain","location","isValidDomain","rp","user","byteLength","WebAuthnAbortService","controller","abort","webauthnAbortService","startRegistration","creationOptionsJSON","browserSupportsWebAuthn","challenge","utf8StringToBuffer","excludeCredentials","map","toPublicKeyCredentialDescriptor","createNewAbortSignal","navigator","credentials","create","credential","identifyRegistrationError","reset","rawId","response","credentialJSON","bufferToBase64URLString","attestationObject","clientDataJSON","clientExtensionResults","getClientExtensionResults","authenticatorAttachment","getTransports","TextDecoder","decode","browserSupportsWebAuthnAutofill","conditionalMediationSupported","globalPublicKeyCredential","isConditionalMediationAvailable","allowCredentials","rpId","startAuthentication","requestOptionsJSON","useBrowserAutofill","eligibleInputs","document","querySelectorAll","mediation","get","identifyAuthenticationError","userHandle","bufferToUTF8String","authenticatorData","signature","NHOST_REFRESH_TOKEN_KEY","NHOST_JWT_EXPIRES_AT_KEY","MIN_PASSWORD_LENGTH","TOKEN_REFRESH_MARGIN","REFRESH_TOKEN_RETRY_INTERVAL","REFRESH_TOKEN_RETRY_MAX_ATTEMPTS","NETWORK_ERROR_CODE","OTHER_ERROR_CODE","VALIDATION_ERROR_CODE","STATE_ERROR_CODE","CodifiedError","original","constructor","status","INVALID_EMAIL_ERROR","INVALID_MFA_TYPE_ERROR","INVALID_MFA_CODE_ERROR","INVALID_PASSWORD_ERROR","INVALID_PHONE_NUMBER_ERROR","INVALID_MFA_TICKET_ERROR","NO_MFA_TICKET_ERROR","NO_REFRESH_TOKEN","TOKEN_REFRESHER_RUNNING_ERROR","USER_ALREADY_SIGNED_IN","USER_UNAUTHENTICATED","USER_NOT_ANONYMOUS","EMAIL_NEEDS_VERIFICATION","INVALID_REFRESH_TOKEN","nhostApiClient","backendUrl","client","axios","baseURL","use","reject","data","request","responseText","JSON","stringify","statusCode","statusText","isBrowser","inMemoryLocalStorage","Map","defaultClientStorageGetter","key","localStorage","getItem","defaultClientStorageSetter","removeItem","has","delete","localStorageGetter","clientStorageType","clientStorage","getItemAsync","localStorageSetter","Cookies","set","expires","remove","setItem","setItemAsync","deleteItemAsync","encodeQueryParameters","baseUrl","parameters","Object","entries","stringValue","Array","isArray","join","encodeURIComponent","encodedParameters","rewriteRedirectTo","clientUrl","redirectTo","otherOptions","startsWith","URL","clientParams","fromEntries","URLSearchParams","baseClientUrl","search","origin","additionalParams","url","combinedParams","pathName","pathname","slice","href","RegExp","results","regex","exec","decodeURIComponent","hash","from","toString","history","pushState","isValidEmail","email","toLowerCase","match","isValidPassword","password","isValidPhoneNumber","phoneNumber","isValidTicket","ticket","INITIAL_MACHINE_CONTEXT","mfa","accessToken","expiresAt","refreshTimer","startedAt","attempts","lastAttempt","refreshToken","errors","createChangeEmailMachine","interpreter","createMachine","schema","context","events","services","tsTypes","preserveActionOrder","initial","states","idle","on","REQUEST","cond","actions","target","success","requesting","invoke","src","onDone","onError","saveInvalidEmailError","assign","_","saveRequestError","reportError","send","ctx","reportSuccess","guards","invalidEmail","requestChange","api","post","newEmail","headers","authorization","state","res","createChangePasswordMachine","saveInvalidPasswordError","invalidPassword","newPassword","createEnableMfaMachine","imageUrl","secret","GENERATE","generating","generated","ACTIVATE","activating","activated","saveInvalidMfaTypeError","saveInvalidMfaCodeError","saveError","saveGeneration","totpSecret","reportGeneratedSuccess","reportGeneratedError","invalidMfaCode","code","invalidMfaType","activeMfaType","generate","activate","createResetPasswordMachine","createSendVerificationEmailMachine","createAuthMachine","clientStorageGetter","clientStorageSetter","refreshIntervalTime","autoRefreshToken","autoSignIn","storageGetter","storageSetter","postRequest","config","result","authentication","SESSION_UPDATE","starting","entry","tags","always","signedOut","noErrors","needsSmsOtp","needsMfa","failed","signingOut","exit","SIGNIN_PASSWORD","SIGNIN_ANONYMOUS","SIGNIN_SECURITY_KEY_EMAIL","SIGNIN_MFA_TOTP","authenticating","anonymous","totp","securityKeyEmail","signedIn","SIGNOUT","disabled","stopped","running","pending","after","internal","refreshing","token","TRY_TOKEN","registration","SIGNED_IN","incomplete","SIGNUP_EMAIL_PASSWORD","SIGNUP_SECURITY_KEY","PASSWORDLESS_EMAIL","PASSWORDLESS_SMS","PASSWORDLESS_SMS_OTP","needsEmailVerification","needsOtp","emailPassword","securityKey","passwordlessEmail","passwordlessSms","passwordlessSmsOtp","complete","SIGNED_OUT","reportSignedIn","reportSignedOut","reportTokenChanged","clearContext","clearContextExceptRefreshToken","saveSession","session","accessTokenExpiresIn","nextRefresh","Date","now","toISOString","saveMfaTicket","e","resetTimer","saveRefreshAttempt","saveAuthenticationError","resetErrors","saveRegistrationError","destroyRefreshToken","cleanUrl","getParameterByName","removeParameterFromWindow","broadcastToken","BroadcastChannel","channel","isAnonymous","isSignedIn","noToken","hasRefreshToken","isAutoRefreshDisabled","refreshTimerShouldRefresh","elapsed","getTime","expiresIn","remaining","unverified","hasSession","hasMfaTicket","signInPassword","Promise","console","warn","signInMethod","connection","otp","signInAnonymous","signInMfaTotp","signInSecurityKeyEmail","event","signout","all","signUpEmailPassword","signUpSecurityKey","nickname","webAuthnOptions","importRefreshToken","urlToken","error2","storageToken","AuthClient","start","devTools","defaultOptions","Set","machine","interpret","_channel","addEventListener","existingToken","_interpreter","_subscriptions","forEach","fn","add","AuthCookieClient","_c","AuthClientSSR","addSecurityKeyPromise","isError","isSuccess","resolve","s","matches","changeEmailPromise","changePasswordPromise","generateQrCodePromise","service","isGenerated","qrCodeDataUrl","activateMfaPromise","isActivated","isSent","resetPasswordPromise","sendVerificationEmailPromise","signInAnonymousPromise","changed","signInEmailPasswordPromise","needsMfaOtp","signInEmailPasswordlessPromise","signInEmailSecurityKeyPromise","signInMfaTotpPromise","signInSmsPasswordlessPromise","signInSmsPasswordlessOtpPromise","signOutPromise","signUpEmailPasswordPromise","signUpEmailSecurityKeyPromise"],"sources":["C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\node_modules\\.pnpm\\@simplewebauthn+browser@6.0.0\\node_modules\\@simplewebauthn\\browser\\dist\\bundle\\index.js","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\constants.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\errors.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\hasura-auth.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\storage.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\utils.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\validators.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\machines\\context.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\machines\\change-email.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\machines\\change-password.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\machines\\enable-mfa.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\machines\\reset-password.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\machines\\send-verification-email.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\machines\\index.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\client.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\cookie-client.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\addSecurityKey.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\changeEmail.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\changePassword.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\mfa.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\resetPassword.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\sendVerificationEmail.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signInAnonymous.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signInEmailPassword.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signInEmailPasswordless.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signInEmailSecurityKey.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signInMfaTotp.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signInSmsPasswordless.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signInSmsPasswordlessOtp.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signOut.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signUpEmailPassword.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signUpEmailSecurityKey.ts"],"sourcesContent":["/* [@simplewebauthn/browser@6.0.0] */\nfunction utf8StringToBuffer(value) {\n    return new TextEncoder().encode(value);\n}\n\nfunction bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction base64URLStringToBuffer(base64URLString) {\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    const binary = atob(padded);\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n\nfunction browserSupportsWebAuthn() {\n    return ((window === null || window === void 0 ? void 0 : window.PublicKeyCredential) !== undefined && typeof window.PublicKeyCredential === 'function');\n}\n\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        transports: descriptor.transports,\n    };\n}\n\nfunction isValidDomain(hostname) {\n    return (hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n\nclass WebAuthnError extends Error {\n    constructor(message, name = 'WebAuthnError') {\n        super(message);\n        this.name = name;\n    }\n}\n\nfunction identifyRegistrationError({ error, options, }) {\n    var _a, _b;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal === new AbortController().signal) {\n            return new WebAuthnError('Registration ceremony was sent an abort signal', 'AbortError');\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {\n            return new WebAuthnError('Discoverable credentials were required but no available authenticator supported it', 'ConstraintError');\n        }\n        else if (((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === 'required') {\n            return new WebAuthnError('User verification was required but no available authenticator supported it', 'ConstraintError');\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        return new WebAuthnError('The authenticator was previously registered', 'InvalidStateError');\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError('User clicked cancel, or the registration ceremony timed out', 'NotAllowedError');\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter(param => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            return new WebAuthnError('No entry in pubKeyCredParams was of type \"public-key\"', 'NotSupportedError');\n        }\n        return new WebAuthnError('No available authenticator supported any of the specified pubKeyCredParams algorithms', 'NotSupportedError');\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError(`${window.location.hostname} is an invalid domain`, 'SecurityError');\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            return new WebAuthnError(`The RP ID \"${publicKey.rp.id}\" is invalid for this domain`, 'SecurityError');\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            return new WebAuthnError('User ID was not between 1 and 64 characters', 'TypeError');\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError('The authenticator was unable to process the specified options, or could not create a new credential', 'UnknownError');\n    }\n    return error;\n}\n\nclass WebAuthnAbortService {\n    createNewAbortSignal() {\n        if (this.controller) {\n            this.controller.abort();\n        }\n        this.controller = new AbortController();\n        return this.controller.signal;\n    }\n    reset() {\n        this.controller = undefined;\n    }\n}\nconst webauthnAbortService = new WebAuthnAbortService();\n\nasync function startRegistration(creationOptionsJSON) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    const publicKey = {\n        ...creationOptionsJSON,\n        challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n        user: {\n            ...creationOptionsJSON.user,\n            id: utf8StringToBuffer(creationOptionsJSON.user.id),\n        },\n        excludeCredentials: creationOptionsJSON.excludeCredentials.map(toPublicKeyCredentialDescriptor),\n    };\n    const options = { publicKey };\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(options));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options });\n    }\n    finally {\n        webauthnAbortService.reset();\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    const credentialJSON = {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: credential.authenticatorAttachment,\n    };\n    if (typeof response.getTransports === 'function') {\n        credentialJSON.transports = response.getTransports();\n    }\n    return credentialJSON;\n}\n\nfunction bufferToUTF8String(value) {\n    return new TextDecoder('utf-8').decode(value);\n}\n\nasync function browserSupportsWebAuthnAutofill() {\n    if (navigator.credentials.conditionalMediationSupported) {\n        return true;\n    }\n    const globalPublicKeyCredential = window.PublicKeyCredential;\n    return (globalPublicKeyCredential.isConditionalMediationAvailable !== undefined &&\n        globalPublicKeyCredential.isConditionalMediationAvailable());\n}\n\nfunction identifyAuthenticationError({ error, options, }) {\n    var _a;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal === new AbortController().signal) {\n            return new WebAuthnError('Authentication ceremony was sent an abort signal', 'AbortError');\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        if ((_a = publicKey.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) {\n            return new WebAuthnError('No available authenticator recognized any of the allowed credentials', 'NotAllowedError');\n        }\n        return new WebAuthnError('User clicked cancel, or the authentication ceremony timed out', 'NotAllowedError');\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError(`${window.location.hostname} is an invalid domain`, 'SecurityError');\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            return new WebAuthnError(`The RP ID \"${publicKey.rpId}\" is invalid for this domain`, 'SecurityError');\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError('The authenticator was unable to process the specified options, or could not create a new assertion signature', 'UnknownError');\n    }\n    return error;\n}\n\nasync function startAuthentication(requestOptionsJSON, useBrowserAutofill = false) {\n    var _a, _b;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    let allowCredentials;\n    if (((_a = requestOptionsJSON.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) !== 0) {\n        allowCredentials = (_b = requestOptionsJSON.allowCredentials) === null || _b === void 0 ? void 0 : _b.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n        ...requestOptionsJSON,\n        challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n        allowCredentials,\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete*='webauthn']\");\n        if (eligibleInputs.length < 1) {\n            throw Error('No <input> with `\"webauthn\"` in its `autocomplete` attribute was detected');\n        }\n        options.mediation = 'conditional';\n        publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(options));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options });\n    }\n    finally {\n        webauthnAbortService.reset();\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToUTF8String(response.userHandle);\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: credential.authenticatorAttachment,\n    };\n}\n\nasync function platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return false;\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport { browserSupportsWebAuthn, browserSupportsWebAuthnAutofill, platformAuthenticatorIsAvailable, startAuthentication, startRegistration };\n","export const NHOST_REFRESH_TOKEN_KEY = 'nhostRefreshToken'\nexport const NHOST_JWT_EXPIRES_AT_KEY = 'nhostRefreshTokenExpiresAt'\n\nexport const MIN_PASSWORD_LENGTH = 3\n\n/**\n * Minimum time in seconds between now and the JWT expiration time before the JWT is refreshed\n * For instance, if set to 60, the client will refresh the JWT one minute before it expires\n */\nexport const TOKEN_REFRESH_MARGIN = 300 // five minutes\n\n/** Number of seconds before retrying a token refresh after an error */\nexport const REFRESH_TOKEN_RETRY_INTERVAL = 5\n\n// TODO not yet implemented\n// TODO try when offline for a long time: maybe we could keep state as 'signedIn'\n/** Maximum number of attempts to refresh a token before stopping the timer and logging out */\nexport const REFRESH_TOKEN_RETRY_MAX_ATTEMPTS = 30\n","export const NETWORK_ERROR_CODE = 0\nexport const OTHER_ERROR_CODE = 1\nexport const VALIDATION_ERROR_CODE = 10\nexport const STATE_ERROR_CODE = 20\n\nexport type ErrorPayload = {\n  error: string\n  status: number\n  message: string\n}\n\n/**\n * @internal\n * Adds a standard error payload to any JS Error, or convert a standard error payload into a JS Error.\n * Allows xstate to use `throw` instead of `Promise.reject` to propagate errors.\n * See https://github.com/statelyai/xstate/issues/3037\n */\nexport class CodifiedError extends Error {\n  error: ErrorPayload\n  constructor(original: Error | ErrorPayload) {\n    super(original.message)\n    Error.captureStackTrace(this, this.constructor)\n    if (original instanceof Error) {\n      this.name = original.name\n      this.error = {\n        error: original.name,\n        status: OTHER_ERROR_CODE,\n        message: original.message\n      }\n    } else {\n      this.name = original.error\n      this.error = original\n    }\n  }\n}\n\nexport type ValidationErrorPayload = ErrorPayload & { status: typeof VALIDATION_ERROR_CODE }\n\n// TODO share with hasura-auth\nexport const INVALID_EMAIL_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-email',\n  message: 'Email is incorrectly formatted'\n}\n\nexport const INVALID_MFA_TYPE_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-type',\n  message: 'MFA type is invalid'\n}\n\nexport const INVALID_MFA_CODE_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-code',\n  message: 'MFA code is invalid'\n}\n\nexport const INVALID_PASSWORD_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-password',\n  message: 'Password is incorrectly formatted'\n}\n\nexport const INVALID_PHONE_NUMBER_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-phone-number',\n  message: 'Phone number is incorrectly formatted'\n}\n\nexport const INVALID_MFA_TICKET_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-ticket',\n  message: 'MFA ticket is invalid'\n}\n\nexport const NO_MFA_TICKET_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'no-mfa-ticket',\n  message: 'No MFA ticket has been provided'\n}\n\nexport const NO_REFRESH_TOKEN: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'no-refresh-token',\n  message: 'No refresh token has been provided'\n}\n\nexport const TOKEN_REFRESHER_RUNNING_ERROR: ErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'refresher-already-running',\n  message:\n    'The token refresher is already running. You must wait until is has finished before submitting a new token.'\n}\n\nexport const USER_ALREADY_SIGNED_IN: ErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'already-signed-in',\n  message: 'User is already signed in'\n}\n\nexport const USER_UNAUTHENTICATED: ErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'unauthenticated-user',\n  message: 'User is not authenticated'\n}\n\nexport const USER_NOT_ANONYMOUS: ErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'user-not-anonymous',\n  message: 'User is not anonymous'\n}\n\nexport const EMAIL_NEEDS_VERIFICATION: ErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'unverified-user',\n  message: 'Email needs verification'\n}\n\nexport const INVALID_REFRESH_TOKEN = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-refresh-token',\n  message: 'Invalid or expired refresh token'\n}\n","import axios, { AxiosError } from 'axios'\n\nimport { ErrorPayload, NETWORK_ERROR_CODE } from './errors'\n\nexport const nhostApiClient = (backendUrl: string) => {\n  const client = axios.create({ baseURL: backendUrl })\n\n  client.interceptors.response.use(\n    (response) => response,\n    (error: AxiosError<{ message: string; error?: string; statusCode?: number }>) =>\n      Promise.reject<{ error: ErrorPayload }>({\n        error: {\n          message:\n            error.response?.data?.message ??\n            error.message ??\n            error.request.responseText ??\n            JSON.stringify(error),\n          status: error.response?.status ?? error.response?.data.statusCode ?? NETWORK_ERROR_CODE,\n          error: error.response?.data.error || error.request.statusText || 'network'\n        }\n      })\n  )\n  return client\n}\n","import Cookies from 'js-cookie'\n\nimport { ClientStorage, ClientStorageType } from './types'\nexport type StorageGetter = (key: string) => string | null | Promise<string | null>\nexport type StorageSetter = (key: string, value: string | null) => void | Promise<void>\n\nconst isBrowser = typeof window !== 'undefined'\n\nconst inMemoryLocalStorage: Map<string, string | null> = new Map()\n\nconst defaultClientStorageGetter: StorageGetter = (key) => {\n  if (isBrowser && typeof localStorage !== 'undefined') return localStorage.getItem(key)\n  else return inMemoryLocalStorage.get(key) ?? null\n}\n\nconst defaultClientStorageSetter: StorageSetter = (key, value) => {\n  if (isBrowser && typeof localStorage !== 'undefined') {\n    if (value) {\n      localStorage.setItem(key, value)\n    } else {\n      localStorage.removeItem(key)\n    }\n  } else {\n    if (value) {\n      inMemoryLocalStorage.set(key, value)\n    } else if (inMemoryLocalStorage.has(key)) {\n      inMemoryLocalStorage.delete(key)\n    }\n  }\n}\n\nexport const localStorageGetter = (\n  clientStorageType: ClientStorageType,\n  clientStorage?: ClientStorage\n): StorageGetter => {\n  if (clientStorageType === 'localStorage' || clientStorageType === 'web') {\n    return defaultClientStorageGetter\n  }\n  if (clientStorageType === 'cookie') {\n    return (key) => {\n      if (isBrowser) {\n        return Cookies.get(key) ?? null\n      } else {\n        return null\n      }\n    }\n  }\n  if (!clientStorage) {\n    throw Error(\n      `clientStorageType is set to '${clientStorageType}' but no clientStorage has been given`\n    )\n  }\n  if (clientStorageType === 'react-native') {\n    return (key) => clientStorage.getItem?.(key)\n  }\n  if (clientStorageType === 'capacitor') {\n    return (key) => clientStorage.get?.({ key })\n  }\n  if (clientStorageType === 'expo-secure-storage') {\n    return (key) => clientStorage.getItemAsync?.(key)\n  }\n  if (clientStorageType === 'custom') {\n    if (clientStorage.getItem && clientStorage.removeItem) {\n      return clientStorage.getItem\n    }\n    if (clientStorage.getItemAsync) {\n      return clientStorage.getItemAsync\n    }\n    throw Error(\n      `clientStorageType is set to 'custom' but clientStorage is missing either \"getItem\" and \"removeItem\" properties or \"getItemAsync\" property`\n    )\n  }\n  throw Error(`Unknown storage type: ${clientStorageType}`)\n}\n\nexport const localStorageSetter = (\n  clientStorageType: ClientStorageType,\n  clientStorage?: ClientStorage\n): StorageSetter => {\n  if (clientStorageType === 'localStorage' || clientStorageType === 'web') {\n    return defaultClientStorageSetter\n  }\n  if (clientStorageType === 'cookie') {\n    return (key, value) => {\n      if (isBrowser) {\n        if (value) {\n          // TODO: Set expires based on the actual refresh token expire time\n          // For now, we're using 30 days so the cookie is not removed when the browser is closed because if `expiers` is omitted, the cookie becomes a session cookie.\n          Cookies.set(key, value, { expires: 30 })\n        } else {\n          Cookies.remove(key)\n        }\n      }\n    }\n  }\n  if (!clientStorage) {\n    throw Error(\n      `clientStorageType is set to '${clientStorageType}' but no clienStorage has been given`\n    )\n  }\n  if (clientStorageType === 'react-native') {\n    return (key, value) =>\n      value ? clientStorage.setItem?.(key, value) : clientStorage.removeItem?.(key)\n  }\n  if (clientStorageType === 'capacitor') {\n    return (key, value) =>\n      value ? clientStorage.set?.({ key, value }) : clientStorage.remove?.({ key })\n  }\n  if (clientStorageType === 'expo-secure-storage') {\n    return async (key, value) =>\n      value ? clientStorage.setItemAsync?.(key, value) : clientStorage.deleteItemAsync?.(key)\n  }\n  if (clientStorageType === 'custom') {\n    if (!clientStorage.removeItem) {\n      throw Error(\n        `clientStorageType is set to 'custom' but clientStorage is missing a removeItem property`\n      )\n    }\n    if (clientStorage.setItem) {\n      return (key, value) =>\n        value ? clientStorage.setItem?.(key, value) : clientStorage.removeItem?.(key)\n    }\n    if (clientStorage.setItemAsync) {\n      return async (key, value) =>\n        value ? clientStorage.setItemAsync?.(key, value) : clientStorage.removeItem?.(key)\n    }\n    throw Error(\n      `clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property`\n    )\n  }\n  throw Error(`Unknown storage type: ${clientStorageType}`)\n}\n","import { RedirectOption } from './types'\n\nexport const encodeQueryParameters = (baseUrl: string, parameters?: Record<string, unknown>) => {\n  const encodedParameters =\n    parameters &&\n    Object.entries(parameters)\n      .map(([key, value]) => {\n        const stringValue = Array.isArray(value)\n          ? value.join(',')\n          : typeof value === 'object'\n          ? JSON.stringify(value)\n          : (value as string)\n        return `${key}=${encodeURIComponent(stringValue)}`\n      })\n      .join('&')\n  if (encodedParameters) return `${baseUrl}?${encodedParameters}`\n  else return baseUrl\n}\n\n/**\n * Transform options that include a redirectTo property so the\n * redirect url is absolute, given a base clientUrl.\n * If no client url is given, any relative redirectUrl is removed while\n * the other options are sent as-is.\n * @param clientUrl base client url\n * @param options\n * @returns\n */\nexport const rewriteRedirectTo = <T extends RedirectOption>(\n  clientUrl?: string,\n  options?: T\n): (Omit<T, 'redirectTo'> & { redirectTo?: string }) | undefined => {\n  if (!options?.redirectTo) {\n    return options\n  }\n  const { redirectTo, ...otherOptions } = options\n  // * If the clientUrl is not defined, we can't rewrite the redirectTo\n  if (!clientUrl) {\n    // * If redirectTo is a relative path, we therefore pull it out of the options\n    if (redirectTo.startsWith('/')) {\n      return otherOptions\n    } else {\n      return options\n    }\n  }\n  const baseClientUrl = new URL(clientUrl)\n  const clientParams = Object.fromEntries(new URLSearchParams(baseClientUrl.search))\n  const url = new URL(redirectTo.startsWith('/') ? baseClientUrl.origin + redirectTo : redirectTo)\n  const additionalParams = new URLSearchParams(url.search)\n  let combinedParams = Object.fromEntries(additionalParams)\n\n  if (redirectTo.startsWith('/')) {\n    combinedParams = { ...clientParams, ...combinedParams }\n  }\n  let pathName = baseClientUrl.pathname\n  if (url.pathname.length > 1) {\n    pathName += url.pathname.slice(1)\n  }\n  return {\n    ...otherOptions,\n    redirectTo: encodeQueryParameters(url.origin + pathName, combinedParams)\n  }\n}\n\nexport function getParameterByName(name: string, url?: string) {\n  if (!url) {\n    if (typeof window === 'undefined') {\n      return\n    }\n    url = window.location?.href || ''\n  }\n  // eslint-disable-next-line no-useless-escape\n  name = name.replace(/[\\[\\]]/g, '\\\\$&')\n  const regex = new RegExp('[?&#]' + name + '(=([^&#]*)|&|#|$)'),\n    results = regex.exec(url)\n  if (!results) return null\n  if (!results[2]) return ''\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '))\n}\n\nexport function removeParameterFromWindow(name: string) {\n  if (typeof window === 'undefined') {\n    return\n  }\n  const location = window?.location\n  if (!location) {\n    return\n  }\n  if (location) {\n    const search = new URLSearchParams(location.search)\n    const hash = new URLSearchParams(location.hash?.slice(1))\n    search.delete(name)\n    hash.delete(name)\n    let url = window.location.pathname\n    if (Array.from(search).length) url += `?${search.toString()}`\n    if (Array.from(hash).length) url += `#${hash.toString()}`\n    window.history.pushState({}, '', url)\n  }\n}\n","import { MIN_PASSWORD_LENGTH } from './constants'\n\nexport const isValidEmail = (email?: string | null) =>\n  !!email &&\n  typeof email === 'string' &&\n  !!String(email)\n    .toLowerCase()\n    .match(\n      /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\n    )\n\nexport const isValidPassword = (password?: string | null) =>\n  !!password && typeof password === 'string' && password.length >= MIN_PASSWORD_LENGTH\n\n// TODO improve validation\nexport const isValidPhoneNumber = (phoneNumber?: string | null) =>\n  !!phoneNumber && typeof phoneNumber === 'string'\n\nexport const isValidTicket = (ticket?: string | null) =>\n  ticket &&\n  typeof ticket === 'string' &&\n  ticket.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)\n","import type { ErrorPayload } from '../errors'\nimport { User } from '../types'\n\nexport type StateErrorTypes = 'registration' | 'authentication' | 'signout'\n\nexport type AuthContext = {\n  user: User | null\n  mfa: {\n    ticket: string\n  } | null\n  accessToken: {\n    value: string | null\n    expiresAt: Date | null\n  }\n  refreshTimer: {\n    startedAt: Date | null\n    attempts: number\n    lastAttempt: Date | null\n  }\n  refreshToken: {\n    value: string | null\n  }\n  errors: Partial<Record<StateErrorTypes, ErrorPayload>>\n}\n\nexport const INITIAL_MACHINE_CONTEXT: AuthContext = {\n  user: null,\n  mfa: null,\n  accessToken: {\n    value: null,\n    expiresAt: null\n  },\n  refreshTimer: {\n    startedAt: null,\n    attempts: 0,\n    lastAttempt: null\n  },\n  refreshToken: {\n    value: null\n  },\n  errors: {}\n}\n","import { assign, createMachine, send } from 'xstate'\n\nimport { AuthClient } from '../client'\nimport { ErrorPayload, INVALID_EMAIL_ERROR } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { ChangeEmailOptions, ChangeEmailResponse } from '../types'\nimport { rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../validators'\n\nexport type ChangeEmailContext = {\n  error: ErrorPayload | null\n}\n\nexport type ChangeEmailEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: ChangeEmailOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: ErrorPayload | null }\n\nexport type ChangeEmailServices = {\n  request: { data: ChangeEmailResponse }\n}\n\nexport type ChangeEmailMachine = ReturnType<typeof createChangeEmailMachine>\n\nexport const createChangeEmailMachine = ({ backendUrl, clientUrl, interpreter }: AuthClient) => {\n  const api = nhostApiClient(backendUrl)\n  return createMachine(\n    {\n      schema: {\n        context: {} as ChangeEmailContext,\n        events: {} as ChangeEmailEvents,\n        services: {} as ChangeEmailServices\n      },\n      tsTypes: {} as import('./change-email.typegen').Typegen0,\n      preserveActionOrder: true,\n      id: 'changeEmail',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        // TODO change email in the main machine (context.user.email)\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        requestChange: async (_, { email, options }) => {\n          const res = await api.post(\n            '/user/email/change',\n            {\n              newEmail: email,\n              options: rewriteRedirectTo(clientUrl, options)\n            },\n            {\n              headers: {\n                authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n              }\n            }\n          )\n          return res.data\n        }\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\n\nimport { AuthClient } from '../client'\nimport { ErrorPayload, INVALID_PASSWORD_ERROR } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { ChangePasswordResponse } from '../types'\nimport { isValidPassword } from '../validators'\n\nexport type ChangePasswordContext = {\n  error: ErrorPayload | null\n}\nexport type ChangePasswordEvents =\n  | {\n      type: 'REQUEST'\n      password?: string\n      ticket?: string\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: ErrorPayload | null }\n\nexport type ChangePasswordServices = {\n  requestChange: { data: ChangePasswordResponse }\n}\n\nexport type ChangePasswordMachine = ReturnType<typeof createChangePasswordMachine>\n\nexport const createChangePasswordMachine = ({ backendUrl, interpreter }: AuthClient) => {\n  const api = nhostApiClient(backendUrl)\n  return createMachine(\n    {\n      schema: {\n        context: {} as ChangePasswordContext,\n        events: {} as ChangePasswordEvents,\n        services: {} as ChangePasswordServices\n      },\n      tsTypes: {} as import('./change-password.typegen').Typegen0,\n      preserveActionOrder: true,\n      id: 'changePassword',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidPassword',\n                actions: 'saveInvalidPasswordError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidPasswordError: assign({ error: (_) => INVALID_PASSWORD_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidPassword: (_, { password }) => !isValidPassword(password)\n      },\n      services: {\n        requestChange: (_, { password, ticket }) =>\n          api.post<string, ChangePasswordResponse>(\n            '/user/password',\n            { newPassword: password, ticket: ticket },\n            {\n              headers: {\n                authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n              }\n            }\n          )\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\n\nimport { AuthClient } from '../client'\nimport { ErrorPayload, INVALID_MFA_CODE_ERROR, INVALID_MFA_TYPE_ERROR } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\n\nexport type EnableMfaContext = {\n  error: ErrorPayload | null\n  imageUrl: string | null\n  secret: string | null\n}\n\nexport type EnableMfaEvents =\n  | {\n      type: 'GENERATE'\n    }\n  | {\n      type: 'ACTIVATE'\n      code?: string\n      activeMfaType: 'totp'\n    }\n  | { type: 'GENERATED' }\n  | { type: 'GENERATED_ERROR'; error: ErrorPayload | null }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: ErrorPayload | null }\n\nexport type EnableMfadMachine = ReturnType<typeof createEnableMfaMachine>\n\nexport const createEnableMfaMachine = ({ backendUrl, interpreter }: AuthClient) => {\n  const api = nhostApiClient(backendUrl)\n  return createMachine(\n    {\n      schema: {\n        context: {} as EnableMfaContext,\n        events: {} as EnableMfaEvents\n      },\n      tsTypes: {} as import('./enable-mfa.typegen').Typegen0,\n      preserveActionOrder: true,\n      id: 'enableMfa',\n      initial: 'idle',\n      context: { error: null, imageUrl: null, secret: null },\n      states: {\n        idle: {\n          initial: 'initial',\n          on: {\n            GENERATE: 'generating'\n          },\n          states: {\n            initial: {},\n            error: {}\n          }\n        },\n        generating: {\n          invoke: {\n            src: 'generate',\n            id: 'generate',\n            onDone: { target: 'generated', actions: ['reportGeneratedSuccess', 'saveGeneration'] },\n            onError: { actions: ['saveError', 'reportGeneratedError'], target: 'idle.error' }\n          }\n        },\n        generated: {\n          initial: 'idle',\n          states: {\n            idle: {\n              initial: 'idle',\n              on: {\n                ACTIVATE: [\n                  {\n                    cond: 'invalidMfaType',\n                    actions: 'saveInvalidMfaTypeError',\n                    target: '.error'\n                  },\n                  {\n                    cond: 'invalidMfaCode',\n                    actions: 'saveInvalidMfaCodeError',\n                    target: '.error'\n                  },\n                  {\n                    target: 'activating'\n                  }\n                ]\n              },\n              states: { idle: {}, error: {} }\n            },\n            activating: {\n              invoke: {\n                src: 'activate',\n                id: 'activate',\n                onDone: { target: 'activated', actions: 'reportSuccess' },\n                onError: { actions: ['saveError', 'reportError'], target: 'idle.error' }\n              }\n            },\n            activated: { type: 'final' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidMfaTypeError: assign({ error: (_) => INVALID_MFA_TYPE_ERROR }),\n        saveInvalidMfaCodeError: assign({ error: (_) => INVALID_MFA_CODE_ERROR }),\n        saveError: assign({\n          error: (_, { data: { error } }: any) => error\n        }),\n        saveGeneration: assign({\n          imageUrl: (_, { data: { imageUrl } }: any) => imageUrl,\n          secret: (_, { data: { totpSecret } }: any) => totpSecret\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS'),\n        reportGeneratedSuccess: send('GENERATED'),\n        reportGeneratedError: send((ctx) => ({ type: 'GENERATED_ERROR', error: ctx.error }))\n      },\n      guards: {\n        invalidMfaCode: (_, { code }) => !code,\n        invalidMfaType: (_, { activeMfaType }) => !activeMfaType || activeMfaType !== 'totp'\n      },\n      services: {\n        generate: async (_) => {\n          const { data } = await api.get('/mfa/totp/generate', {\n            headers: {\n              authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n            }\n          })\n          return data\n        },\n        activate: (_, { code, activeMfaType }) =>\n          api.post(\n            '/user/mfa',\n            {\n              code,\n              activeMfaType\n            },\n            {\n              headers: {\n                authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n              }\n            }\n          )\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\n\nimport { AuthClient } from '../client'\nimport { ErrorPayload, INVALID_EMAIL_ERROR } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { ResetPasswordOptions, ResetPasswordResponse } from '../types'\nimport { rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../validators'\n\nexport type ResetPasswordContext = {\n  error: ErrorPayload | null\n}\nexport type ResetPasswordEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: ResetPasswordOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: ErrorPayload | null }\n\nexport type ResetPasswordServices = {\n  requestChange: { data: ResetPasswordResponse }\n}\n\nexport type ResetPasswordMachine = ReturnType<typeof createResetPasswordMachine>\n\nexport const createResetPasswordMachine = ({ backendUrl, clientUrl }: AuthClient) => {\n  const api = nhostApiClient(backendUrl)\n  return createMachine(\n    {\n      schema: {\n        context: {} as ResetPasswordContext,\n        events: {} as ResetPasswordEvents,\n        services: {} as ResetPasswordServices\n      },\n      tsTypes: {} as import('./reset-password.typegen').Typegen0,\n      preserveActionOrder: true,\n      id: 'changePassword',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        requestChange: (_, { email, options }) =>\n          api.post<string, ResetPasswordResponse>('/user/password/reset', {\n            email,\n            options: rewriteRedirectTo(clientUrl, options)\n          })\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\n\nimport { AuthClient } from '../client'\nimport { ErrorPayload, INVALID_EMAIL_ERROR } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { SendVerificationEmailOptions, SendVerificationEmailResponse } from '../types'\nimport { rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../validators'\n\nexport type SendVerificationEmailContext = {\n  error: ErrorPayload | null\n}\n\nexport type SendVerificationEmailEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: SendVerificationEmailOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: ErrorPayload | null }\n\nexport type SendVerificationEmailServices = {\n  request: { data: SendVerificationEmailResponse }\n}\n\nexport type SendVerificationEmailMachine = ReturnType<typeof createSendVerificationEmailMachine>\nexport const createSendVerificationEmailMachine = ({ backendUrl, clientUrl }: AuthClient) => {\n  const api = nhostApiClient(backendUrl)\n  return createMachine(\n    {\n      schema: {\n        context: {} as SendVerificationEmailContext,\n        events: {} as SendVerificationEmailEvents,\n        services: {} as SendVerificationEmailServices\n      },\n      tsTypes: {} as import('./send-verification-email.typegen').Typegen0,\n      preserveActionOrder: true,\n      id: 'sendVerificationEmail',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'request',\n            id: 'request',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        request: async (_, { email, options }) => {\n          const res = await api.post<SendVerificationEmailResponse>(\n            '/user/email/send-verification-email',\n            {\n              email,\n              options: rewriteRedirectTo(clientUrl, options)\n            }\n          )\n          return res.data\n        }\n      }\n    }\n  )\n}\n","import type { AxiosRequestConfig } from 'axios'\nimport { assign, createMachine, send } from 'xstate'\n\nimport { startAuthentication, startRegistration } from '@simplewebauthn/browser'\nimport type {\n  AuthenticationCredentialJSON,\n  PublicKeyCredentialCreationOptionsJSON,\n  PublicKeyCredentialRequestOptionsJSON,\n  RegistrationCredentialJSON\n} from '@simplewebauthn/typescript-types'\n\nimport {\n  NHOST_JWT_EXPIRES_AT_KEY,\n  NHOST_REFRESH_TOKEN_KEY,\n  REFRESH_TOKEN_RETRY_INTERVAL,\n  TOKEN_REFRESH_MARGIN\n} from '../constants'\nimport {\n  CodifiedError,\n  INVALID_EMAIL_ERROR,\n  INVALID_MFA_TICKET_ERROR,\n  INVALID_PASSWORD_ERROR,\n  INVALID_PHONE_NUMBER_ERROR,\n  NO_MFA_TICKET_ERROR,\n  VALIDATION_ERROR_CODE,\n  ValidationErrorPayload\n} from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { localStorageGetter, localStorageSetter } from '../storage'\nimport {\n  AuthOptions,\n  DeanonymizeResponse,\n  NhostSession,\n  NhostSessionResponse,\n  PasswordlessEmailResponse,\n  PasswordlessSmsOtpResponse,\n  PasswordlessSmsResponse,\n  RefreshSessionResponse,\n  SignInAnonymousResponse,\n  SignInMfaTotpResponse,\n  SignInResponse,\n  SignOutResponse,\n  SignUpResponse\n} from '../types'\nimport { getParameterByName, removeParameterFromWindow, rewriteRedirectTo } from '../utils'\nimport { isValidEmail, isValidPassword, isValidPhoneNumber, isValidTicket } from '../validators'\n\nimport { AuthContext, INITIAL_MACHINE_CONTEXT, StateErrorTypes } from './context'\nimport { AuthEvents } from './events'\n\nexport * from './change-email'\nexport * from './change-password'\nexport * from './enable-mfa'\nexport * from './reset-password'\nexport * from './send-verification-email'\n\nexport type { AuthContext, AuthEvents, StateErrorTypes }\n\nexport interface AuthMachineOptions extends AuthOptions {\n  backendUrl: string\n  clientUrl: string\n}\n\nexport type AuthMachine = ReturnType<typeof createAuthMachine>\n\ntype AuthServices = {\n  signInPassword: { data: SignInResponse }\n  passwordlessSms: { data: PasswordlessSmsResponse | DeanonymizeResponse }\n  passwordlessSmsOtp: { data: PasswordlessSmsOtpResponse }\n  passwordlessEmail: { data: PasswordlessEmailResponse | DeanonymizeResponse }\n  signInAnonymous: { data: SignInAnonymousResponse }\n  signInMfaTotp: { data: SignInMfaTotpResponse }\n  signInSecurityKeyEmail: { data: SignInResponse }\n  refreshToken: { data: NhostSessionResponse }\n  signout: { data: SignOutResponse }\n  signUpEmailPassword: { data: SignUpResponse }\n  signUpSecurityKey: { data: SignUpResponse }\n  importRefreshToken: { data: NhostSessionResponse }\n}\n\nexport const createAuthMachine = ({\n  backendUrl,\n  clientUrl,\n  clientStorageGetter,\n  clientStorageSetter,\n  clientStorageType = 'web',\n  clientStorage,\n  refreshIntervalTime,\n  autoRefreshToken = true,\n  autoSignIn = true\n}: AuthMachineOptions) => {\n  const storageGetter = clientStorageGetter || localStorageGetter(clientStorageType, clientStorage)\n  const storageSetter = clientStorageSetter || localStorageSetter(clientStorageType, clientStorage)\n  const api = nhostApiClient(backendUrl)\n  const postRequest = async <T = any, D = any>(\n    url: string,\n    data?: D,\n    config?: AxiosRequestConfig<D>\n  ): Promise<T> => {\n    const result = await api.post(url, data, config)\n\n    return result.data\n  }\n  return createMachine(\n    {\n      schema: {\n        context: {} as AuthContext,\n        events: {} as AuthEvents,\n        services: {} as AuthServices\n      },\n      tsTypes: {} as import('./index.typegen').Typegen0,\n      context: INITIAL_MACHINE_CONTEXT,\n      preserveActionOrder: true,\n      id: 'nhost',\n      type: 'parallel',\n      states: {\n        authentication: {\n          initial: 'starting',\n          on: {\n            SESSION_UPDATE: [\n              {\n                cond: 'hasSession',\n                actions: ['saveSession', 'resetTimer', 'reportTokenChanged'],\n                target: '.signedIn'\n              }\n            ]\n          },\n          states: {\n            starting: {\n              entry: 'resetErrors',\n              tags: ['loading'],\n              always: { cond: 'isSignedIn', target: 'signedIn' },\n              invoke: {\n                id: 'importRefreshToken',\n                src: 'importRefreshToken',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: 'signedIn'\n                },\n                onError: { actions: ['saveAuthenticationError'], target: 'signedOut' }\n              }\n            },\n            signedOut: {\n              initial: 'noErrors',\n              entry: 'reportSignedOut',\n              states: {\n                noErrors: {},\n                success: {},\n                needsSmsOtp: {},\n                needsMfa: {},\n                failed: {},\n                signingOut: {\n                  entry: ['clearContextExceptRefreshToken'],\n                  exit: ['destroyRefreshToken', 'reportTokenChanged'],\n                  invoke: {\n                    src: 'signout',\n                    id: 'signingOut',\n                    onDone: {\n                      target: 'success'\n                    },\n                    onError: {\n                      target: 'failed',\n                      actions: ['saveAuthenticationError']\n                    }\n                  }\n                }\n              },\n              on: {\n                SIGNIN_PASSWORD: 'authenticating.password',\n                SIGNIN_ANONYMOUS: 'authenticating.anonymous',\n                SIGNIN_SECURITY_KEY_EMAIL: 'authenticating.securityKeyEmail',\n                SIGNIN_MFA_TOTP: 'authenticating.mfa.totp'\n              }\n            },\n            authenticating: {\n              entry: 'resetErrors',\n              states: {\n                password: {\n                  invoke: {\n                    src: 'signInPassword',\n                    id: 'authenticateUserWithPassword',\n                    onDone: [\n                      {\n                        cond: 'hasMfaTicket',\n                        actions: ['saveMfaTicket'],\n                        target: '#nhost.authentication.signedOut.needsMfa'\n                      },\n                      {\n                        actions: ['saveSession', 'reportTokenChanged'],\n                        target: '#nhost.authentication.signedIn'\n                      }\n                    ],\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: [\n                          '#nhost.authentication.signedOut',\n                          '#nhost.registration.incomplete.needsEmailVerification'\n                        ]\n                      },\n                      {\n                        actions: 'saveAuthenticationError',\n                        target: '#nhost.authentication.signedOut.failed'\n                      }\n                    ]\n                  }\n                },\n                anonymous: {\n                  invoke: {\n                    src: 'signInAnonymous',\n                    id: 'authenticateAnonymously',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: {\n                      actions: 'saveAuthenticationError',\n                      target: '#nhost.authentication.signedOut.failed'\n                    }\n                  }\n                },\n                mfa: {\n                  states: {\n                    totp: {\n                      invoke: {\n                        src: 'signInMfaTotp',\n                        id: 'signInMfaTotp',\n                        onDone: {\n                          actions: ['saveSession', 'reportTokenChanged'],\n                          target: '#nhost.authentication.signedIn'\n                        },\n                        onError: {\n                          actions: ['saveAuthenticationError'],\n                          target: '#nhost.authentication.signedOut.failed'\n                        }\n                      }\n                    }\n                  }\n                },\n                securityKeyEmail: {\n                  invoke: {\n                    src: 'signInSecurityKeyEmail',\n                    id: 'authenticateUserWithSecurityKey',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: [\n                          '#nhost.authentication.signedOut',\n                          '#nhost.registration.incomplete.needsEmailVerification'\n                        ]\n                      },\n                      {\n                        actions: 'saveAuthenticationError',\n                        target: '#nhost.authentication.signedOut.failed'\n                      }\n                    ]\n                  }\n                }\n              }\n            },\n            signedIn: {\n              type: 'parallel',\n              entry: ['reportSignedIn', 'cleanUrl', 'broadcastToken', 'resetErrors'],\n              on: {\n                SIGNOUT: 'signedOut.signingOut'\n              },\n              states: {\n                refreshTimer: {\n                  id: 'timer',\n                  initial: 'idle',\n                  states: {\n                    disabled: { type: 'final' },\n                    stopped: {\n                      always: {\n                        cond: 'noToken',\n                        target: 'idle'\n                      }\n                    },\n                    idle: {\n                      always: [\n                        { cond: 'isAutoRefreshDisabled', target: 'disabled' },\n                        {\n                          cond: 'hasRefreshToken',\n                          target: 'running'\n                        }\n                      ]\n                    },\n                    running: {\n                      initial: 'pending',\n                      entry: 'resetTimer',\n                      states: {\n                        pending: {\n                          after: {\n                            '1000': {\n                              internal: false,\n                              target: 'pending'\n                            }\n                          },\n                          always: {\n                            cond: 'refreshTimerShouldRefresh',\n                            target: 'refreshing'\n                          }\n                        },\n                        refreshing: {\n                          invoke: {\n                            src: 'refreshToken',\n                            id: 'refreshToken',\n                            onDone: {\n                              actions: ['saveSession', 'resetTimer', 'reportTokenChanged'],\n                              target: 'pending'\n                            },\n                            onError: [\n                              { actions: 'saveRefreshAttempt', target: 'pending' }\n                              // ? stop trying after x attempts?\n                              // {\n                              //   actions: 'retry',\n                              //   cond: 'canRetry',\n                              //   target: 'pending'\n                              // },\n                              // {\n                              //   actions: ['sendError', 'resetToken'],\n                              //   target: '#timer.stopped'\n                              // }\n                            ]\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        },\n        token: {\n          initial: 'idle',\n          states: {\n            idle: {\n              on: {\n                TRY_TOKEN: 'running'\n              },\n              initial: 'noErrors',\n              states: { noErrors: {}, error: {} }\n            },\n            running: {\n              invoke: {\n                src: 'refreshToken',\n                id: 'authenticateWithToken',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: ['#nhost.authentication.signedIn', 'idle.noErrors']\n                },\n                onError: [\n                  { cond: 'isSignedIn', target: 'idle.error' },\n                  {\n                    actions: 'saveAuthenticationError',\n                    target: ['#nhost.authentication.signedOut.failed', 'idle.error']\n                  }\n                ]\n              }\n            }\n          }\n        },\n        registration: {\n          initial: 'incomplete',\n          on: {\n            SIGNED_IN: [{ cond: 'isAnonymous', target: '.incomplete' }, '.complete']\n          },\n          states: {\n            incomplete: {\n              on: {\n                SIGNUP_EMAIL_PASSWORD: 'emailPassword',\n                SIGNUP_SECURITY_KEY: 'securityKey',\n                PASSWORDLESS_EMAIL: 'passwordlessEmail',\n                PASSWORDLESS_SMS: 'passwordlessSms',\n                PASSWORDLESS_SMS_OTP: 'passwordlessSmsOtp'\n              },\n              initial: 'noErrors',\n              states: {\n                noErrors: {},\n                needsEmailVerification: {},\n                needsOtp: {},\n                failed: {}\n              }\n            },\n            emailPassword: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'signUpEmailPassword',\n                id: 'signUpEmailPassword',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: '#nhost.authentication.signedIn'\n                  },\n                  {\n                    actions: 'clearContext',\n                    target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'unverified',\n                    target: 'incomplete.needsEmailVerification'\n                  },\n                  {\n                    actions: 'saveRegistrationError',\n                    target: 'incomplete.failed'\n                  }\n                ]\n              }\n            },\n            securityKey: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'signUpSecurityKey',\n                id: 'signUpSecurityKey',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: '#nhost.authentication.signedIn'\n                  },\n                  {\n                    actions: 'clearContext',\n                    target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'unverified',\n                    target: 'incomplete.needsEmailVerification'\n                  },\n                  {\n                    actions: 'saveRegistrationError',\n                    target: 'incomplete.failed'\n                  }\n                ]\n              }\n            },\n            passwordlessEmail: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessEmail',\n                id: 'passwordlessEmail',\n                onDone: {\n                  actions: 'clearContext',\n                  target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            passwordlessSms: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessSms',\n                id: 'passwordlessSms',\n                onDone: {\n                  actions: 'clearContext',\n                  target: ['#nhost.authentication.signedOut', 'incomplete.needsOtp']\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            passwordlessSmsOtp: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessSmsOtp',\n                id: 'passwordlessSmsOtp',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: '#nhost.authentication.signedIn'\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n\n            complete: {\n              on: {\n                SIGNED_OUT: 'incomplete'\n              }\n            }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        reportSignedIn: send('SIGNED_IN'),\n        reportSignedOut: send('SIGNED_OUT'),\n        reportTokenChanged: send('TOKEN_CHANGED'),\n        clearContext: assign(() => {\n          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n          storageSetter(NHOST_REFRESH_TOKEN_KEY, null)\n          return {\n            ...INITIAL_MACHINE_CONTEXT\n          }\n        }),\n        clearContextExceptRefreshToken: assign(({ refreshToken: { value } }) => {\n          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n          return {\n            ...INITIAL_MACHINE_CONTEXT,\n            refreshToken: { value }\n          }\n        }),\n\n        // * Save session in the context, and persist the refresh token and the jwt expiration outside of the machine\n        saveSession: assign({\n          user: (_, { data }) => data?.session?.user || null,\n          accessToken: (_, { data }) => {\n            if (data.session) {\n              const { accessTokenExpiresIn, accessToken } = data.session\n              const nextRefresh = new Date(Date.now() + accessTokenExpiresIn * 1_000)\n              storageSetter(NHOST_JWT_EXPIRES_AT_KEY, nextRefresh.toISOString())\n              return {\n                value: accessToken,\n                expiresAt: nextRefresh\n              }\n            }\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n            return {\n              value: null,\n              expiresAt: null\n            }\n          },\n          refreshToken: (_, { data }) => {\n            const refreshToken = data.session?.refreshToken || null\n            if (refreshToken) {\n              storageSetter(NHOST_REFRESH_TOKEN_KEY, refreshToken)\n            }\n            return { value: refreshToken }\n          }\n        }),\n        saveMfaTicket: assign({\n          mfa: (_, e) => e.data?.mfa\n        }),\n\n        resetTimer: assign({\n          refreshTimer: (_) => ({\n            startedAt: new Date(),\n            attempts: 0,\n            lastAttempt: null\n          })\n        }),\n\n        saveRefreshAttempt: assign({\n          refreshTimer: (ctx, e) => ({\n            startedAt: ctx.refreshTimer.startedAt,\n            attempts: ctx.refreshTimer.attempts + 1,\n            lastAttempt: new Date()\n          })\n        }),\n\n        // * Authentication errors\n        saveAuthenticationError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          errors: ({ errors }, { data: { error } }: any) => ({\n            ...errors,\n            authentication: error\n          })\n        }),\n        resetErrors: assign({\n          errors: (_) => ({})\n        }),\n        saveRegistrationError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          errors: ({ errors }, { data: { error } }: any) => ({ ...errors, registration: error })\n        }),\n        destroyRefreshToken: assign({\n          refreshToken: (_) => {\n            storageSetter(NHOST_REFRESH_TOKEN_KEY, null)\n            return { value: null }\n          }\n        }),\n\n        // * Clean the browser url when `autoSignIn` is activated\n        cleanUrl: () => {\n          if (autoSignIn && getParameterByName('refreshToken')) {\n            // * Remove the refresh token from the URL\n            removeParameterFromWindow('refreshToken')\n            removeParameterFromWindow('type')\n          }\n        },\n\n        // * Broadcast the token to other tabs when `autoSignIn` is activated\n        broadcastToken: (context) => {\n          if (autoSignIn) {\n            try {\n              const channel = new BroadcastChannel('nhost')\n              // ? broadcat session instead of token ?\n              channel.postMessage(context.refreshToken.value)\n            } catch (error) {\n              // * BroadcastChannel is not available e.g. react-native\n            }\n          }\n        }\n      },\n\n      guards: {\n        isAnonymous: (ctx, e) => !!ctx.user?.isAnonymous,\n        isSignedIn: (ctx) => !!ctx.user && !!ctx.refreshToken.value && !!ctx.accessToken.value,\n        noToken: (ctx) => !ctx.refreshToken.value,\n        hasRefreshToken: (ctx) => !!ctx.refreshToken.value,\n        isAutoRefreshDisabled: () => !autoRefreshToken,\n        refreshTimerShouldRefresh: (ctx) => {\n          const { expiresAt } = ctx.accessToken\n          if (!expiresAt) {\n            return false\n          }\n          if (ctx.refreshTimer.lastAttempt) {\n            // * If a refesh previously failed, only try to refresh every `REFRESH_TOKEN_RETRY_INTERVAL` seconds\n            const elapsed = Date.now() - ctx.refreshTimer.lastAttempt.getTime()\n            return elapsed > REFRESH_TOKEN_RETRY_INTERVAL * 1_000\n          }\n          if (refreshIntervalTime) {\n            // * If a refreshIntervalTime has been passed on as an option, it will notify\n            // * the token should be refershed when this interval is overdue\n            const elapsed = Date.now() - ctx.refreshTimer.startedAt!.getTime()\n            if (elapsed > refreshIntervalTime * 1_000) {\n              return true\n            }\n          }\n          // * In any case, it's time to refresh when there's less than\n          // * TOKEN_REFRESH_MARGIN seconds before the JWT exprires\n          const expiresIn = expiresAt.getTime() - Date.now()\n          const remaining = expiresIn - 1_000 * TOKEN_REFRESH_MARGIN\n          return remaining <= 0\n        },\n        // * Authentication errors\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        unverified: (_, { data: { error } }: any) =>\n          error.status === 401 &&\n          // * legacy: don't use the message contents to determine if the email is unverified, but the error type (error.error)\n          (error.message === 'Email is not verified' || error.error === 'unverified-user'),\n\n        // * Event guards\n        hasSession: (_, e) => !!e.data?.session,\n        hasMfaTicket: (_, e) => !!e.data?.mfa\n      },\n\n      services: {\n        signInPassword: (_, { email, password }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n          if (!isValidPassword(password)) {\n            return Promise.reject({ error: INVALID_PASSWORD_ERROR })\n          }\n          return postRequest<SignInResponse>('/signin/email-password', {\n            email,\n            password\n          })\n        },\n        passwordlessSms: (context, { phoneNumber, options }) => {\n          if (!isValidPhoneNumber(phoneNumber)) {\n            return Promise.reject({ error: INVALID_PHONE_NUMBER_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            // TODO implement in hasura-auth\n            // * See https://github.com/nhost/hasura-auth/blob/9c6d0f4ded4fc8fd1b8031926c02796c74a7eada/src/routes/user/deanonymize.ts\n            console.warn(\n              'Deanonymisation from a phone number is not yet implemented in hasura-auth'\n            )\n            return postRequest(\n              '/user/deanonymize',\n              {\n                signInMethod: 'passwordless',\n                connection: 'sms',\n                phoneNumber,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              {\n                headers: {\n                  authorization: `Bearer ${context.accessToken.value}`\n                }\n              }\n            )\n          } else {\n            return postRequest('/signin/passwordless/sms', {\n              phoneNumber,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        passwordlessSmsOtp: (_, { phoneNumber, otp }) => {\n          if (!isValidPhoneNumber(phoneNumber)) {\n            return Promise.reject({ error: INVALID_PHONE_NUMBER_ERROR })\n          }\n          return postRequest('/signin/passwordless/sms/otp', {\n            phoneNumber,\n            otp\n          })\n        },\n        passwordlessEmail: (context, { email, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            return postRequest(\n              '/user/deanonymize',\n              {\n                signInMethod: 'passwordless',\n                connection: 'email',\n                email,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              {\n                headers: {\n                  authorization: `Bearer ${context.accessToken.value}`\n                }\n              }\n            )\n          } else {\n            return postRequest('/signin/passwordless/email', {\n              email,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        signInAnonymous: (_) => postRequest('/signin/anonymous'),\n        signInMfaTotp: (context, data) => {\n          const ticket: string | undefined = data.ticket || context.mfa?.ticket\n          if (!ticket) {\n            return Promise.reject({ error: NO_MFA_TICKET_ERROR })\n          }\n          if (!isValidTicket(ticket)) {\n            return Promise.reject({ error: INVALID_MFA_TICKET_ERROR })\n          }\n\n          return postRequest('/signin/mfa/totp', {\n            ticket,\n            otp: data.otp\n          })\n        },\n        signInSecurityKeyEmail: async (_, { email }) => {\n          if (!isValidEmail(email)) {\n            throw new CodifiedError(INVALID_EMAIL_ERROR)\n          }\n          const options = await postRequest<PublicKeyCredentialRequestOptionsJSON>(\n            '/signin/webauthn',\n            { email }\n          )\n          let credential: AuthenticationCredentialJSON\n          try {\n            credential = await startAuthentication(options)\n          } catch (e) {\n            throw new CodifiedError(e as Error)\n          }\n          return postRequest<SignInResponse>('/signin/webauthn/verify', { email, credential })\n        },\n        refreshToken: async (ctx, event) => {\n          const refreshToken = event.type === 'TRY_TOKEN' ? event.token : ctx.refreshToken.value\n          const session = await postRequest<RefreshSessionResponse>('/token', {\n            refreshToken\n          })\n          return { session, error: null }\n        },\n        signout: (ctx, e) =>\n          postRequest('/signout', {\n            refreshToken: ctx.refreshToken.value,\n            all: !!e.all\n          }),\n        signUpEmailPassword: async (context, { email, password, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_EMAIL_ERROR })\n          }\n          if (!isValidPassword(password)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_PASSWORD_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            return postRequest<SignUpResponse>(\n              '/user/deanonymize',\n              {\n                signInMethod: 'email-password',\n                email,\n                password,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              {\n                headers: {\n                  authorization: `Bearer ${context.accessToken.value}`\n                }\n              }\n            )\n          } else {\n            return postRequest<SignUpResponse>('/signup/email-password', {\n              email,\n              password,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        signUpSecurityKey: async (_, { email, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_EMAIL_ERROR })\n          }\n          // TODO anonymous users\n          const nickname = options?.nickname\n          /*\n           * The `/signup/webauthn` endpoint accepts any option from SignUpOptions,\n           * We therefore remove the nickname from the options object before sending it to the server,\n           * as options if of type `SignUpSecurityKeyOptions`, which extends `SignUpOptions` with the optional `nickname` property.\n           */\n          if (nickname) delete options.nickname\n          const webAuthnOptions = await postRequest<PublicKeyCredentialCreationOptionsJSON>(\n            '/signup/webauthn',\n            { email, options }\n          )\n          let credential: RegistrationCredentialJSON\n          try {\n            credential = await startRegistration(webAuthnOptions)\n          } catch (e) {\n            throw new CodifiedError(e as Error)\n          }\n          return postRequest<SignUpResponse>('/signup/webauthn/verify', {\n            credential,\n            options: {\n              redirectTo: options?.redirectTo,\n              nickname\n            }\n          })\n        },\n        importRefreshToken: async () => {\n          let error: ValidationErrorPayload | null = null\n          if (autoSignIn) {\n            const urlToken = getParameterByName('refreshToken') || null\n            if (urlToken) {\n              try {\n                const session = await postRequest<NhostSession>('/token', {\n                  refreshToken: urlToken\n                })\n                return { session, error: null }\n              } catch (exception) {\n                error = (exception as { error: ValidationErrorPayload }).error\n              }\n            } else {\n              const error = getParameterByName('error')\n              if (error) {\n                return Promise.reject<NhostSessionResponse>({\n                  session: null,\n                  error: {\n                    status: VALIDATION_ERROR_CODE,\n                    error,\n                    message: getParameterByName('errorDescription') || error\n                  }\n                })\n              }\n            }\n          }\n          const storageToken = await storageGetter(NHOST_REFRESH_TOKEN_KEY)\n          if (storageToken) {\n            try {\n              const session = await postRequest<NhostSession>('/token', {\n                refreshToken: storageToken\n              })\n              return { session, error: null }\n            } catch (exception) {\n              error = (exception as { error: ValidationErrorPayload }).error\n            }\n          }\n          return Promise.reject<NhostSessionResponse>({ error })\n        }\n      }\n    }\n  )\n}\n","import { interpret } from 'xstate'\n\nimport { AuthMachine, AuthMachineOptions, createAuthMachine } from './machines'\nimport type { AuthInterpreter } from './types'\n\nexport type NhostClientOptions = AuthMachineOptions & {\n  /** @internal create and start xstate interpreter on creation. With React, it is started inside the Nhost provider */\n  start?: boolean\n}\n\n/**\n * @internal\n * This is a private API.\n */\nexport class AuthClient {\n  readonly backendUrl: string\n  readonly clientUrl: string\n  readonly machine: AuthMachine\n  private _interpreter?: AuthInterpreter\n  private _channel?: BroadcastChannel\n  private _subscriptions: Set<(client: AuthClient) => void> = new Set()\n\n  constructor({\n    clientStorageType = 'web',\n    autoSignIn = true,\n    autoRefreshToken = true,\n    start = true,\n    backendUrl,\n    clientUrl,\n    devTools,\n    ...defaultOptions\n  }: NhostClientOptions) {\n    this.backendUrl = backendUrl\n    this.clientUrl = clientUrl\n\n    this.machine = createAuthMachine({\n      ...defaultOptions,\n      backendUrl,\n      clientUrl,\n      clientStorageType,\n      autoSignIn,\n      autoRefreshToken\n    })\n\n    if (start) {\n      this.interpreter = interpret(this.machine, { devTools })\n      this.interpreter.start()\n    }\n\n    if (typeof window !== 'undefined' && autoSignIn) {\n      try {\n        // TODO listen to sign out\n        // TODO the same refresh token is used and refreshed by all tabs\n        // * Ideally, a single tab should autorefresh and share the new jwt\n        this._channel = new BroadcastChannel('nhost')\n        this._channel.addEventListener('message', (token) => {\n          const existingToken = this.interpreter?.state.context.refreshToken.value\n          if (this.interpreter && token.data !== existingToken) {\n            this.interpreter.send('TRY_TOKEN', { token: token.data })\n          }\n        })\n      } catch (error) {\n        // * BroadcastChannel is not available e.g. react-native\n      }\n    }\n  }\n\n  get interpreter(): AuthInterpreter | undefined {\n    return this._interpreter\n  }\n  set interpreter(interpreter: AuthInterpreter | undefined) {\n    this._interpreter = interpreter\n    if (interpreter) {\n      this._subscriptions.forEach((fn) => fn(this))\n    }\n  }\n\n  onStart(fn: (client: AuthClient) => void) {\n    if (this.interpreter) {\n      // * The interpreter is already available: we can add the listener straight ahead\n      fn(this)\n    } else {\n      // * The interpreter is not yet available: we add the listener to a queue that will be started when setting the interpreter\n      // * Note: in React, the Xstate interpreter does not start from the global state, but from the root component\n      this._subscriptions.add(fn)\n    }\n  }\n}\n","import { AuthClient, NhostClientOptions } from './client'\nconst isBrowser = typeof window !== 'undefined'\n\n/** @deprecated Not in use anymore. Use `clientStorageType: 'cookie'` instead */\nexport class AuthCookieClient extends AuthClient {\n  constructor({\n    ...options\n  }: Omit<\n    NhostClientOptions,\n    'clientStorageGetter' | 'clientStorageSetter' | 'clientStorage' | 'clientStorageType'\n  >) {\n    super({\n      ...options,\n      autoSignIn: isBrowser && options.autoSignIn,\n      autoRefreshToken: isBrowser && options.autoRefreshToken,\n      clientStorageType: 'cookie'\n    })\n  }\n}\n\n/** @deprecated Alias for {@link AuthCookieClient} */\nexport const AuthClientSSR = AuthCookieClient\n","import { startRegistration } from '@simplewebauthn/browser'\nimport {\n  PublicKeyCredentialCreationOptionsJSON,\n  RegistrationCredentialJSON\n} from '@simplewebauthn/typescript-types'\n\nimport { AuthClient } from '../client'\nimport { CodifiedError, ErrorPayload } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { SecurityKey } from '../types'\n\nimport { ActionErrorState, ActionLoadingState, ActionSuccessState } from './types'\nexport interface AddSecurityKeyHandlerResult extends ActionErrorState, ActionSuccessState {\n  key?: SecurityKey\n}\n\nexport interface AddSecurityKeyState extends AddSecurityKeyHandlerResult, ActionLoadingState {}\n\nexport const addSecurityKeyPromise = async (\n  { backendUrl, interpreter }: AuthClient,\n  nickname?: string\n): Promise<AddSecurityKeyHandlerResult> => {\n  const api = nhostApiClient(backendUrl)\n  try {\n    const { data: options } = await api.post<PublicKeyCredentialCreationOptionsJSON>(\n      '/user/webauthn/add',\n      {},\n      {\n        headers: {\n          authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n        }\n      }\n    )\n    let credential: RegistrationCredentialJSON\n    try {\n      credential = await startRegistration(options)\n    } catch (e) {\n      throw new CodifiedError(e as Error)\n    }\n    const { data: key } = await api.post<SecurityKey>(\n      '/user/webauthn/verify',\n      { credential, nickname },\n      {\n        headers: {\n          authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n        }\n      }\n    )\n    return { key, isError: false, error: null, isSuccess: true }\n  } catch (e) {\n    const { error } = e as { error: ErrorPayload }\n    return { isError: true, error, isSuccess: false }\n  }\n}\n","import { InterpreterFrom } from 'xstate'\n\nimport { ChangeEmailMachine } from '../machines'\nimport { ChangeEmailOptions } from '../types'\n\nimport { ActionErrorState, ActionLoadingState, NeedsEmailVerificationState } from './types'\nexport interface ChangeEmailHandlerResult extends ActionErrorState, NeedsEmailVerificationState {}\n\nexport interface ChangeEmailState extends ChangeEmailHandlerResult, ActionLoadingState {}\n\nexport const changeEmailPromise = async (\n  interpreter: InterpreterFrom<ChangeEmailMachine>,\n  email: string,\n  options?: ChangeEmailOptions\n): Promise<ChangeEmailHandlerResult> =>\n  new Promise<ChangeEmailHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((s) => {\n      if (s.matches({ idle: 'error' })) {\n        resolve({ error: s.context.error, isError: true, needsEmailVerification: false })\n      } else if (s.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, needsEmailVerification: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { ChangePasswordMachine } from '../machines'\n\nimport { ActionErrorState, ActionLoadingState, ActionSuccessState } from './types'\n\nexport interface ChangePasswordState extends ChangePasswordHandlerResult, ActionLoadingState {}\n\nexport interface ChangePasswordHandlerResult extends ActionErrorState, ActionSuccessState {}\n\nexport const changePasswordPromise = async (\n  interpreter: InterpreterFrom<ChangePasswordMachine>,\n  password: string,\n  ticket?: string\n): Promise<ChangePasswordHandlerResult> =>\n  new Promise<ChangePasswordHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      password, ticket\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSuccess: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSuccess: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { EnableMfadMachine } from '../machines'\n\nimport { ActionErrorState } from './types'\n\nexport interface GenerateQrCodeHandlerResult extends ActionErrorState {\n  qrCodeDataUrl: string\n  isGenerated: boolean\n}\n\nexport interface GenerateQrCodeState extends GenerateQrCodeHandlerResult {\n  isGenerating: boolean\n}\nexport interface ActivateMfaHandlerResult extends ActionErrorState {\n  isActivated: boolean\n}\n\nexport interface ActivateMfaState extends ActivateMfaHandlerResult {\n  isActivating: boolean\n}\n\nexport const generateQrCodePromise = (service: InterpreterFrom<EnableMfadMachine>) =>\n  new Promise<GenerateQrCodeHandlerResult>((resolve) => {\n    service.send('GENERATE')\n    service.onTransition((state) => {\n      if (state.matches('generated')) {\n        resolve({\n          error: null,\n          isError: false,\n          isGenerated: true,\n          qrCodeDataUrl: state.context.imageUrl || ''\n        })\n      } else if (state.matches({ idle: 'error' })) {\n        resolve({\n          error: state.context.error || null,\n          isError: true,\n          isGenerated: false,\n          qrCodeDataUrl: ''\n        })\n      }\n    })\n  })\nexport const activateMfaPromise = (service: InterpreterFrom<EnableMfadMachine>, code: string) =>\n  new Promise<ActivateMfaHandlerResult>((resolve) => {\n    service.send('ACTIVATE', {\n      activeMfaType: 'totp',\n      code\n    })\n    service.onTransition((state) => {\n      if (state.matches({ generated: 'activated' })) {\n        resolve({ error: null, isActivated: true, isError: false })\n      } else if (state.matches({ generated: { idle: 'error' } })) {\n        resolve({ error: state.context.error, isActivated: false, isError: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { ResetPasswordMachine } from '../machines'\nimport { ResetPasswordOptions } from '../types'\n\nimport { ActionErrorState, ActionLoadingState } from './types'\n\nexport interface ResetPasswordHandlerResult extends ActionErrorState {\n  /** Returns `true` when an email to reset the password has been sent */\n  isSent: boolean\n}\n\nexport interface ResetPasswordState extends ResetPasswordHandlerResult, ActionLoadingState {}\n\nexport const resetPasswordPromise = async (\n  interpreter: InterpreterFrom<ResetPasswordMachine>,\n  email: string,\n  options?: ResetPasswordOptions\n): Promise<ResetPasswordHandlerResult> =>\n  new Promise((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSent: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSent: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { SendVerificationEmailMachine } from '../machines'\nimport { SendVerificationEmailOptions } from '../types'\n\nimport { ActionErrorState, ActionLoadingState } from './types'\n\nexport interface SendVerificationEmailHandlerResult extends ActionErrorState {\n  /** Returns `true` when a new verification email has been sent */\n  isSent: boolean\n}\n\nexport interface SendVerificationEmailState\n  extends ActionLoadingState,\n    SendVerificationEmailHandlerResult {}\n\nexport const sendVerificationEmailPromise = (\n  interpreter: InterpreterFrom<SendVerificationEmailMachine>,\n  email: string,\n  options?: SendVerificationEmailOptions\n): Promise<SendVerificationEmailHandlerResult> =>\n  new Promise<SendVerificationEmailHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSent: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSent: true })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../types'\n\nimport { ActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInAnonymousHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInAnonymousState extends SignInAnonymousHandlerResult, ActionLoadingState {}\n\nexport const signInAnonymousPromise = (\n  interpreter: AuthInterpreter\n): Promise<SignInAnonymousHandlerResult> =>\n  new Promise((resolve) => {\n    const { changed } = interpreter.send('SIGNIN_ANONYMOUS')\n    if (!changed) {\n      resolve({\n        isSuccess: false,\n        isError: true,\n        error: USER_ALREADY_SIGNED_IN,\n        user: null,\n        accessToken: null\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          isSuccess: true,\n          isError: false,\n          error: null,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value\n        })\n      }\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          isSuccess: false,\n          isError: true,\n          error: state.context.errors.authentication || null,\n          user: null,\n          accessToken: null\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../types'\n\nimport {\n  ActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInEmailPasswordHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {\n  needsMfaOtp: boolean\n  mfa: {\n    ticket: string\n  } | null\n}\n\nexport interface SignInEmailPasswordState\n  extends SignInEmailPasswordHandlerResult,\n    ActionLoadingState {}\n\nexport const signInEmailPasswordPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  password: string\n) =>\n  new Promise<SignInEmailPasswordHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNIN_PASSWORD', {\n      email,\n      password\n    })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        needsMfaOtp: false,\n        mfa: null,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'needsMfa' } })) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: true,\n          mfa: state.context.mfa,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter, PasswordlessOptions } from '../types'\n\nimport { ActionErrorState, ActionLoadingState, ActionSuccessState } from './types'\nexport interface SignInEmailPasswordlessHandlerResult\n  extends ActionErrorState,\n    ActionSuccessState {}\nexport interface SignInEmailPasswordlessState\n  extends SignInEmailPasswordlessHandlerResult,\n    ActionLoadingState {}\n\nexport const signInEmailPasswordlessPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  options?: PasswordlessOptions\n) =>\n  new Promise<SignInEmailPasswordlessHandlerResult>((resolve) => {\n    const { changed } = interpreter.send('PASSWORDLESS_EMAIL', {\n      email,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({ error: null, isError: false, isSuccess: true })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../types'\n\nimport {\n  ActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInSecurityKeyPasswordlessHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignInSecurityKeyPasswordlessState\n  extends SignInSecurityKeyPasswordlessHandlerResult,\n    ActionLoadingState {}\n\nexport const signInEmailSecurityKeyPromise = (interpreter: AuthInterpreter, email: string) =>\n  new Promise<SignInSecurityKeyPasswordlessHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send({ type: 'SIGNIN_SECURITY_KEY_EMAIL', email })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../types'\n\nimport { ActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInMfaTotpHandlerResult extends SessionActionHandlerResult {}\n\nexport interface SignInMfaTotpState extends SignInMfaTotpHandlerResult, ActionLoadingState {}\n\nexport const signInMfaTotpPromise = (interpreter: AuthInterpreter, otp: string, ticket?: string) =>\n  new Promise<SignInMfaTotpHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNIN_MFA_TOTP', {\n      otp,\n      ticket\n    })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter, PasswordlessOptions } from '../types'\n\nimport { ActionErrorState, ActionLoadingState, ActionSuccessState } from './types'\n\nexport interface SignInSmsPasswordlessState\n  extends SignInSmsPasswordlessHandlerResult,\n    ActionLoadingState {}\n\nexport interface SignInSmsPasswordlessHandlerResult extends ActionErrorState, ActionSuccessState {\n  /**\n   * Returns true when the one-time password has been sent over by SMS, and the user needs to send it back to complete sign-in.\n   */\n  needsOtp: boolean\n}\n\nexport const signInSmsPasswordlessPromise = (\n  interpreter: AuthInterpreter,\n  phoneNumber: string,\n  options?: PasswordlessOptions\n) =>\n  new Promise<SignInSmsPasswordlessHandlerResult>((resolve) => {\n    const { changed } = interpreter.send('PASSWORDLESS_SMS', { phoneNumber, options })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsOtp: false\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.needsOtp')) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsOtp: true\n        })\n      } else if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsOtp: false\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../types'\n\nimport { ActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInSmsPasswordlessOtpHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInSmsPasswordlessOtpState\n  extends SignInSmsPasswordlessOtpHandlerResult,\n    ActionLoadingState {}\n\nexport const signInSmsPasswordlessOtpPromise = (\n  interpreter: AuthInterpreter,\n  phoneNumber: string,\n  otp: string\n) =>\n  new Promise<SignInSmsPasswordlessOtpHandlerResult>((resolve) => {\n    const { changed } = interpreter.send({ type: 'PASSWORDLESS_SMS_OTP', phoneNumber, otp })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: null,\n        accessToken: null\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value\n        })\n      } else if (state.matches({ registration: { incomplete: 'failed' } })) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null,\n          accessToken: null\n        })\n      }\n    })\n  })\n","import { USER_UNAUTHENTICATED } from '../errors'\nimport { AuthInterpreter } from '../types'\n\nimport { ActionErrorState, ActionLoadingState, ActionSuccessState } from './types'\n\nexport interface SignOutlessHandlerResult extends ActionErrorState, ActionSuccessState {}\nexport interface SignOutlessState extends SignOutlessHandlerResult, ActionLoadingState {}\n\nexport const signOutPromise = async (\n  interpreter: AuthInterpreter,\n  all?: boolean\n): Promise<SignOutlessHandlerResult> =>\n  new Promise<SignOutlessHandlerResult>((resolve) => {\n    const { event } = interpreter.send('SIGNOUT', { all })\n    if (event.type !== 'SIGNED_OUT') {\n      return resolve({ isSuccess: false, isError: true, error: USER_UNAUTHENTICATED })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'success' } })) {\n        resolve({ isSuccess: true, isError: false, error: null })\n      } else if (state.matches('authentication.signedOut.failed')) {\n        resolve({ isSuccess: false, isError: true, error: state.context.errors.signout || null })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter, SignUpOptions } from '../types'\n\nimport {\n  ActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignUpEmailPasswordHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignUpEmailPasswordState\n  extends SignUpEmailPasswordHandlerResult,\n    ActionLoadingState {}\n\nexport const signUpEmailPasswordPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  password: string,\n  options?: SignUpOptions\n): Promise<SignUpEmailPasswordHandlerResult> =>\n  new Promise<SignUpEmailPasswordHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNUP_EMAIL_PASSWORD', {\n      email,\n      password,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn', registration: 'complete' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter, SignUpSecurityKeyOptions } from '../types'\n\nimport {\n  ActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignUpSecurityKeyHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignUpSecurityKeyState\n  extends SignUpSecurityKeyHandlerResult,\n    ActionLoadingState {}\n\nexport const signUpEmailSecurityKeyPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  options?: SignUpSecurityKeyOptions\n): Promise<SignUpSecurityKeyHandlerResult> =>\n  new Promise<SignUpSecurityKeyHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNUP_SECURITY_KEY', {\n      email,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn', registration: 'complete' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n"]},"metadata":{},"sourceType":"module"}