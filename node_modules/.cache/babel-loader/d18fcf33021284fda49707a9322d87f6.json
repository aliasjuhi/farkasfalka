{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n};\nimport { createMachine, assign, send, interpret } from \"xstate\";\nimport axios from \"axios\";\nimport Cookies from \"js-cookie\";\nfunction utf8StringToBuffer(value) {\n  return new TextEncoder().encode(value);\n}\nfunction bufferToBase64URLString(buffer) {\n  const bytes = new Uint8Array(buffer);\n  let str = \"\";\n  for (const charCode of bytes) {\n    str += String.fromCharCode(charCode);\n  }\n  const base64String = btoa(str);\n  return base64String.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\nfunction base64URLStringToBuffer(base64URLString) {\n  const base64 = base64URLString.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const padLength = (4 - base64.length % 4) % 4;\n  const padded = base64.padEnd(base64.length + padLength, \"=\");\n  const binary = atob(padded);\n  const buffer = new ArrayBuffer(binary.length);\n  const bytes = new Uint8Array(buffer);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return buffer;\n}\nfunction browserSupportsWebAuthn() {\n  return (window === null || window === void 0 ? void 0 : window.PublicKeyCredential) !== void 0 && typeof window.PublicKeyCredential === \"function\";\n}\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n  const {\n    id\n  } = descriptor;\n  return __spreadProps(__spreadValues({}, descriptor), {\n    id: base64URLStringToBuffer(id),\n    transports: descriptor.transports\n  });\n}\nfunction isValidDomain(hostname) {\n  return hostname === \"localhost\" || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname);\n}\nclass WebAuthnError extends Error {\n  constructor(message) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"WebAuthnError\";\n    super(message);\n    this.name = name;\n  }\n}\nfunction identifyRegistrationError(_ref) {\n  let {\n    error,\n    options\n  } = _ref;\n  var _a, _b;\n  const {\n    publicKey\n  } = options;\n  if (!publicKey) {\n    throw Error(\"options was missing required publicKey property\");\n  }\n  if (error.name === \"AbortError\") {\n    if (options.signal === new AbortController().signal) {\n      return new WebAuthnError(\"Registration ceremony was sent an abort signal\", \"AbortError\");\n    }\n  } else if (error.name === \"ConstraintError\") {\n    if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {\n      return new WebAuthnError(\"Discoverable credentials were required but no available authenticator supported it\", \"ConstraintError\");\n    } else if (((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === \"required\") {\n      return new WebAuthnError(\"User verification was required but no available authenticator supported it\", \"ConstraintError\");\n    }\n  } else if (error.name === \"InvalidStateError\") {\n    return new WebAuthnError(\"The authenticator was previously registered\", \"InvalidStateError\");\n  } else if (error.name === \"NotAllowedError\") {\n    return new WebAuthnError(\"User clicked cancel, or the registration ceremony timed out\", \"NotAllowedError\");\n  } else if (error.name === \"NotSupportedError\") {\n    const validPubKeyCredParams = publicKey.pubKeyCredParams.filter(param => param.type === \"public-key\");\n    if (validPubKeyCredParams.length === 0) {\n      return new WebAuthnError('No entry in pubKeyCredParams was of type \"public-key\"', \"NotSupportedError\");\n    }\n    return new WebAuthnError(\"No available authenticator supported any of the specified pubKeyCredParams algorithms\", \"NotSupportedError\");\n  } else if (error.name === \"SecurityError\") {\n    const effectiveDomain = window.location.hostname;\n    if (!isValidDomain(effectiveDomain)) {\n      return new WebAuthnError(`${window.location.hostname} is an invalid domain`, \"SecurityError\");\n    } else if (publicKey.rp.id !== effectiveDomain) {\n      return new WebAuthnError(`The RP ID \"${publicKey.rp.id}\" is invalid for this domain`, \"SecurityError\");\n    }\n  } else if (error.name === \"TypeError\") {\n    if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n      return new WebAuthnError(\"User ID was not between 1 and 64 characters\", \"TypeError\");\n    }\n  } else if (error.name === \"UnknownError\") {\n    return new WebAuthnError(\"The authenticator was unable to process the specified options, or could not create a new credential\", \"UnknownError\");\n  }\n  return error;\n}\nclass WebAuthnAbortService {\n  createNewAbortSignal() {\n    if (this.controller) {\n      this.controller.abort();\n    }\n    this.controller = new AbortController();\n    return this.controller.signal;\n  }\n  reset() {\n    this.controller = void 0;\n  }\n}\nconst webauthnAbortService = new WebAuthnAbortService();\nasync function startRegistration(creationOptionsJSON) {\n  if (!browserSupportsWebAuthn()) {\n    throw new Error(\"WebAuthn is not supported in this browser\");\n  }\n  const publicKey = __spreadProps(__spreadValues({}, creationOptionsJSON), {\n    challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n    user: __spreadProps(__spreadValues({}, creationOptionsJSON.user), {\n      id: utf8StringToBuffer(creationOptionsJSON.user.id)\n    }),\n    excludeCredentials: creationOptionsJSON.excludeCredentials.map(toPublicKeyCredentialDescriptor)\n  });\n  const options = {\n    publicKey\n  };\n  options.signal = webauthnAbortService.createNewAbortSignal();\n  let credential;\n  try {\n    credential = await navigator.credentials.create(options);\n  } catch (err) {\n    throw identifyRegistrationError({\n      error: err,\n      options\n    });\n  } finally {\n    webauthnAbortService.reset();\n  }\n  if (!credential) {\n    throw new Error(\"Registration was not completed\");\n  }\n  const {\n    id,\n    rawId,\n    response,\n    type\n  } = credential;\n  const credentialJSON = {\n    id,\n    rawId: bufferToBase64URLString(rawId),\n    response: {\n      attestationObject: bufferToBase64URLString(response.attestationObject),\n      clientDataJSON: bufferToBase64URLString(response.clientDataJSON)\n    },\n    type,\n    clientExtensionResults: credential.getClientExtensionResults(),\n    authenticatorAttachment: credential.authenticatorAttachment\n  };\n  if (typeof response.getTransports === \"function\") {\n    credentialJSON.transports = response.getTransports();\n  }\n  return credentialJSON;\n}\nfunction bufferToUTF8String(value) {\n  return new TextDecoder(\"utf-8\").decode(value);\n}\nasync function browserSupportsWebAuthnAutofill() {\n  if (navigator.credentials.conditionalMediationSupported) {\n    return true;\n  }\n  const globalPublicKeyCredential = window.PublicKeyCredential;\n  return globalPublicKeyCredential.isConditionalMediationAvailable !== void 0 && globalPublicKeyCredential.isConditionalMediationAvailable();\n}\nfunction identifyAuthenticationError(_ref2) {\n  let {\n    error,\n    options\n  } = _ref2;\n  var _a;\n  const {\n    publicKey\n  } = options;\n  if (!publicKey) {\n    throw Error(\"options was missing required publicKey property\");\n  }\n  if (error.name === \"AbortError\") {\n    if (options.signal === new AbortController().signal) {\n      return new WebAuthnError(\"Authentication ceremony was sent an abort signal\", \"AbortError\");\n    }\n  } else if (error.name === \"NotAllowedError\") {\n    if ((_a = publicKey.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) {\n      return new WebAuthnError(\"No available authenticator recognized any of the allowed credentials\", \"NotAllowedError\");\n    }\n    return new WebAuthnError(\"User clicked cancel, or the authentication ceremony timed out\", \"NotAllowedError\");\n  } else if (error.name === \"SecurityError\") {\n    const effectiveDomain = window.location.hostname;\n    if (!isValidDomain(effectiveDomain)) {\n      return new WebAuthnError(`${window.location.hostname} is an invalid domain`, \"SecurityError\");\n    } else if (publicKey.rpId !== effectiveDomain) {\n      return new WebAuthnError(`The RP ID \"${publicKey.rpId}\" is invalid for this domain`, \"SecurityError\");\n    }\n  } else if (error.name === \"UnknownError\") {\n    return new WebAuthnError(\"The authenticator was unable to process the specified options, or could not create a new assertion signature\", \"UnknownError\");\n  }\n  return error;\n}\nasync function startAuthentication(requestOptionsJSON) {\n  let useBrowserAutofill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var _a, _b;\n  if (!browserSupportsWebAuthn()) {\n    throw new Error(\"WebAuthn is not supported in this browser\");\n  }\n  let allowCredentials;\n  if (((_a = requestOptionsJSON.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) !== 0) {\n    allowCredentials = (_b = requestOptionsJSON.allowCredentials) === null || _b === void 0 ? void 0 : _b.map(toPublicKeyCredentialDescriptor);\n  }\n  const publicKey = __spreadProps(__spreadValues({}, requestOptionsJSON), {\n    challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n    allowCredentials\n  });\n  const options = {};\n  if (useBrowserAutofill) {\n    if (!(await browserSupportsWebAuthnAutofill())) {\n      throw Error(\"Browser does not support WebAuthn autofill\");\n    }\n    const eligibleInputs = document.querySelectorAll(\"input[autocomplete*='webauthn']\");\n    if (eligibleInputs.length < 1) {\n      throw Error('No <input> with `\"webauthn\"` in its `autocomplete` attribute was detected');\n    }\n    options.mediation = \"conditional\";\n    publicKey.allowCredentials = [];\n  }\n  options.publicKey = publicKey;\n  options.signal = webauthnAbortService.createNewAbortSignal();\n  let credential;\n  try {\n    credential = await navigator.credentials.get(options);\n  } catch (err) {\n    throw identifyAuthenticationError({\n      error: err,\n      options\n    });\n  } finally {\n    webauthnAbortService.reset();\n  }\n  if (!credential) {\n    throw new Error(\"Authentication was not completed\");\n  }\n  const {\n    id,\n    rawId,\n    response,\n    type\n  } = credential;\n  let userHandle = void 0;\n  if (response.userHandle) {\n    userHandle = bufferToUTF8String(response.userHandle);\n  }\n  return {\n    id,\n    rawId: bufferToBase64URLString(rawId),\n    response: {\n      authenticatorData: bufferToBase64URLString(response.authenticatorData),\n      clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n      signature: bufferToBase64URLString(response.signature),\n      userHandle\n    },\n    type,\n    clientExtensionResults: credential.getClientExtensionResults(),\n    authenticatorAttachment: credential.authenticatorAttachment\n  };\n}\nconst NHOST_REFRESH_TOKEN_KEY = \"nhostRefreshToken\";\nconst NHOST_JWT_EXPIRES_AT_KEY = \"nhostRefreshTokenExpiresAt\";\nconst MIN_PASSWORD_LENGTH = 3;\nconst TOKEN_REFRESH_MARGIN = 300;\nconst REFRESH_TOKEN_RETRY_INTERVAL = 5;\nconst REFRESH_TOKEN_RETRY_MAX_ATTEMPTS = 30;\nconst NETWORK_ERROR_CODE = 0;\nconst OTHER_ERROR_CODE = 1;\nconst VALIDATION_ERROR_CODE = 10;\nconst STATE_ERROR_CODE = 20;\nclass CodifiedError extends Error {\n  constructor(original) {\n    super(original.message);\n    Error.captureStackTrace(this, this.constructor);\n    if (original instanceof Error) {\n      this.name = original.name;\n      this.error = {\n        error: original.name,\n        status: OTHER_ERROR_CODE,\n        message: original.message\n      };\n    } else {\n      this.name = original.error;\n      this.error = original;\n    }\n  }\n}\nconst INVALID_EMAIL_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-email\",\n  message: \"Email is incorrectly formatted\"\n};\nconst INVALID_MFA_TYPE_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-mfa-type\",\n  message: \"MFA type is invalid\"\n};\nconst INVALID_MFA_CODE_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-mfa-code\",\n  message: \"MFA code is invalid\"\n};\nconst INVALID_PASSWORD_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-password\",\n  message: \"Password is incorrectly formatted\"\n};\nconst INVALID_PHONE_NUMBER_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-phone-number\",\n  message: \"Phone number is incorrectly formatted\"\n};\nconst INVALID_MFA_TICKET_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-mfa-ticket\",\n  message: \"MFA ticket is invalid\"\n};\nconst NO_MFA_TICKET_ERROR = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"no-mfa-ticket\",\n  message: \"No MFA ticket has been provided\"\n};\nconst NO_REFRESH_TOKEN = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"no-refresh-token\",\n  message: \"No refresh token has been provided\"\n};\nconst TOKEN_REFRESHER_RUNNING_ERROR = {\n  status: STATE_ERROR_CODE,\n  error: \"refresher-already-running\",\n  message: \"The token refresher is already running. You must wait until is has finished before submitting a new token.\"\n};\nconst USER_ALREADY_SIGNED_IN = {\n  status: STATE_ERROR_CODE,\n  error: \"already-signed-in\",\n  message: \"User is already signed in\"\n};\nconst USER_UNAUTHENTICATED = {\n  status: STATE_ERROR_CODE,\n  error: \"unauthenticated-user\",\n  message: \"User is not authenticated\"\n};\nconst USER_NOT_ANONYMOUS = {\n  status: STATE_ERROR_CODE,\n  error: \"user-not-anonymous\",\n  message: \"User is not anonymous\"\n};\nconst EMAIL_NEEDS_VERIFICATION = {\n  status: STATE_ERROR_CODE,\n  error: \"unverified-user\",\n  message: \"Email needs verification\"\n};\nconst INVALID_REFRESH_TOKEN = {\n  status: VALIDATION_ERROR_CODE,\n  error: \"invalid-refresh-token\",\n  message: \"Invalid or expired refresh token\"\n};\nconst nhostApiClient = backendUrl => {\n  const client = axios.create({\n    baseURL: backendUrl\n  });\n  client.interceptors.response.use(response => response, error => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    return Promise.reject({\n      error: {\n        message: (_e = (_d = (_c = (_b = (_a = error.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message) != null ? _c : error.message) != null ? _d : error.request.responseText) != null ? _e : JSON.stringify(error),\n        status: (_i = (_h = (_f = error.response) == null ? void 0 : _f.status) != null ? _h : (_g = error.response) == null ? void 0 : _g.data.statusCode) != null ? _i : NETWORK_ERROR_CODE,\n        error: ((_j = error.response) == null ? void 0 : _j.data.error) || error.request.statusText || \"network\"\n      }\n    });\n  });\n  return client;\n};\nconst isBrowser$1 = typeof window !== \"undefined\";\nconst inMemoryLocalStorage = /* @__PURE__ */new Map();\nconst defaultClientStorageGetter = key => {\n  var _a;\n  if (isBrowser$1 && typeof localStorage !== \"undefined\") return localStorage.getItem(key);else return (_a = inMemoryLocalStorage.get(key)) != null ? _a : null;\n};\nconst defaultClientStorageSetter = (key, value) => {\n  if (isBrowser$1 && typeof localStorage !== \"undefined\") {\n    if (value) {\n      localStorage.setItem(key, value);\n    } else {\n      localStorage.removeItem(key);\n    }\n  } else {\n    if (value) {\n      inMemoryLocalStorage.set(key, value);\n    } else if (inMemoryLocalStorage.has(key)) {\n      inMemoryLocalStorage.delete(key);\n    }\n  }\n};\nconst localStorageGetter = (clientStorageType, clientStorage) => {\n  if (clientStorageType === \"localStorage\" || clientStorageType === \"web\") {\n    return defaultClientStorageGetter;\n  }\n  if (clientStorageType === \"cookie\") {\n    return key => {\n      var _a;\n      if (isBrowser$1) {\n        return (_a = Cookies.get(key)) != null ? _a : null;\n      } else {\n        return null;\n      }\n    };\n  }\n  if (!clientStorage) {\n    throw Error(`clientStorageType is set to '${clientStorageType}' but no clientStorage has been given`);\n  }\n  if (clientStorageType === \"react-native\") {\n    return key => {\n      var _a;\n      return (_a = clientStorage.getItem) == null ? void 0 : _a.call(clientStorage, key);\n    };\n  }\n  if (clientStorageType === \"capacitor\") {\n    return key => {\n      var _a;\n      return (_a = clientStorage.get) == null ? void 0 : _a.call(clientStorage, {\n        key\n      });\n    };\n  }\n  if (clientStorageType === \"expo-secure-storage\") {\n    return key => {\n      var _a;\n      return (_a = clientStorage.getItemAsync) == null ? void 0 : _a.call(clientStorage, key);\n    };\n  }\n  if (clientStorageType === \"custom\") {\n    if (clientStorage.getItem && clientStorage.removeItem) {\n      return clientStorage.getItem;\n    }\n    if (clientStorage.getItemAsync) {\n      return clientStorage.getItemAsync;\n    }\n    throw Error(`clientStorageType is set to 'custom' but clientStorage is missing either \"getItem\" and \"removeItem\" properties or \"getItemAsync\" property`);\n  }\n  throw Error(`Unknown storage type: ${clientStorageType}`);\n};\nconst localStorageSetter = (clientStorageType, clientStorage) => {\n  if (clientStorageType === \"localStorage\" || clientStorageType === \"web\") {\n    return defaultClientStorageSetter;\n  }\n  if (clientStorageType === \"cookie\") {\n    return (key, value) => {\n      if (isBrowser$1) {\n        if (value) {\n          Cookies.set(key, value, {\n            expires: 30\n          });\n        } else {\n          Cookies.remove(key);\n        }\n      }\n    };\n  }\n  if (!clientStorage) {\n    throw Error(`clientStorageType is set to '${clientStorageType}' but no clienStorage has been given`);\n  }\n  if (clientStorageType === \"react-native\") {\n    return (key, value) => {\n      var _a, _b;\n      return value ? (_a = clientStorage.setItem) == null ? void 0 : _a.call(clientStorage, key, value) : (_b = clientStorage.removeItem) == null ? void 0 : _b.call(clientStorage, key);\n    };\n  }\n  if (clientStorageType === \"capacitor\") {\n    return (key, value) => {\n      var _a, _b;\n      return value ? (_a = clientStorage.set) == null ? void 0 : _a.call(clientStorage, {\n        key,\n        value\n      }) : (_b = clientStorage.remove) == null ? void 0 : _b.call(clientStorage, {\n        key\n      });\n    };\n  }\n  if (clientStorageType === \"expo-secure-storage\") {\n    return async (key, value) => {\n      var _a, _b;\n      return value ? (_a = clientStorage.setItemAsync) == null ? void 0 : _a.call(clientStorage, key, value) : (_b = clientStorage.deleteItemAsync) == null ? void 0 : _b.call(clientStorage, key);\n    };\n  }\n  if (clientStorageType === \"custom\") {\n    if (!clientStorage.removeItem) {\n      throw Error(`clientStorageType is set to 'custom' but clientStorage is missing a removeItem property`);\n    }\n    if (clientStorage.setItem) {\n      return (key, value) => {\n        var _a, _b;\n        return value ? (_a = clientStorage.setItem) == null ? void 0 : _a.call(clientStorage, key, value) : (_b = clientStorage.removeItem) == null ? void 0 : _b.call(clientStorage, key);\n      };\n    }\n    if (clientStorage.setItemAsync) {\n      return async (key, value) => {\n        var _a, _b;\n        return value ? (_a = clientStorage.setItemAsync) == null ? void 0 : _a.call(clientStorage, key, value) : (_b = clientStorage.removeItem) == null ? void 0 : _b.call(clientStorage, key);\n      };\n    }\n    throw Error(`clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property`);\n  }\n  throw Error(`Unknown storage type: ${clientStorageType}`);\n};\nconst encodeQueryParameters = (baseUrl, parameters) => {\n  const encodedParameters = parameters && Object.entries(parameters).map(_ref3 => {\n    let [key, value] = _ref3;\n    const stringValue = Array.isArray(value) ? value.join(\",\") : typeof value === \"object\" ? JSON.stringify(value) : value;\n    return `${key}=${encodeURIComponent(stringValue)}`;\n  }).join(\"&\");\n  if (encodedParameters) return `${baseUrl}?${encodedParameters}`;else return baseUrl;\n};\nconst rewriteRedirectTo = (clientUrl, options) => {\n  if (!(options == null ? void 0 : options.redirectTo)) {\n    return options;\n  }\n  const _a = options,\n    {\n      redirectTo\n    } = _a,\n    otherOptions = __objRest(_a, [\"redirectTo\"]);\n  if (!clientUrl) {\n    if (redirectTo.startsWith(\"/\")) {\n      return otherOptions;\n    } else {\n      return options;\n    }\n  }\n  const baseClientUrl = new URL(clientUrl);\n  const clientParams = Object.fromEntries(new URLSearchParams(baseClientUrl.search));\n  const url = new URL(redirectTo.startsWith(\"/\") ? baseClientUrl.origin + redirectTo : redirectTo);\n  const additionalParams = new URLSearchParams(url.search);\n  let combinedParams = Object.fromEntries(additionalParams);\n  if (redirectTo.startsWith(\"/\")) {\n    combinedParams = __spreadValues(__spreadValues({}, clientParams), combinedParams);\n  }\n  let pathName = baseClientUrl.pathname;\n  if (url.pathname.length > 1) {\n    pathName += url.pathname.slice(1);\n  }\n  return __spreadProps(__spreadValues({}, otherOptions), {\n    redirectTo: encodeQueryParameters(url.origin + pathName, combinedParams)\n  });\n};\nfunction getParameterByName(name, url) {\n  var _a;\n  if (!url) {\n    if (typeof window === \"undefined\") {\n      return;\n    }\n    url = ((_a = window.location) == null ? void 0 : _a.href) || \"\";\n  }\n  name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n  const regex = new RegExp(\"[?&#]\" + name + \"(=([^&#]*)|&|#|$)\"),\n    results = regex.exec(url);\n  if (!results) return null;\n  if (!results[2]) return \"\";\n  return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n}\nfunction removeParameterFromWindow(name) {\n  var _a;\n  if (typeof window === \"undefined\") {\n    return;\n  }\n  const location = window == null ? void 0 : window.location;\n  if (!location) {\n    return;\n  }\n  if (location) {\n    const search = new URLSearchParams(location.search);\n    const hash = new URLSearchParams((_a = location.hash) == null ? void 0 : _a.slice(1));\n    search.delete(name);\n    hash.delete(name);\n    let url = window.location.pathname;\n    if (Array.from(search).length) url += `?${search.toString()}`;\n    if (Array.from(hash).length) url += `#${hash.toString()}`;\n    window.history.pushState({}, \"\", url);\n  }\n}\nconst isValidEmail = email => !!email && typeof email === \"string\" && !!String(email).toLowerCase().match(/^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/);\nconst isValidPassword = password => !!password && typeof password === \"string\" && password.length >= MIN_PASSWORD_LENGTH;\nconst isValidPhoneNumber = phoneNumber => !!phoneNumber && typeof phoneNumber === \"string\";\nconst isValidTicket = ticket => ticket && typeof ticket === \"string\" && ticket.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i);\nconst INITIAL_MACHINE_CONTEXT = {\n  user: null,\n  mfa: null,\n  accessToken: {\n    value: null,\n    expiresAt: null\n  },\n  refreshTimer: {\n    startedAt: null,\n    attempts: 0,\n    lastAttempt: null\n  },\n  refreshToken: {\n    value: null\n  },\n  errors: {}\n};\nconst createChangeEmailMachine = _ref4 => {\n  let {\n    backendUrl,\n    clientUrl,\n    interpreter\n  } = _ref4;\n  const api = nhostApiClient(backendUrl);\n  return createMachine({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    preserveActionOrder: true,\n    id: \"changeEmail\",\n    initial: \"idle\",\n    context: {\n      error: null\n    },\n    states: {\n      idle: {\n        on: {\n          REQUEST: [{\n            cond: \"invalidEmail\",\n            actions: \"saveInvalidEmailError\",\n            target: \".error\"\n          }, {\n            target: \"requesting\"\n          }]\n        },\n        initial: \"initial\",\n        states: {\n          initial: {},\n          success: {},\n          error: {}\n        }\n      },\n      requesting: {\n        invoke: {\n          src: \"requestChange\",\n          id: \"requestChange\",\n          onDone: {\n            target: \"idle.success\",\n            actions: \"reportSuccess\"\n          },\n          onError: {\n            actions: [\"saveRequestError\", \"reportError\"],\n            target: \"idle.error\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidEmailError: assign({\n        error: _ => INVALID_EMAIL_ERROR\n      }),\n      saveRequestError: assign({\n        error: (_, _ref5) => {\n          let {\n            data: {\n              error\n            }\n          } = _ref5;\n          return error;\n        }\n      }),\n      reportError: send(ctx => ({\n        type: \"ERROR\",\n        error: ctx.error\n      })),\n      reportSuccess: send(\"SUCCESS\")\n    },\n    guards: {\n      invalidEmail: (_, _ref6) => {\n        let {\n          email\n        } = _ref6;\n        return !isValidEmail(email);\n      }\n    },\n    services: {\n      requestChange: async (_, _ref7) => {\n        let {\n          email,\n          options\n        } = _ref7;\n        const res = await api.post(\"/user/email/change\", {\n          newEmail: email,\n          options: rewriteRedirectTo(clientUrl, options)\n        }, {\n          headers: {\n            authorization: `Bearer ${interpreter == null ? void 0 : interpreter.state.context.accessToken.value}`\n          }\n        });\n        return res.data;\n      }\n    }\n  });\n};\nconst createChangePasswordMachine = _ref8 => {\n  let {\n    backendUrl,\n    interpreter\n  } = _ref8;\n  const api = nhostApiClient(backendUrl);\n  return createMachine({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    preserveActionOrder: true,\n    id: \"changePassword\",\n    initial: \"idle\",\n    context: {\n      error: null\n    },\n    states: {\n      idle: {\n        on: {\n          REQUEST: [{\n            cond: \"invalidPassword\",\n            actions: \"saveInvalidPasswordError\",\n            target: \".error\"\n          }, {\n            target: \"requesting\"\n          }]\n        },\n        initial: \"initial\",\n        states: {\n          initial: {},\n          success: {},\n          error: {}\n        }\n      },\n      requesting: {\n        invoke: {\n          src: \"requestChange\",\n          id: \"requestChange\",\n          onDone: {\n            target: \"idle.success\",\n            actions: \"reportSuccess\"\n          },\n          onError: {\n            actions: [\"saveRequestError\", \"reportError\"],\n            target: \"idle.error\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidPasswordError: assign({\n        error: _ => INVALID_PASSWORD_ERROR\n      }),\n      saveRequestError: assign({\n        error: (_, _ref9) => {\n          let {\n            data: {\n              error\n            }\n          } = _ref9;\n          return error;\n        }\n      }),\n      reportError: send(ctx => ({\n        type: \"ERROR\",\n        error: ctx.error\n      })),\n      reportSuccess: send(\"SUCCESS\")\n    },\n    guards: {\n      invalidPassword: (_, _ref10) => {\n        let {\n          password\n        } = _ref10;\n        return !isValidPassword(password);\n      }\n    },\n    services: {\n      requestChange: (_, _ref11) => {\n        let {\n          password,\n          ticket\n        } = _ref11;\n        return api.post(\"/user/password\", {\n          newPassword: password,\n          ticket\n        }, {\n          headers: {\n            authorization: `Bearer ${interpreter == null ? void 0 : interpreter.state.context.accessToken.value}`\n          }\n        });\n      }\n    }\n  });\n};\nconst createEnableMfaMachine = _ref12 => {\n  let {\n    backendUrl,\n    interpreter\n  } = _ref12;\n  const api = nhostApiClient(backendUrl);\n  return createMachine({\n    schema: {\n      context: {},\n      events: {}\n    },\n    tsTypes: {},\n    preserveActionOrder: true,\n    id: \"enableMfa\",\n    initial: \"idle\",\n    context: {\n      error: null,\n      imageUrl: null,\n      secret: null\n    },\n    states: {\n      idle: {\n        initial: \"initial\",\n        on: {\n          GENERATE: \"generating\"\n        },\n        states: {\n          initial: {},\n          error: {}\n        }\n      },\n      generating: {\n        invoke: {\n          src: \"generate\",\n          id: \"generate\",\n          onDone: {\n            target: \"generated\",\n            actions: [\"reportGeneratedSuccess\", \"saveGeneration\"]\n          },\n          onError: {\n            actions: [\"saveError\", \"reportGeneratedError\"],\n            target: \"idle.error\"\n          }\n        }\n      },\n      generated: {\n        initial: \"idle\",\n        states: {\n          idle: {\n            initial: \"idle\",\n            on: {\n              ACTIVATE: [{\n                cond: \"invalidMfaType\",\n                actions: \"saveInvalidMfaTypeError\",\n                target: \".error\"\n              }, {\n                cond: \"invalidMfaCode\",\n                actions: \"saveInvalidMfaCodeError\",\n                target: \".error\"\n              }, {\n                target: \"activating\"\n              }]\n            },\n            states: {\n              idle: {},\n              error: {}\n            }\n          },\n          activating: {\n            invoke: {\n              src: \"activate\",\n              id: \"activate\",\n              onDone: {\n                target: \"activated\",\n                actions: \"reportSuccess\"\n              },\n              onError: {\n                actions: [\"saveError\", \"reportError\"],\n                target: \"idle.error\"\n              }\n            }\n          },\n          activated: {\n            type: \"final\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidMfaTypeError: assign({\n        error: _ => INVALID_MFA_TYPE_ERROR\n      }),\n      saveInvalidMfaCodeError: assign({\n        error: _ => INVALID_MFA_CODE_ERROR\n      }),\n      saveError: assign({\n        error: (_, _ref13) => {\n          let {\n            data: {\n              error\n            }\n          } = _ref13;\n          return error;\n        }\n      }),\n      saveGeneration: assign({\n        imageUrl: (_, _ref14) => {\n          let {\n            data: {\n              imageUrl\n            }\n          } = _ref14;\n          return imageUrl;\n        },\n        secret: (_, _ref15) => {\n          let {\n            data: {\n              totpSecret\n            }\n          } = _ref15;\n          return totpSecret;\n        }\n      }),\n      reportError: send(ctx => ({\n        type: \"ERROR\",\n        error: ctx.error\n      })),\n      reportSuccess: send(\"SUCCESS\"),\n      reportGeneratedSuccess: send(\"GENERATED\"),\n      reportGeneratedError: send(ctx => ({\n        type: \"GENERATED_ERROR\",\n        error: ctx.error\n      }))\n    },\n    guards: {\n      invalidMfaCode: (_, _ref16) => {\n        let {\n          code\n        } = _ref16;\n        return !code;\n      },\n      invalidMfaType: (_, _ref17) => {\n        let {\n          activeMfaType\n        } = _ref17;\n        return !activeMfaType || activeMfaType !== \"totp\";\n      }\n    },\n    services: {\n      generate: async _ => {\n        const {\n          data\n        } = await api.get(\"/mfa/totp/generate\", {\n          headers: {\n            authorization: `Bearer ${interpreter == null ? void 0 : interpreter.state.context.accessToken.value}`\n          }\n        });\n        return data;\n      },\n      activate: (_, _ref18) => {\n        let {\n          code,\n          activeMfaType\n        } = _ref18;\n        return api.post(\"/user/mfa\", {\n          code,\n          activeMfaType\n        }, {\n          headers: {\n            authorization: `Bearer ${interpreter == null ? void 0 : interpreter.state.context.accessToken.value}`\n          }\n        });\n      }\n    }\n  });\n};\nconst createResetPasswordMachine = _ref19 => {\n  let {\n    backendUrl,\n    clientUrl\n  } = _ref19;\n  const api = nhostApiClient(backendUrl);\n  return createMachine({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    preserveActionOrder: true,\n    id: \"changePassword\",\n    initial: \"idle\",\n    context: {\n      error: null\n    },\n    states: {\n      idle: {\n        on: {\n          REQUEST: [{\n            cond: \"invalidEmail\",\n            actions: \"saveInvalidEmailError\",\n            target: \".error\"\n          }, {\n            target: \"requesting\"\n          }]\n        },\n        initial: \"initial\",\n        states: {\n          initial: {},\n          success: {},\n          error: {}\n        }\n      },\n      requesting: {\n        invoke: {\n          src: \"requestChange\",\n          id: \"requestChange\",\n          onDone: {\n            target: \"idle.success\",\n            actions: \"reportSuccess\"\n          },\n          onError: {\n            actions: [\"saveRequestError\", \"reportError\"],\n            target: \"idle.error\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidEmailError: assign({\n        error: _ => INVALID_EMAIL_ERROR\n      }),\n      saveRequestError: assign({\n        error: (_, _ref20) => {\n          let {\n            data: {\n              error\n            }\n          } = _ref20;\n          return error;\n        }\n      }),\n      reportError: send(ctx => ({\n        type: \"ERROR\",\n        error: ctx.error\n      })),\n      reportSuccess: send(\"SUCCESS\")\n    },\n    guards: {\n      invalidEmail: (_, _ref21) => {\n        let {\n          email\n        } = _ref21;\n        return !isValidEmail(email);\n      }\n    },\n    services: {\n      requestChange: (_, _ref22) => {\n        let {\n          email,\n          options\n        } = _ref22;\n        return api.post(\"/user/password/reset\", {\n          email,\n          options: rewriteRedirectTo(clientUrl, options)\n        });\n      }\n    }\n  });\n};\nconst createSendVerificationEmailMachine = _ref23 => {\n  let {\n    backendUrl,\n    clientUrl\n  } = _ref23;\n  const api = nhostApiClient(backendUrl);\n  return createMachine({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    preserveActionOrder: true,\n    id: \"sendVerificationEmail\",\n    initial: \"idle\",\n    context: {\n      error: null\n    },\n    states: {\n      idle: {\n        on: {\n          REQUEST: [{\n            cond: \"invalidEmail\",\n            actions: \"saveInvalidEmailError\",\n            target: \".error\"\n          }, {\n            target: \"requesting\"\n          }]\n        },\n        initial: \"initial\",\n        states: {\n          initial: {},\n          success: {},\n          error: {}\n        }\n      },\n      requesting: {\n        invoke: {\n          src: \"request\",\n          id: \"request\",\n          onDone: {\n            target: \"idle.success\",\n            actions: \"reportSuccess\"\n          },\n          onError: {\n            actions: [\"saveRequestError\", \"reportError\"],\n            target: \"idle.error\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidEmailError: assign({\n        error: _ => INVALID_EMAIL_ERROR\n      }),\n      saveRequestError: assign({\n        error: (_, _ref24) => {\n          let {\n            data: {\n              error\n            }\n          } = _ref24;\n          return error;\n        }\n      }),\n      reportError: send(ctx => ({\n        type: \"ERROR\",\n        error: ctx.error\n      })),\n      reportSuccess: send(\"SUCCESS\")\n    },\n    guards: {\n      invalidEmail: (_, _ref25) => {\n        let {\n          email\n        } = _ref25;\n        return !isValidEmail(email);\n      }\n    },\n    services: {\n      request: async (_, _ref26) => {\n        let {\n          email,\n          options\n        } = _ref26;\n        const res = await api.post(\"/user/email/send-verification-email\", {\n          email,\n          options: rewriteRedirectTo(clientUrl, options)\n        });\n        return res.data;\n      }\n    }\n  });\n};\nconst createAuthMachine = _ref27 => {\n  let {\n    backendUrl,\n    clientUrl,\n    clientStorageGetter,\n    clientStorageSetter,\n    clientStorageType = \"web\",\n    clientStorage,\n    refreshIntervalTime,\n    autoRefreshToken = true,\n    autoSignIn = true\n  } = _ref27;\n  const storageGetter = clientStorageGetter || localStorageGetter(clientStorageType, clientStorage);\n  const storageSetter = clientStorageSetter || localStorageSetter(clientStorageType, clientStorage);\n  const api = nhostApiClient(backendUrl);\n  const postRequest = async (url, data, config) => {\n    const result = await api.post(url, data, config);\n    return result.data;\n  };\n  return createMachine({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    context: INITIAL_MACHINE_CONTEXT,\n    preserveActionOrder: true,\n    id: \"nhost\",\n    type: \"parallel\",\n    states: {\n      authentication: {\n        initial: \"starting\",\n        on: {\n          SESSION_UPDATE: [{\n            cond: \"hasSession\",\n            actions: [\"saveSession\", \"resetTimer\", \"reportTokenChanged\"],\n            target: \".signedIn\"\n          }]\n        },\n        states: {\n          starting: {\n            entry: \"resetErrors\",\n            tags: [\"loading\"],\n            always: {\n              cond: \"isSignedIn\",\n              target: \"signedIn\"\n            },\n            invoke: {\n              id: \"importRefreshToken\",\n              src: \"importRefreshToken\",\n              onDone: {\n                actions: [\"saveSession\", \"reportTokenChanged\"],\n                target: \"signedIn\"\n              },\n              onError: {\n                actions: [\"saveAuthenticationError\"],\n                target: \"signedOut\"\n              }\n            }\n          },\n          signedOut: {\n            initial: \"noErrors\",\n            entry: \"reportSignedOut\",\n            states: {\n              noErrors: {},\n              success: {},\n              needsSmsOtp: {},\n              needsMfa: {},\n              failed: {},\n              signingOut: {\n                entry: [\"clearContextExceptRefreshToken\"],\n                exit: [\"destroyRefreshToken\", \"reportTokenChanged\"],\n                invoke: {\n                  src: \"signout\",\n                  id: \"signingOut\",\n                  onDone: {\n                    target: \"success\"\n                  },\n                  onError: {\n                    target: \"failed\",\n                    actions: [\"saveAuthenticationError\"]\n                  }\n                }\n              }\n            },\n            on: {\n              SIGNIN_PASSWORD: \"authenticating.password\",\n              SIGNIN_ANONYMOUS: \"authenticating.anonymous\",\n              SIGNIN_SECURITY_KEY_EMAIL: \"authenticating.securityKeyEmail\",\n              SIGNIN_MFA_TOTP: \"authenticating.mfa.totp\"\n            }\n          },\n          authenticating: {\n            entry: \"resetErrors\",\n            states: {\n              password: {\n                invoke: {\n                  src: \"signInPassword\",\n                  id: \"authenticateUserWithPassword\",\n                  onDone: [{\n                    cond: \"hasMfaTicket\",\n                    actions: [\"saveMfaTicket\"],\n                    target: \"#nhost.authentication.signedOut.needsMfa\"\n                  }, {\n                    actions: [\"saveSession\", \"reportTokenChanged\"],\n                    target: \"#nhost.authentication.signedIn\"\n                  }],\n                  onError: [{\n                    cond: \"unverified\",\n                    target: [\"#nhost.authentication.signedOut\", \"#nhost.registration.incomplete.needsEmailVerification\"]\n                  }, {\n                    actions: \"saveAuthenticationError\",\n                    target: \"#nhost.authentication.signedOut.failed\"\n                  }]\n                }\n              },\n              anonymous: {\n                invoke: {\n                  src: \"signInAnonymous\",\n                  id: \"authenticateAnonymously\",\n                  onDone: {\n                    actions: [\"saveSession\", \"reportTokenChanged\"],\n                    target: \"#nhost.authentication.signedIn\"\n                  },\n                  onError: {\n                    actions: \"saveAuthenticationError\",\n                    target: \"#nhost.authentication.signedOut.failed\"\n                  }\n                }\n              },\n              mfa: {\n                states: {\n                  totp: {\n                    invoke: {\n                      src: \"signInMfaTotp\",\n                      id: \"signInMfaTotp\",\n                      onDone: {\n                        actions: [\"saveSession\", \"reportTokenChanged\"],\n                        target: \"#nhost.authentication.signedIn\"\n                      },\n                      onError: {\n                        actions: [\"saveAuthenticationError\"],\n                        target: \"#nhost.authentication.signedOut.failed\"\n                      }\n                    }\n                  }\n                }\n              },\n              securityKeyEmail: {\n                invoke: {\n                  src: \"signInSecurityKeyEmail\",\n                  id: \"authenticateUserWithSecurityKey\",\n                  onDone: {\n                    actions: [\"saveSession\", \"reportTokenChanged\"],\n                    target: \"#nhost.authentication.signedIn\"\n                  },\n                  onError: [{\n                    cond: \"unverified\",\n                    target: [\"#nhost.authentication.signedOut\", \"#nhost.registration.incomplete.needsEmailVerification\"]\n                  }, {\n                    actions: \"saveAuthenticationError\",\n                    target: \"#nhost.authentication.signedOut.failed\"\n                  }]\n                }\n              }\n            }\n          },\n          signedIn: {\n            type: \"parallel\",\n            entry: [\"reportSignedIn\", \"cleanUrl\", \"broadcastToken\", \"resetErrors\"],\n            on: {\n              SIGNOUT: \"signedOut.signingOut\"\n            },\n            states: {\n              refreshTimer: {\n                id: \"timer\",\n                initial: \"idle\",\n                states: {\n                  disabled: {\n                    type: \"final\"\n                  },\n                  stopped: {\n                    always: {\n                      cond: \"noToken\",\n                      target: \"idle\"\n                    }\n                  },\n                  idle: {\n                    always: [{\n                      cond: \"isAutoRefreshDisabled\",\n                      target: \"disabled\"\n                    }, {\n                      cond: \"hasRefreshToken\",\n                      target: \"running\"\n                    }]\n                  },\n                  running: {\n                    initial: \"pending\",\n                    entry: \"resetTimer\",\n                    states: {\n                      pending: {\n                        after: {\n                          \"1000\": {\n                            internal: false,\n                            target: \"pending\"\n                          }\n                        },\n                        always: {\n                          cond: \"refreshTimerShouldRefresh\",\n                          target: \"refreshing\"\n                        }\n                      },\n                      refreshing: {\n                        invoke: {\n                          src: \"refreshToken\",\n                          id: \"refreshToken\",\n                          onDone: {\n                            actions: [\"saveSession\", \"resetTimer\", \"reportTokenChanged\"],\n                            target: \"pending\"\n                          },\n                          onError: [{\n                            actions: \"saveRefreshAttempt\",\n                            target: \"pending\"\n                          }]\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      token: {\n        initial: \"idle\",\n        states: {\n          idle: {\n            on: {\n              TRY_TOKEN: \"running\"\n            },\n            initial: \"noErrors\",\n            states: {\n              noErrors: {},\n              error: {}\n            }\n          },\n          running: {\n            invoke: {\n              src: \"refreshToken\",\n              id: \"authenticateWithToken\",\n              onDone: {\n                actions: [\"saveSession\", \"reportTokenChanged\"],\n                target: [\"#nhost.authentication.signedIn\", \"idle.noErrors\"]\n              },\n              onError: [{\n                cond: \"isSignedIn\",\n                target: \"idle.error\"\n              }, {\n                actions: \"saveAuthenticationError\",\n                target: [\"#nhost.authentication.signedOut.failed\", \"idle.error\"]\n              }]\n            }\n          }\n        }\n      },\n      registration: {\n        initial: \"incomplete\",\n        on: {\n          SIGNED_IN: [{\n            cond: \"isAnonymous\",\n            target: \".incomplete\"\n          }, \".complete\"]\n        },\n        states: {\n          incomplete: {\n            on: {\n              SIGNUP_EMAIL_PASSWORD: \"emailPassword\",\n              SIGNUP_SECURITY_KEY: \"securityKey\",\n              PASSWORDLESS_EMAIL: \"passwordlessEmail\",\n              PASSWORDLESS_SMS: \"passwordlessSms\",\n              PASSWORDLESS_SMS_OTP: \"passwordlessSmsOtp\"\n            },\n            initial: \"noErrors\",\n            states: {\n              noErrors: {},\n              needsEmailVerification: {},\n              needsOtp: {},\n              failed: {}\n            }\n          },\n          emailPassword: {\n            entry: [\"resetErrors\"],\n            invoke: {\n              src: \"signUpEmailPassword\",\n              id: \"signUpEmailPassword\",\n              onDone: [{\n                cond: \"hasSession\",\n                actions: [\"saveSession\", \"reportTokenChanged\"],\n                target: \"#nhost.authentication.signedIn\"\n              }, {\n                actions: \"clearContext\",\n                target: [\"#nhost.authentication.signedOut\", \"incomplete.needsEmailVerification\"]\n              }],\n              onError: [{\n                cond: \"unverified\",\n                target: \"incomplete.needsEmailVerification\"\n              }, {\n                actions: \"saveRegistrationError\",\n                target: \"incomplete.failed\"\n              }]\n            }\n          },\n          securityKey: {\n            entry: [\"resetErrors\"],\n            invoke: {\n              src: \"signUpSecurityKey\",\n              id: \"signUpSecurityKey\",\n              onDone: [{\n                cond: \"hasSession\",\n                actions: [\"saveSession\", \"reportTokenChanged\"],\n                target: \"#nhost.authentication.signedIn\"\n              }, {\n                actions: \"clearContext\",\n                target: [\"#nhost.authentication.signedOut\", \"incomplete.needsEmailVerification\"]\n              }],\n              onError: [{\n                cond: \"unverified\",\n                target: \"incomplete.needsEmailVerification\"\n              }, {\n                actions: \"saveRegistrationError\",\n                target: \"incomplete.failed\"\n              }]\n            }\n          },\n          passwordlessEmail: {\n            entry: [\"resetErrors\"],\n            invoke: {\n              src: \"passwordlessEmail\",\n              id: \"passwordlessEmail\",\n              onDone: {\n                actions: \"clearContext\",\n                target: [\"#nhost.authentication.signedOut\", \"incomplete.needsEmailVerification\"]\n              },\n              onError: {\n                actions: \"saveRegistrationError\",\n                target: \"incomplete.failed\"\n              }\n            }\n          },\n          passwordlessSms: {\n            entry: [\"resetErrors\"],\n            invoke: {\n              src: \"passwordlessSms\",\n              id: \"passwordlessSms\",\n              onDone: {\n                actions: \"clearContext\",\n                target: [\"#nhost.authentication.signedOut\", \"incomplete.needsOtp\"]\n              },\n              onError: {\n                actions: \"saveRegistrationError\",\n                target: \"incomplete.failed\"\n              }\n            }\n          },\n          passwordlessSmsOtp: {\n            entry: [\"resetErrors\"],\n            invoke: {\n              src: \"passwordlessSmsOtp\",\n              id: \"passwordlessSmsOtp\",\n              onDone: {\n                actions: [\"saveSession\", \"reportTokenChanged\"],\n                target: \"#nhost.authentication.signedIn\"\n              },\n              onError: {\n                actions: \"saveRegistrationError\",\n                target: \"incomplete.failed\"\n              }\n            }\n          },\n          complete: {\n            on: {\n              SIGNED_OUT: \"incomplete\"\n            }\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      reportSignedIn: send(\"SIGNED_IN\"),\n      reportSignedOut: send(\"SIGNED_OUT\"),\n      reportTokenChanged: send(\"TOKEN_CHANGED\"),\n      clearContext: assign(() => {\n        storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null);\n        storageSetter(NHOST_REFRESH_TOKEN_KEY, null);\n        return __spreadValues({}, INITIAL_MACHINE_CONTEXT);\n      }),\n      clearContextExceptRefreshToken: assign(_ref28 => {\n        let {\n          refreshToken: {\n            value\n          }\n        } = _ref28;\n        storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null);\n        return __spreadProps(__spreadValues({}, INITIAL_MACHINE_CONTEXT), {\n          refreshToken: {\n            value\n          }\n        });\n      }),\n      saveSession: assign({\n        user: (_, _ref29) => {\n          let {\n            data\n          } = _ref29;\n          var _a;\n          return ((_a = data == null ? void 0 : data.session) == null ? void 0 : _a.user) || null;\n        },\n        accessToken: (_, _ref30) => {\n          let {\n            data\n          } = _ref30;\n          if (data.session) {\n            const {\n              accessTokenExpiresIn,\n              accessToken\n            } = data.session;\n            const nextRefresh = new Date(Date.now() + accessTokenExpiresIn * 1e3);\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, nextRefresh.toISOString());\n            return {\n              value: accessToken,\n              expiresAt: nextRefresh\n            };\n          }\n          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null);\n          return {\n            value: null,\n            expiresAt: null\n          };\n        },\n        refreshToken: (_, _ref31) => {\n          let {\n            data\n          } = _ref31;\n          var _a;\n          const refreshToken = ((_a = data.session) == null ? void 0 : _a.refreshToken) || null;\n          if (refreshToken) {\n            storageSetter(NHOST_REFRESH_TOKEN_KEY, refreshToken);\n          }\n          return {\n            value: refreshToken\n          };\n        }\n      }),\n      saveMfaTicket: assign({\n        mfa: (_, e) => {\n          var _a;\n          return (_a = e.data) == null ? void 0 : _a.mfa;\n        }\n      }),\n      resetTimer: assign({\n        refreshTimer: _ => ({\n          startedAt: new Date(),\n          attempts: 0,\n          lastAttempt: null\n        })\n      }),\n      saveRefreshAttempt: assign({\n        refreshTimer: (ctx, e) => ({\n          startedAt: ctx.refreshTimer.startedAt,\n          attempts: ctx.refreshTimer.attempts + 1,\n          lastAttempt: new Date()\n        })\n      }),\n      saveAuthenticationError: assign({\n        errors: (_ref32, _ref33) => {\n          let {\n            errors\n          } = _ref32;\n          let {\n            data: {\n              error\n            }\n          } = _ref33;\n          return __spreadProps(__spreadValues({}, errors), {\n            authentication: error\n          });\n        }\n      }),\n      resetErrors: assign({\n        errors: _ => ({})\n      }),\n      saveRegistrationError: assign({\n        errors: (_ref34, _ref35) => {\n          let {\n            errors\n          } = _ref34;\n          let {\n            data: {\n              error\n            }\n          } = _ref35;\n          return __spreadProps(__spreadValues({}, errors), {\n            registration: error\n          });\n        }\n      }),\n      destroyRefreshToken: assign({\n        refreshToken: _ => {\n          storageSetter(NHOST_REFRESH_TOKEN_KEY, null);\n          return {\n            value: null\n          };\n        }\n      }),\n      cleanUrl: () => {\n        if (autoSignIn && getParameterByName(\"refreshToken\")) {\n          removeParameterFromWindow(\"refreshToken\");\n          removeParameterFromWindow(\"type\");\n        }\n      },\n      broadcastToken: context => {\n        if (autoSignIn) {\n          try {\n            const channel = new BroadcastChannel(\"nhost\");\n            channel.postMessage(context.refreshToken.value);\n          } catch (error) {}\n        }\n      }\n    },\n    guards: {\n      isAnonymous: (ctx, e) => {\n        var _a;\n        return !!((_a = ctx.user) == null ? void 0 : _a.isAnonymous);\n      },\n      isSignedIn: ctx => !!ctx.user && !!ctx.refreshToken.value && !!ctx.accessToken.value,\n      noToken: ctx => !ctx.refreshToken.value,\n      hasRefreshToken: ctx => !!ctx.refreshToken.value,\n      isAutoRefreshDisabled: () => !autoRefreshToken,\n      refreshTimerShouldRefresh: ctx => {\n        const {\n          expiresAt\n        } = ctx.accessToken;\n        if (!expiresAt) {\n          return false;\n        }\n        if (ctx.refreshTimer.lastAttempt) {\n          const elapsed = Date.now() - ctx.refreshTimer.lastAttempt.getTime();\n          return elapsed > REFRESH_TOKEN_RETRY_INTERVAL * 1e3;\n        }\n        if (refreshIntervalTime) {\n          const elapsed = Date.now() - ctx.refreshTimer.startedAt.getTime();\n          if (elapsed > refreshIntervalTime * 1e3) {\n            return true;\n          }\n        }\n        const expiresIn = expiresAt.getTime() - Date.now();\n        const remaining = expiresIn - 1e3 * TOKEN_REFRESH_MARGIN;\n        return remaining <= 0;\n      },\n      unverified: (_, _ref36) => {\n        let {\n          data: {\n            error\n          }\n        } = _ref36;\n        return error.status === 401 && (error.message === \"Email is not verified\" || error.error === \"unverified-user\");\n      },\n      hasSession: (_, e) => {\n        var _a;\n        return !!((_a = e.data) == null ? void 0 : _a.session);\n      },\n      hasMfaTicket: (_, e) => {\n        var _a;\n        return !!((_a = e.data) == null ? void 0 : _a.mfa);\n      }\n    },\n    services: {\n      signInPassword: (_, _ref37) => {\n        let {\n          email,\n          password\n        } = _ref37;\n        if (!isValidEmail(email)) {\n          return Promise.reject({\n            error: INVALID_EMAIL_ERROR\n          });\n        }\n        if (!isValidPassword(password)) {\n          return Promise.reject({\n            error: INVALID_PASSWORD_ERROR\n          });\n        }\n        return postRequest(\"/signin/email-password\", {\n          email,\n          password\n        });\n      },\n      passwordlessSms: (context, _ref38) => {\n        let {\n          phoneNumber,\n          options\n        } = _ref38;\n        var _a;\n        if (!isValidPhoneNumber(phoneNumber)) {\n          return Promise.reject({\n            error: INVALID_PHONE_NUMBER_ERROR\n          });\n        }\n        if ((_a = context.user) == null ? void 0 : _a.isAnonymous) {\n          console.warn(\"Deanonymisation from a phone number is not yet implemented in hasura-auth\");\n          return postRequest(\"/user/deanonymize\", {\n            signInMethod: \"passwordless\",\n            connection: \"sms\",\n            phoneNumber,\n            options: rewriteRedirectTo(clientUrl, options)\n          }, {\n            headers: {\n              authorization: `Bearer ${context.accessToken.value}`\n            }\n          });\n        } else {\n          return postRequest(\"/signin/passwordless/sms\", {\n            phoneNumber,\n            options: rewriteRedirectTo(clientUrl, options)\n          });\n        }\n      },\n      passwordlessSmsOtp: (_, _ref39) => {\n        let {\n          phoneNumber,\n          otp\n        } = _ref39;\n        if (!isValidPhoneNumber(phoneNumber)) {\n          return Promise.reject({\n            error: INVALID_PHONE_NUMBER_ERROR\n          });\n        }\n        return postRequest(\"/signin/passwordless/sms/otp\", {\n          phoneNumber,\n          otp\n        });\n      },\n      passwordlessEmail: (context, _ref40) => {\n        let {\n          email,\n          options\n        } = _ref40;\n        var _a;\n        if (!isValidEmail(email)) {\n          return Promise.reject({\n            error: INVALID_EMAIL_ERROR\n          });\n        }\n        if ((_a = context.user) == null ? void 0 : _a.isAnonymous) {\n          return postRequest(\"/user/deanonymize\", {\n            signInMethod: \"passwordless\",\n            connection: \"email\",\n            email,\n            options: rewriteRedirectTo(clientUrl, options)\n          }, {\n            headers: {\n              authorization: `Bearer ${context.accessToken.value}`\n            }\n          });\n        } else {\n          return postRequest(\"/signin/passwordless/email\", {\n            email,\n            options: rewriteRedirectTo(clientUrl, options)\n          });\n        }\n      },\n      signInAnonymous: _ => postRequest(\"/signin/anonymous\"),\n      signInMfaTotp: (context, data) => {\n        var _a;\n        const ticket = data.ticket || ((_a = context.mfa) == null ? void 0 : _a.ticket);\n        if (!ticket) {\n          return Promise.reject({\n            error: NO_MFA_TICKET_ERROR\n          });\n        }\n        if (!isValidTicket(ticket)) {\n          return Promise.reject({\n            error: INVALID_MFA_TICKET_ERROR\n          });\n        }\n        return postRequest(\"/signin/mfa/totp\", {\n          ticket,\n          otp: data.otp\n        });\n      },\n      signInSecurityKeyEmail: async (_, _ref41) => {\n        let {\n          email\n        } = _ref41;\n        if (!isValidEmail(email)) {\n          throw new CodifiedError(INVALID_EMAIL_ERROR);\n        }\n        const options = await postRequest(\"/signin/webauthn\", {\n          email\n        });\n        let credential;\n        try {\n          credential = await startAuthentication(options);\n        } catch (e) {\n          throw new CodifiedError(e);\n        }\n        return postRequest(\"/signin/webauthn/verify\", {\n          email,\n          credential\n        });\n      },\n      refreshToken: async (ctx, event) => {\n        const refreshToken = event.type === \"TRY_TOKEN\" ? event.token : ctx.refreshToken.value;\n        const session = await postRequest(\"/token\", {\n          refreshToken\n        });\n        return {\n          session,\n          error: null\n        };\n      },\n      signout: (ctx, e) => postRequest(\"/signout\", {\n        refreshToken: ctx.refreshToken.value,\n        all: !!e.all\n      }),\n      signUpEmailPassword: async (context, _ref42) => {\n        let {\n          email,\n          password,\n          options\n        } = _ref42;\n        var _a;\n        if (!isValidEmail(email)) {\n          return Promise.reject({\n            error: INVALID_EMAIL_ERROR\n          });\n        }\n        if (!isValidPassword(password)) {\n          return Promise.reject({\n            error: INVALID_PASSWORD_ERROR\n          });\n        }\n        if ((_a = context.user) == null ? void 0 : _a.isAnonymous) {\n          return postRequest(\"/user/deanonymize\", {\n            signInMethod: \"email-password\",\n            email,\n            password,\n            options: rewriteRedirectTo(clientUrl, options)\n          }, {\n            headers: {\n              authorization: `Bearer ${context.accessToken.value}`\n            }\n          });\n        } else {\n          return postRequest(\"/signup/email-password\", {\n            email,\n            password,\n            options: rewriteRedirectTo(clientUrl, options)\n          });\n        }\n      },\n      signUpSecurityKey: async (_, _ref43) => {\n        let {\n          email,\n          options\n        } = _ref43;\n        if (!isValidEmail(email)) {\n          return Promise.reject({\n            error: INVALID_EMAIL_ERROR\n          });\n        }\n        const nickname = options == null ? void 0 : options.nickname;\n        if (nickname) delete options.nickname;\n        const webAuthnOptions = await postRequest(\"/signup/webauthn\", {\n          email,\n          options\n        });\n        let credential;\n        try {\n          credential = await startRegistration(webAuthnOptions);\n        } catch (e) {\n          throw new CodifiedError(e);\n        }\n        return postRequest(\"/signup/webauthn/verify\", {\n          credential,\n          options: {\n            redirectTo: options == null ? void 0 : options.redirectTo,\n            nickname\n          }\n        });\n      },\n      importRefreshToken: async () => {\n        let error = null;\n        if (autoSignIn) {\n          const urlToken = getParameterByName(\"refreshToken\") || null;\n          if (urlToken) {\n            try {\n              const session = await postRequest(\"/token\", {\n                refreshToken: urlToken\n              });\n              return {\n                session,\n                error: null\n              };\n            } catch (exception) {\n              error = exception.error;\n            }\n          } else {\n            const error2 = getParameterByName(\"error\");\n            if (error2) {\n              return Promise.reject({\n                session: null,\n                error: {\n                  status: VALIDATION_ERROR_CODE,\n                  error: error2,\n                  message: getParameterByName(\"errorDescription\") || error2\n                }\n              });\n            }\n          }\n        }\n        const storageToken = await storageGetter(NHOST_REFRESH_TOKEN_KEY);\n        if (storageToken) {\n          try {\n            const session = await postRequest(\"/token\", {\n              refreshToken: storageToken\n            });\n            return {\n              session,\n              error: null\n            };\n          } catch (exception) {\n            error = exception.error;\n          }\n        }\n        return Promise.reject({\n          error\n        });\n      }\n    }\n  });\n};\nclass AuthClient {\n  constructor(_a) {\n    var _b = _a,\n      {\n        clientStorageType = \"web\",\n        autoSignIn = true,\n        autoRefreshToken = true,\n        start = true,\n        backendUrl,\n        clientUrl,\n        devTools\n      } = _b,\n      defaultOptions = __objRest(_b, [\"clientStorageType\", \"autoSignIn\", \"autoRefreshToken\", \"start\", \"backendUrl\", \"clientUrl\", \"devTools\"]);\n    this._subscriptions = /* @__PURE__ */new Set();\n    this.backendUrl = backendUrl;\n    this.clientUrl = clientUrl;\n    this.machine = createAuthMachine(__spreadProps(__spreadValues({}, defaultOptions), {\n      backendUrl,\n      clientUrl,\n      clientStorageType,\n      autoSignIn,\n      autoRefreshToken\n    }));\n    if (start) {\n      this.interpreter = interpret(this.machine, {\n        devTools\n      });\n      this.interpreter.start();\n    }\n    if (typeof window !== \"undefined\" && autoSignIn) {\n      try {\n        this._channel = new BroadcastChannel(\"nhost\");\n        this._channel.addEventListener(\"message\", token => {\n          var _a2;\n          const existingToken = (_a2 = this.interpreter) == null ? void 0 : _a2.state.context.refreshToken.value;\n          if (this.interpreter && token.data !== existingToken) {\n            this.interpreter.send(\"TRY_TOKEN\", {\n              token: token.data\n            });\n          }\n        });\n      } catch (error) {}\n    }\n  }\n  get interpreter() {\n    return this._interpreter;\n  }\n  set interpreter(interpreter) {\n    this._interpreter = interpreter;\n    if (interpreter) {\n      this._subscriptions.forEach(fn => fn(this));\n    }\n  }\n  onStart(fn) {\n    if (this.interpreter) {\n      fn(this);\n    } else {\n      this._subscriptions.add(fn);\n    }\n  }\n}\nconst isBrowser = typeof window !== \"undefined\";\nclass AuthCookieClient extends AuthClient {\n  constructor(_c) {\n    var options = __objRest(_c, []);\n    super(__spreadProps(__spreadValues({}, options), {\n      autoSignIn: isBrowser && options.autoSignIn,\n      autoRefreshToken: isBrowser && options.autoRefreshToken,\n      clientStorageType: \"cookie\"\n    }));\n  }\n}\nconst AuthClientSSR = AuthCookieClient;\nconst addSecurityKeyPromise = async (_ref44, nickname) => {\n  let {\n    backendUrl,\n    interpreter\n  } = _ref44;\n  const api = nhostApiClient(backendUrl);\n  try {\n    const {\n      data: options\n    } = await api.post(\"/user/webauthn/add\", {}, {\n      headers: {\n        authorization: `Bearer ${interpreter == null ? void 0 : interpreter.state.context.accessToken.value}`\n      }\n    });\n    let credential;\n    try {\n      credential = await startRegistration(options);\n    } catch (e) {\n      throw new CodifiedError(e);\n    }\n    const {\n      data: key\n    } = await api.post(\"/user/webauthn/verify\", {\n      credential,\n      nickname\n    }, {\n      headers: {\n        authorization: `Bearer ${interpreter == null ? void 0 : interpreter.state.context.accessToken.value}`\n      }\n    });\n    return {\n      key,\n      isError: false,\n      error: null,\n      isSuccess: true\n    };\n  } catch (e) {\n    const {\n      error\n    } = e;\n    return {\n      isError: true,\n      error,\n      isSuccess: false\n    };\n  }\n};\nconst changeEmailPromise = async (interpreter, email, options) => new Promise(resolve => {\n  interpreter.send(\"REQUEST\", {\n    email,\n    options\n  });\n  interpreter.onTransition(s => {\n    if (s.matches({\n      idle: \"error\"\n    })) {\n      resolve({\n        error: s.context.error,\n        isError: true,\n        needsEmailVerification: false\n      });\n    } else if (s.matches({\n      idle: \"success\"\n    })) {\n      resolve({\n        error: null,\n        isError: false,\n        needsEmailVerification: true\n      });\n    }\n  });\n});\nconst changePasswordPromise = async (interpreter, password, ticket) => new Promise(resolve => {\n  interpreter.send(\"REQUEST\", {\n    password,\n    ticket\n  });\n  interpreter.onTransition(state => {\n    if (state.matches({\n      idle: \"error\"\n    })) {\n      resolve({\n        error: state.context.error,\n        isError: true,\n        isSuccess: false\n      });\n    } else if (state.matches({\n      idle: \"success\"\n    })) {\n      resolve({\n        error: null,\n        isError: false,\n        isSuccess: true\n      });\n    }\n  });\n});\nconst generateQrCodePromise = service => new Promise(resolve => {\n  service.send(\"GENERATE\");\n  service.onTransition(state => {\n    if (state.matches(\"generated\")) {\n      resolve({\n        error: null,\n        isError: false,\n        isGenerated: true,\n        qrCodeDataUrl: state.context.imageUrl || \"\"\n      });\n    } else if (state.matches({\n      idle: \"error\"\n    })) {\n      resolve({\n        error: state.context.error || null,\n        isError: true,\n        isGenerated: false,\n        qrCodeDataUrl: \"\"\n      });\n    }\n  });\n});\nconst activateMfaPromise = (service, code) => new Promise(resolve => {\n  service.send(\"ACTIVATE\", {\n    activeMfaType: \"totp\",\n    code\n  });\n  service.onTransition(state => {\n    if (state.matches({\n      generated: \"activated\"\n    })) {\n      resolve({\n        error: null,\n        isActivated: true,\n        isError: false\n      });\n    } else if (state.matches({\n      generated: {\n        idle: \"error\"\n      }\n    })) {\n      resolve({\n        error: state.context.error,\n        isActivated: false,\n        isError: true\n      });\n    }\n  });\n});\nconst resetPasswordPromise = async (interpreter, email, options) => new Promise(resolve => {\n  interpreter.send(\"REQUEST\", {\n    email,\n    options\n  });\n  interpreter.onTransition(state => {\n    if (state.matches({\n      idle: \"error\"\n    })) {\n      resolve({\n        error: state.context.error,\n        isError: true,\n        isSent: false\n      });\n    } else if (state.matches({\n      idle: \"success\"\n    })) {\n      resolve({\n        error: null,\n        isError: false,\n        isSent: true\n      });\n    }\n  });\n});\nconst sendVerificationEmailPromise = (interpreter, email, options) => new Promise(resolve => {\n  interpreter.send(\"REQUEST\", {\n    email,\n    options\n  });\n  interpreter.onTransition(state => {\n    if (state.matches({\n      idle: \"error\"\n    })) {\n      resolve({\n        error: state.context.error,\n        isError: true,\n        isSent: false\n      });\n    } else if (state.matches({\n      idle: \"success\"\n    })) {\n      resolve({\n        error: null,\n        isError: false,\n        isSent: true\n      });\n    }\n  });\n});\nconst signInAnonymousPromise = interpreter => new Promise(resolve => {\n  const {\n    changed\n  } = interpreter.send(\"SIGNIN_ANONYMOUS\");\n  if (!changed) {\n    resolve({\n      isSuccess: false,\n      isError: true,\n      error: USER_ALREADY_SIGNED_IN,\n      user: null,\n      accessToken: null\n    });\n  }\n  interpreter.onTransition(state => {\n    if (state.matches({\n      authentication: \"signedIn\"\n    })) {\n      resolve({\n        isSuccess: true,\n        isError: false,\n        error: null,\n        user: state.context.user,\n        accessToken: state.context.accessToken.value\n      });\n    }\n    if (state.matches({\n      authentication: {\n        signedOut: \"failed\"\n      }\n    })) {\n      resolve({\n        isSuccess: false,\n        isError: true,\n        error: state.context.errors.authentication || null,\n        user: null,\n        accessToken: null\n      });\n    }\n  });\n});\nconst signInEmailPasswordPromise = (interpreter, email, password) => new Promise(resolve => {\n  const {\n    changed,\n    context\n  } = interpreter.send(\"SIGNIN_PASSWORD\", {\n    email,\n    password\n  });\n  if (!changed) {\n    return resolve({\n      accessToken: context.accessToken.value,\n      error: USER_ALREADY_SIGNED_IN,\n      isError: true,\n      isSuccess: false,\n      needsEmailVerification: false,\n      needsMfaOtp: false,\n      mfa: null,\n      user: context.user\n    });\n  }\n  interpreter.onTransition(state => {\n    if (state.matches({\n      authentication: {\n        signedOut: \"noErrors\"\n      },\n      registration: {\n        incomplete: \"needsEmailVerification\"\n      }\n    })) {\n      resolve({\n        accessToken: null,\n        error: null,\n        isError: false,\n        isSuccess: false,\n        needsEmailVerification: true,\n        needsMfaOtp: false,\n        mfa: null,\n        user: null\n      });\n    } else if (state.matches({\n      authentication: {\n        signedOut: \"needsMfa\"\n      }\n    })) {\n      resolve({\n        accessToken: null,\n        error: null,\n        isError: false,\n        isSuccess: false,\n        needsEmailVerification: false,\n        needsMfaOtp: true,\n        mfa: state.context.mfa,\n        user: null\n      });\n    } else if (state.matches({\n      authentication: {\n        signedOut: \"failed\"\n      }\n    })) {\n      resolve({\n        accessToken: null,\n        error: state.context.errors.authentication || null,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        needsMfaOtp: false,\n        mfa: null,\n        user: null\n      });\n    } else if (state.matches({\n      authentication: \"signedIn\"\n    })) {\n      resolve({\n        accessToken: state.context.accessToken.value,\n        error: null,\n        isError: false,\n        isSuccess: true,\n        needsEmailVerification: false,\n        needsMfaOtp: false,\n        mfa: null,\n        user: state.context.user\n      });\n    }\n  });\n});\nconst signInEmailPasswordlessPromise = (interpreter, email, options) => new Promise(resolve => {\n  const {\n    changed\n  } = interpreter.send(\"PASSWORDLESS_EMAIL\", {\n    email,\n    options\n  });\n  if (!changed) {\n    return resolve({\n      error: USER_ALREADY_SIGNED_IN,\n      isError: true,\n      isSuccess: false\n    });\n  }\n  interpreter.onTransition(state => {\n    if (state.matches(\"registration.incomplete.failed\")) {\n      resolve({\n        error: state.context.errors.registration || null,\n        isError: true,\n        isSuccess: false\n      });\n    } else if (state.matches({\n      authentication: {\n        signedOut: \"noErrors\"\n      },\n      registration: {\n        incomplete: \"needsEmailVerification\"\n      }\n    })) {\n      resolve({\n        error: null,\n        isError: false,\n        isSuccess: true\n      });\n    }\n  });\n});\nconst signInEmailSecurityKeyPromise = (interpreter, email) => new Promise(resolve => {\n  const {\n    changed,\n    context\n  } = interpreter.send({\n    type: \"SIGNIN_SECURITY_KEY_EMAIL\",\n    email\n  });\n  if (!changed) {\n    return resolve({\n      accessToken: context.accessToken.value,\n      error: USER_ALREADY_SIGNED_IN,\n      isError: true,\n      isSuccess: false,\n      needsEmailVerification: false,\n      user: context.user\n    });\n  }\n  interpreter.onTransition(state => {\n    if (state.matches({\n      authentication: {\n        signedOut: \"noErrors\"\n      },\n      registration: {\n        incomplete: \"needsEmailVerification\"\n      }\n    })) {\n      resolve({\n        accessToken: null,\n        error: null,\n        isError: false,\n        isSuccess: false,\n        needsEmailVerification: true,\n        user: null\n      });\n    } else if (state.matches({\n      authentication: {\n        signedOut: \"failed\"\n      }\n    })) {\n      resolve({\n        accessToken: null,\n        error: state.context.errors.authentication || null,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: null\n      });\n    } else if (state.matches({\n      authentication: \"signedIn\"\n    })) {\n      resolve({\n        accessToken: state.context.accessToken.value,\n        error: null,\n        isError: false,\n        isSuccess: true,\n        needsEmailVerification: false,\n        user: state.context.user\n      });\n    }\n  });\n});\nconst signInMfaTotpPromise = (interpreter, otp, ticket) => new Promise(resolve => {\n  const {\n    changed,\n    context\n  } = interpreter.send(\"SIGNIN_MFA_TOTP\", {\n    otp,\n    ticket\n  });\n  if (!changed) {\n    return resolve({\n      accessToken: context.accessToken.value,\n      error: USER_ALREADY_SIGNED_IN,\n      isError: true,\n      isSuccess: false,\n      user: context.user\n    });\n  }\n  interpreter.onTransition(state => {\n    if (state.matches({\n      authentication: {\n        signedOut: \"failed\"\n      }\n    })) {\n      resolve({\n        accessToken: null,\n        error: state.context.errors.authentication || null,\n        isError: true,\n        isSuccess: false,\n        user: null\n      });\n    } else if (state.matches({\n      authentication: \"signedIn\"\n    })) {\n      resolve({\n        accessToken: state.context.accessToken.value,\n        error: null,\n        isError: false,\n        isSuccess: true,\n        user: state.context.user\n      });\n    }\n  });\n});\nconst signInSmsPasswordlessPromise = (interpreter, phoneNumber, options) => new Promise(resolve => {\n  const {\n    changed\n  } = interpreter.send(\"PASSWORDLESS_SMS\", {\n    phoneNumber,\n    options\n  });\n  if (!changed) {\n    return resolve({\n      error: USER_ALREADY_SIGNED_IN,\n      isError: true,\n      isSuccess: false,\n      needsOtp: false\n    });\n  }\n  interpreter.onTransition(state => {\n    if (state.matches(\"registration.incomplete.needsOtp\")) {\n      resolve({\n        error: null,\n        isError: false,\n        isSuccess: false,\n        needsOtp: true\n      });\n    } else if (state.matches(\"registration.incomplete.failed\")) {\n      resolve({\n        error: state.context.errors.authentication || null,\n        isError: true,\n        isSuccess: false,\n        needsOtp: false\n      });\n    }\n  });\n});\nconst signInSmsPasswordlessOtpPromise = (interpreter, phoneNumber, otp) => new Promise(resolve => {\n  const {\n    changed\n  } = interpreter.send({\n    type: \"PASSWORDLESS_SMS_OTP\",\n    phoneNumber,\n    otp\n  });\n  if (!changed) {\n    return resolve({\n      error: USER_ALREADY_SIGNED_IN,\n      isError: true,\n      isSuccess: false,\n      user: null,\n      accessToken: null\n    });\n  }\n  interpreter.onTransition(state => {\n    if (state.matches({\n      authentication: \"signedIn\"\n    })) {\n      resolve({\n        error: null,\n        isError: false,\n        isSuccess: true,\n        user: state.context.user,\n        accessToken: state.context.accessToken.value\n      });\n    } else if (state.matches({\n      registration: {\n        incomplete: \"failed\"\n      }\n    })) {\n      resolve({\n        error: state.context.errors.authentication || null,\n        isError: true,\n        isSuccess: false,\n        user: null,\n        accessToken: null\n      });\n    }\n  });\n});\nconst signOutPromise = async (interpreter, all) => new Promise(resolve => {\n  const {\n    event\n  } = interpreter.send(\"SIGNOUT\", {\n    all\n  });\n  if (event.type !== \"SIGNED_OUT\") {\n    return resolve({\n      isSuccess: false,\n      isError: true,\n      error: USER_UNAUTHENTICATED\n    });\n  }\n  interpreter.onTransition(state => {\n    if (state.matches({\n      authentication: {\n        signedOut: \"success\"\n      }\n    })) {\n      resolve({\n        isSuccess: true,\n        isError: false,\n        error: null\n      });\n    } else if (state.matches(\"authentication.signedOut.failed\")) {\n      resolve({\n        isSuccess: false,\n        isError: true,\n        error: state.context.errors.signout || null\n      });\n    }\n  });\n});\nconst signUpEmailPasswordPromise = (interpreter, email, password, options) => new Promise(resolve => {\n  const {\n    changed,\n    context\n  } = interpreter.send(\"SIGNUP_EMAIL_PASSWORD\", {\n    email,\n    password,\n    options\n  });\n  if (!changed) {\n    return resolve({\n      error: USER_ALREADY_SIGNED_IN,\n      accessToken: context.accessToken.value,\n      isError: true,\n      isSuccess: false,\n      needsEmailVerification: false,\n      user: context.user\n    });\n  }\n  interpreter.onTransition(state => {\n    if (state.matches(\"registration.incomplete.failed\")) {\n      resolve({\n        accessToken: null,\n        error: state.context.errors.registration || null,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: null\n      });\n    } else if (state.matches({\n      authentication: {\n        signedOut: \"noErrors\"\n      },\n      registration: {\n        incomplete: \"needsEmailVerification\"\n      }\n    })) {\n      resolve({\n        accessToken: null,\n        error: null,\n        isError: false,\n        isSuccess: false,\n        needsEmailVerification: true,\n        user: null\n      });\n    } else if (state.matches({\n      authentication: \"signedIn\",\n      registration: \"complete\"\n    })) {\n      resolve({\n        accessToken: state.context.accessToken.value,\n        error: null,\n        isError: false,\n        isSuccess: true,\n        needsEmailVerification: false,\n        user: state.context.user\n      });\n    }\n  });\n});\nconst signUpEmailSecurityKeyPromise = (interpreter, email, options) => new Promise(resolve => {\n  const {\n    changed,\n    context\n  } = interpreter.send(\"SIGNUP_SECURITY_KEY\", {\n    email,\n    options\n  });\n  if (!changed) {\n    return resolve({\n      error: USER_ALREADY_SIGNED_IN,\n      accessToken: context.accessToken.value,\n      isError: true,\n      isSuccess: false,\n      needsEmailVerification: false,\n      user: context.user\n    });\n  }\n  interpreter.onTransition(state => {\n    if (state.matches(\"registration.incomplete.failed\")) {\n      resolve({\n        accessToken: null,\n        error: state.context.errors.registration || null,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: null\n      });\n    } else if (state.matches({\n      authentication: {\n        signedOut: \"noErrors\"\n      },\n      registration: {\n        incomplete: \"needsEmailVerification\"\n      }\n    })) {\n      resolve({\n        accessToken: null,\n        error: null,\n        isError: false,\n        isSuccess: false,\n        needsEmailVerification: true,\n        user: null\n      });\n    } else if (state.matches({\n      authentication: \"signedIn\",\n      registration: \"complete\"\n    })) {\n      resolve({\n        accessToken: state.context.accessToken.value,\n        error: null,\n        isError: false,\n        isSuccess: true,\n        needsEmailVerification: false,\n        user: state.context.user\n      });\n    }\n  });\n});\nexport { AuthClient, AuthClientSSR, AuthCookieClient, CodifiedError, EMAIL_NEEDS_VERIFICATION, INVALID_EMAIL_ERROR, INVALID_MFA_CODE_ERROR, INVALID_MFA_TICKET_ERROR, INVALID_MFA_TYPE_ERROR, INVALID_PASSWORD_ERROR, INVALID_PHONE_NUMBER_ERROR, INVALID_REFRESH_TOKEN, MIN_PASSWORD_LENGTH, NETWORK_ERROR_CODE, NHOST_JWT_EXPIRES_AT_KEY, NHOST_REFRESH_TOKEN_KEY, NO_MFA_TICKET_ERROR, NO_REFRESH_TOKEN, OTHER_ERROR_CODE, REFRESH_TOKEN_RETRY_INTERVAL, REFRESH_TOKEN_RETRY_MAX_ATTEMPTS, STATE_ERROR_CODE, TOKEN_REFRESHER_RUNNING_ERROR, TOKEN_REFRESH_MARGIN, USER_ALREADY_SIGNED_IN, USER_NOT_ANONYMOUS, USER_UNAUTHENTICATED, VALIDATION_ERROR_CODE, activateMfaPromise, addSecurityKeyPromise, changeEmailPromise, changePasswordPromise, createAuthMachine, createChangeEmailMachine, createChangePasswordMachine, createEnableMfaMachine, createResetPasswordMachine, createSendVerificationEmailMachine, encodeQueryParameters, generateQrCodePromise, getParameterByName, localStorageGetter, localStorageSetter, removeParameterFromWindow, resetPasswordPromise, rewriteRedirectTo, sendVerificationEmailPromise, signInAnonymousPromise, signInEmailPasswordPromise, signInEmailPasswordlessPromise, signInEmailSecurityKeyPromise, signInMfaTotpPromise, signInSmsPasswordlessOtpPromise, signInSmsPasswordlessPromise, signOutPromise, signUpEmailPasswordPromise, signUpEmailSecurityKeyPromise };","map":{"version":3,"mappings":"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","names":["value","TextEncoder","encode","buffer","bytes","Uint8Array","str","charCode","String","fromCharCode","base64String","btoa","replace","base64URLString","base64","padLength","length","padded","padEnd","binary","atob","ArrayBuffer","i","charCodeAt","window","PublicKeyCredential","descriptor","id","__spreadProps","base64URLStringToBuffer","transports","hostname","test","WebAuthnError","Error","constructor","message","name","error","options","_a","_b","publicKey","signal","AbortController","authenticatorSelection","requireResidentKey","userVerification","validPubKeyCredParams","pubKeyCredParams","filter","param","type","effectiveDomain","location","isValidDomain","rp","user","byteLength","WebAuthnAbortService","createNewAbortSignal","controller","abort","reset","webauthnAbortService","creationOptionsJSON","browserSupportsWebAuthn","challenge","utf8StringToBuffer","excludeCredentials","map","toPublicKeyCredentialDescriptor","credential","navigator","credentials","create","err","identifyRegistrationError","rawId","response","credentialJSON","bufferToBase64URLString","attestationObject","clientDataJSON","clientExtensionResults","getClientExtensionResults","authenticatorAttachment","getTransports","TextDecoder","decode","conditionalMediationSupported","globalPublicKeyCredential","isConditionalMediationAvailable","allowCredentials","rpId","requestOptionsJSON","useBrowserAutofill","browserSupportsWebAuthnAutofill","eligibleInputs","document","querySelectorAll","mediation","get","identifyAuthenticationError","userHandle","bufferToUTF8String","authenticatorData","signature","NHOST_REFRESH_TOKEN_KEY","NHOST_JWT_EXPIRES_AT_KEY","MIN_PASSWORD_LENGTH","TOKEN_REFRESH_MARGIN","REFRESH_TOKEN_RETRY_INTERVAL","REFRESH_TOKEN_RETRY_MAX_ATTEMPTS","NETWORK_ERROR_CODE","OTHER_ERROR_CODE","VALIDATION_ERROR_CODE","STATE_ERROR_CODE","CodifiedError","original","status","INVALID_EMAIL_ERROR","INVALID_MFA_TYPE_ERROR","INVALID_MFA_CODE_ERROR","INVALID_PASSWORD_ERROR","INVALID_PHONE_NUMBER_ERROR","INVALID_MFA_TICKET_ERROR","NO_MFA_TICKET_ERROR","NO_REFRESH_TOKEN","TOKEN_REFRESHER_RUNNING_ERROR","USER_ALREADY_SIGNED_IN","USER_UNAUTHENTICATED","USER_NOT_ANONYMOUS","EMAIL_NEEDS_VERIFICATION","INVALID_REFRESH_TOKEN","backendUrl","client","axios","baseURL","use","reject","data","request","responseText","JSON","stringify","statusCode","statusText","isBrowser","inMemoryLocalStorage","Map","defaultClientStorageGetter","key","localStorage","getItem","defaultClientStorageSetter","removeItem","has","delete","clientStorageType","clientStorage","getItemAsync","Cookies","set","expires","remove","setItem","setItemAsync","deleteItemAsync","baseUrl","parameters","Object","entries","stringValue","Array","isArray","join","encodeURIComponent","encodedParameters","clientUrl","redirectTo","otherOptions","startsWith","URL","clientParams","fromEntries","URLSearchParams","baseClientUrl","search","origin","additionalParams","url","combinedParams","pathName","pathname","slice","encodeQueryParameters","href","RegExp","results","regex","exec","decodeURIComponent","hash","from","toString","history","pushState","isValidEmail","email","toLowerCase","match","password","isValidPhoneNumber","phoneNumber","ticket","INITIAL_MACHINE_CONTEXT","mfa","accessToken","expiresAt","refreshTimer","startedAt","attempts","lastAttempt","refreshToken","errors","createChangeEmailMachine","interpreter","nhostApiClient","createMachine","schema","context","events","services","tsTypes","preserveActionOrder","initial","states","idle","on","REQUEST","cond","actions","target","success","requesting","invoke","src","onDone","onError","saveInvalidEmailError","assign","_","saveRequestError","reportError","send","ctx","reportSuccess","guards","invalidEmail","requestChange","res","api","post","newEmail","rewriteRedirectTo","headers","authorization","state","createChangePasswordMachine","saveInvalidPasswordError","invalidPassword","isValidPassword","newPassword","createEnableMfaMachine","imageUrl","secret","GENERATE","generating","generated","ACTIVATE","activating","activated","saveInvalidMfaTypeError","saveInvalidMfaCodeError","saveError","saveGeneration","totpSecret","reportGeneratedSuccess","reportGeneratedError","invalidMfaCode","code","invalidMfaType","activeMfaType","generate","activate","createResetPasswordMachine","createSendVerificationEmailMachine","createAuthMachine","clientStorageGetter","clientStorageSetter","refreshIntervalTime","autoRefreshToken","autoSignIn","storageGetter","localStorageGetter","storageSetter","localStorageSetter","postRequest","config","result","authentication","SESSION_UPDATE","starting","entry","tags","always","signedOut","noErrors","needsSmsOtp","needsMfa","failed","signingOut","exit","SIGNIN_PASSWORD","SIGNIN_ANONYMOUS","SIGNIN_SECURITY_KEY_EMAIL","SIGNIN_MFA_TOTP","authenticating","anonymous","totp","securityKeyEmail","signedIn","SIGNOUT","disabled","stopped","running","pending","after","internal","refreshing","token","TRY_TOKEN","registration","SIGNED_IN","incomplete","SIGNUP_EMAIL_PASSWORD","SIGNUP_SECURITY_KEY","PASSWORDLESS_EMAIL","PASSWORDLESS_SMS","PASSWORDLESS_SMS_OTP","needsEmailVerification","needsOtp","emailPassword","securityKey","passwordlessEmail","passwordlessSms","passwordlessSmsOtp","complete","SIGNED_OUT","reportSignedIn","reportSignedOut","reportTokenChanged","clearContext","clearContextExceptRefreshToken","saveSession","session","accessTokenExpiresIn","nextRefresh","Date","now","toISOString","saveMfaTicket","e","resetTimer","saveRefreshAttempt","saveAuthenticationError","resetErrors","saveRegistrationError","destroyRefreshToken","cleanUrl","getParameterByName","removeParameterFromWindow","broadcastToken","BroadcastChannel","channel","isAnonymous","isSignedIn","noToken","hasRefreshToken","isAutoRefreshDisabled","refreshTimerShouldRefresh","elapsed","getTime","expiresIn","remaining","unverified","hasSession","hasMfaTicket","signInPassword","Promise","console","warn","signInMethod","connection","otp","signInAnonymous","signInMfaTotp","isValidTicket","signInSecurityKeyEmail","startAuthentication","event","signout","all","signUpEmailPassword","signUpSecurityKey","nickname","webAuthnOptions","startRegistration","importRefreshToken","urlToken","exception","error2","storageToken","AuthClient","start","devTools","defaultOptions","Set","machine","interpret","_channel","addEventListener","existingToken","_interpreter","_subscriptions","forEach","fn","onStart","add","AuthCookieClient","_c","AuthClientSSR","addSecurityKeyPromise","isError","isSuccess","resolve","s","matches","generateQrCodePromise","service","isGenerated","qrCodeDataUrl","activateMfaPromise","isActivated","isSent","signInAnonymousPromise","changed","needsMfaOtp","signInEmailSecurityKeyPromise","signOutPromise"],"sources":["C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\node_modules\\.pnpm\\@simplewebauthn+browser@6.0.0\\node_modules\\@simplewebauthn\\browser\\dist\\bundle\\index.js","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\constants.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\errors.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\hasura-auth.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\storage.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\utils.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\validators.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\machines\\context.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\machines\\change-email.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\machines\\change-password.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\machines\\enable-mfa.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\machines\\reset-password.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\machines\\send-verification-email.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\machines\\index.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\client.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\cookie-client.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\addSecurityKey.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\changeEmail.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\changePassword.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\mfa.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\resetPassword.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\sendVerificationEmail.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signInAnonymous.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signInEmailPassword.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signInEmailPasswordless.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signInEmailSecurityKey.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signInMfaTotp.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signInSmsPasswordless.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signInSmsPasswordlessOtp.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signOut.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signUpEmailPassword.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\core\\src\\promises\\signUpEmailSecurityKey.ts"],"sourcesContent":["/* [@simplewebauthn/browser@6.0.0] */\nfunction utf8StringToBuffer(value) {\n    return new TextEncoder().encode(value);\n}\n\nfunction bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction base64URLStringToBuffer(base64URLString) {\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    const binary = atob(padded);\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n\nfunction browserSupportsWebAuthn() {\n    return ((window === null || window === void 0 ? void 0 : window.PublicKeyCredential) !== undefined && typeof window.PublicKeyCredential === 'function');\n}\n\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        transports: descriptor.transports,\n    };\n}\n\nfunction isValidDomain(hostname) {\n    return (hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n\nclass WebAuthnError extends Error {\n    constructor(message, name = 'WebAuthnError') {\n        super(message);\n        this.name = name;\n    }\n}\n\nfunction identifyRegistrationError({ error, options, }) {\n    var _a, _b;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal === new AbortController().signal) {\n            return new WebAuthnError('Registration ceremony was sent an abort signal', 'AbortError');\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {\n            return new WebAuthnError('Discoverable credentials were required but no available authenticator supported it', 'ConstraintError');\n        }\n        else if (((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === 'required') {\n            return new WebAuthnError('User verification was required but no available authenticator supported it', 'ConstraintError');\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        return new WebAuthnError('The authenticator was previously registered', 'InvalidStateError');\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError('User clicked cancel, or the registration ceremony timed out', 'NotAllowedError');\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter(param => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            return new WebAuthnError('No entry in pubKeyCredParams was of type \"public-key\"', 'NotSupportedError');\n        }\n        return new WebAuthnError('No available authenticator supported any of the specified pubKeyCredParams algorithms', 'NotSupportedError');\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError(`${window.location.hostname} is an invalid domain`, 'SecurityError');\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            return new WebAuthnError(`The RP ID \"${publicKey.rp.id}\" is invalid for this domain`, 'SecurityError');\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            return new WebAuthnError('User ID was not between 1 and 64 characters', 'TypeError');\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError('The authenticator was unable to process the specified options, or could not create a new credential', 'UnknownError');\n    }\n    return error;\n}\n\nclass WebAuthnAbortService {\n    createNewAbortSignal() {\n        if (this.controller) {\n            this.controller.abort();\n        }\n        this.controller = new AbortController();\n        return this.controller.signal;\n    }\n    reset() {\n        this.controller = undefined;\n    }\n}\nconst webauthnAbortService = new WebAuthnAbortService();\n\nasync function startRegistration(creationOptionsJSON) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    const publicKey = {\n        ...creationOptionsJSON,\n        challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n        user: {\n            ...creationOptionsJSON.user,\n            id: utf8StringToBuffer(creationOptionsJSON.user.id),\n        },\n        excludeCredentials: creationOptionsJSON.excludeCredentials.map(toPublicKeyCredentialDescriptor),\n    };\n    const options = { publicKey };\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(options));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options });\n    }\n    finally {\n        webauthnAbortService.reset();\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    const credentialJSON = {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: credential.authenticatorAttachment,\n    };\n    if (typeof response.getTransports === 'function') {\n        credentialJSON.transports = response.getTransports();\n    }\n    return credentialJSON;\n}\n\nfunction bufferToUTF8String(value) {\n    return new TextDecoder('utf-8').decode(value);\n}\n\nasync function browserSupportsWebAuthnAutofill() {\n    if (navigator.credentials.conditionalMediationSupported) {\n        return true;\n    }\n    const globalPublicKeyCredential = window.PublicKeyCredential;\n    return (globalPublicKeyCredential.isConditionalMediationAvailable !== undefined &&\n        globalPublicKeyCredential.isConditionalMediationAvailable());\n}\n\nfunction identifyAuthenticationError({ error, options, }) {\n    var _a;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal === new AbortController().signal) {\n            return new WebAuthnError('Authentication ceremony was sent an abort signal', 'AbortError');\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        if ((_a = publicKey.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) {\n            return new WebAuthnError('No available authenticator recognized any of the allowed credentials', 'NotAllowedError');\n        }\n        return new WebAuthnError('User clicked cancel, or the authentication ceremony timed out', 'NotAllowedError');\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError(`${window.location.hostname} is an invalid domain`, 'SecurityError');\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            return new WebAuthnError(`The RP ID \"${publicKey.rpId}\" is invalid for this domain`, 'SecurityError');\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError('The authenticator was unable to process the specified options, or could not create a new assertion signature', 'UnknownError');\n    }\n    return error;\n}\n\nasync function startAuthentication(requestOptionsJSON, useBrowserAutofill = false) {\n    var _a, _b;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    let allowCredentials;\n    if (((_a = requestOptionsJSON.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) !== 0) {\n        allowCredentials = (_b = requestOptionsJSON.allowCredentials) === null || _b === void 0 ? void 0 : _b.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n        ...requestOptionsJSON,\n        challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n        allowCredentials,\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete*='webauthn']\");\n        if (eligibleInputs.length < 1) {\n            throw Error('No <input> with `\"webauthn\"` in its `autocomplete` attribute was detected');\n        }\n        options.mediation = 'conditional';\n        publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(options));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options });\n    }\n    finally {\n        webauthnAbortService.reset();\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToUTF8String(response.userHandle);\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: credential.authenticatorAttachment,\n    };\n}\n\nasync function platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return false;\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport { browserSupportsWebAuthn, browserSupportsWebAuthnAutofill, platformAuthenticatorIsAvailable, startAuthentication, startRegistration };\n","export const NHOST_REFRESH_TOKEN_KEY = 'nhostRefreshToken'\nexport const NHOST_JWT_EXPIRES_AT_KEY = 'nhostRefreshTokenExpiresAt'\n\nexport const MIN_PASSWORD_LENGTH = 3\n\n/**\n * Minimum time in seconds between now and the JWT expiration time before the JWT is refreshed\n * For instance, if set to 60, the client will refresh the JWT one minute before it expires\n */\nexport const TOKEN_REFRESH_MARGIN = 300 // five minutes\n\n/** Number of seconds before retrying a token refresh after an error */\nexport const REFRESH_TOKEN_RETRY_INTERVAL = 5\n\n// TODO not yet implemented\n// TODO try when offline for a long time: maybe we could keep state as 'signedIn'\n/** Maximum number of attempts to refresh a token before stopping the timer and logging out */\nexport const REFRESH_TOKEN_RETRY_MAX_ATTEMPTS = 30\n","export const NETWORK_ERROR_CODE = 0\nexport const OTHER_ERROR_CODE = 1\nexport const VALIDATION_ERROR_CODE = 10\nexport const STATE_ERROR_CODE = 20\n\nexport type ErrorPayload = {\n  error: string\n  status: number\n  message: string\n}\n\n/**\n * @internal\n * Adds a standard error payload to any JS Error, or convert a standard error payload into a JS Error.\n * Allows xstate to use `throw` instead of `Promise.reject` to propagate errors.\n * See https://github.com/statelyai/xstate/issues/3037\n */\nexport class CodifiedError extends Error {\n  error: ErrorPayload\n  constructor(original: Error | ErrorPayload) {\n    super(original.message)\n    Error.captureStackTrace(this, this.constructor)\n    if (original instanceof Error) {\n      this.name = original.name\n      this.error = {\n        error: original.name,\n        status: OTHER_ERROR_CODE,\n        message: original.message\n      }\n    } else {\n      this.name = original.error\n      this.error = original\n    }\n  }\n}\n\nexport type ValidationErrorPayload = ErrorPayload & { status: typeof VALIDATION_ERROR_CODE }\n\n// TODO share with hasura-auth\nexport const INVALID_EMAIL_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-email',\n  message: 'Email is incorrectly formatted'\n}\n\nexport const INVALID_MFA_TYPE_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-type',\n  message: 'MFA type is invalid'\n}\n\nexport const INVALID_MFA_CODE_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-code',\n  message: 'MFA code is invalid'\n}\n\nexport const INVALID_PASSWORD_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-password',\n  message: 'Password is incorrectly formatted'\n}\n\nexport const INVALID_PHONE_NUMBER_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-phone-number',\n  message: 'Phone number is incorrectly formatted'\n}\n\nexport const INVALID_MFA_TICKET_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-ticket',\n  message: 'MFA ticket is invalid'\n}\n\nexport const NO_MFA_TICKET_ERROR: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'no-mfa-ticket',\n  message: 'No MFA ticket has been provided'\n}\n\nexport const NO_REFRESH_TOKEN: ValidationErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'no-refresh-token',\n  message: 'No refresh token has been provided'\n}\n\nexport const TOKEN_REFRESHER_RUNNING_ERROR: ErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'refresher-already-running',\n  message:\n    'The token refresher is already running. You must wait until is has finished before submitting a new token.'\n}\n\nexport const USER_ALREADY_SIGNED_IN: ErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'already-signed-in',\n  message: 'User is already signed in'\n}\n\nexport const USER_UNAUTHENTICATED: ErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'unauthenticated-user',\n  message: 'User is not authenticated'\n}\n\nexport const USER_NOT_ANONYMOUS: ErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'user-not-anonymous',\n  message: 'User is not anonymous'\n}\n\nexport const EMAIL_NEEDS_VERIFICATION: ErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'unverified-user',\n  message: 'Email needs verification'\n}\n\nexport const INVALID_REFRESH_TOKEN = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-refresh-token',\n  message: 'Invalid or expired refresh token'\n}\n","import axios, { AxiosError } from 'axios'\n\nimport { ErrorPayload, NETWORK_ERROR_CODE } from './errors'\n\nexport const nhostApiClient = (backendUrl: string) => {\n  const client = axios.create({ baseURL: backendUrl })\n\n  client.interceptors.response.use(\n    (response) => response,\n    (error: AxiosError<{ message: string; error?: string; statusCode?: number }>) =>\n      Promise.reject<{ error: ErrorPayload }>({\n        error: {\n          message:\n            error.response?.data?.message ??\n            error.message ??\n            error.request.responseText ??\n            JSON.stringify(error),\n          status: error.response?.status ?? error.response?.data.statusCode ?? NETWORK_ERROR_CODE,\n          error: error.response?.data.error || error.request.statusText || 'network'\n        }\n      })\n  )\n  return client\n}\n","import Cookies from 'js-cookie'\n\nimport { ClientStorage, ClientStorageType } from './types'\nexport type StorageGetter = (key: string) => string | null | Promise<string | null>\nexport type StorageSetter = (key: string, value: string | null) => void | Promise<void>\n\nconst isBrowser = typeof window !== 'undefined'\n\nconst inMemoryLocalStorage: Map<string, string | null> = new Map()\n\nconst defaultClientStorageGetter: StorageGetter = (key) => {\n  if (isBrowser && typeof localStorage !== 'undefined') return localStorage.getItem(key)\n  else return inMemoryLocalStorage.get(key) ?? null\n}\n\nconst defaultClientStorageSetter: StorageSetter = (key, value) => {\n  if (isBrowser && typeof localStorage !== 'undefined') {\n    if (value) {\n      localStorage.setItem(key, value)\n    } else {\n      localStorage.removeItem(key)\n    }\n  } else {\n    if (value) {\n      inMemoryLocalStorage.set(key, value)\n    } else if (inMemoryLocalStorage.has(key)) {\n      inMemoryLocalStorage.delete(key)\n    }\n  }\n}\n\nexport const localStorageGetter = (\n  clientStorageType: ClientStorageType,\n  clientStorage?: ClientStorage\n): StorageGetter => {\n  if (clientStorageType === 'localStorage' || clientStorageType === 'web') {\n    return defaultClientStorageGetter\n  }\n  if (clientStorageType === 'cookie') {\n    return (key) => {\n      if (isBrowser) {\n        return Cookies.get(key) ?? null\n      } else {\n        return null\n      }\n    }\n  }\n  if (!clientStorage) {\n    throw Error(\n      `clientStorageType is set to '${clientStorageType}' but no clientStorage has been given`\n    )\n  }\n  if (clientStorageType === 'react-native') {\n    return (key) => clientStorage.getItem?.(key)\n  }\n  if (clientStorageType === 'capacitor') {\n    return (key) => clientStorage.get?.({ key })\n  }\n  if (clientStorageType === 'expo-secure-storage') {\n    return (key) => clientStorage.getItemAsync?.(key)\n  }\n  if (clientStorageType === 'custom') {\n    if (clientStorage.getItem && clientStorage.removeItem) {\n      return clientStorage.getItem\n    }\n    if (clientStorage.getItemAsync) {\n      return clientStorage.getItemAsync\n    }\n    throw Error(\n      `clientStorageType is set to 'custom' but clientStorage is missing either \"getItem\" and \"removeItem\" properties or \"getItemAsync\" property`\n    )\n  }\n  throw Error(`Unknown storage type: ${clientStorageType}`)\n}\n\nexport const localStorageSetter = (\n  clientStorageType: ClientStorageType,\n  clientStorage?: ClientStorage\n): StorageSetter => {\n  if (clientStorageType === 'localStorage' || clientStorageType === 'web') {\n    return defaultClientStorageSetter\n  }\n  if (clientStorageType === 'cookie') {\n    return (key, value) => {\n      if (isBrowser) {\n        if (value) {\n          // TODO: Set expires based on the actual refresh token expire time\n          // For now, we're using 30 days so the cookie is not removed when the browser is closed because if `expiers` is omitted, the cookie becomes a session cookie.\n          Cookies.set(key, value, { expires: 30 })\n        } else {\n          Cookies.remove(key)\n        }\n      }\n    }\n  }\n  if (!clientStorage) {\n    throw Error(\n      `clientStorageType is set to '${clientStorageType}' but no clienStorage has been given`\n    )\n  }\n  if (clientStorageType === 'react-native') {\n    return (key, value) =>\n      value ? clientStorage.setItem?.(key, value) : clientStorage.removeItem?.(key)\n  }\n  if (clientStorageType === 'capacitor') {\n    return (key, value) =>\n      value ? clientStorage.set?.({ key, value }) : clientStorage.remove?.({ key })\n  }\n  if (clientStorageType === 'expo-secure-storage') {\n    return async (key, value) =>\n      value ? clientStorage.setItemAsync?.(key, value) : clientStorage.deleteItemAsync?.(key)\n  }\n  if (clientStorageType === 'custom') {\n    if (!clientStorage.removeItem) {\n      throw Error(\n        `clientStorageType is set to 'custom' but clientStorage is missing a removeItem property`\n      )\n    }\n    if (clientStorage.setItem) {\n      return (key, value) =>\n        value ? clientStorage.setItem?.(key, value) : clientStorage.removeItem?.(key)\n    }\n    if (clientStorage.setItemAsync) {\n      return async (key, value) =>\n        value ? clientStorage.setItemAsync?.(key, value) : clientStorage.removeItem?.(key)\n    }\n    throw Error(\n      `clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property`\n    )\n  }\n  throw Error(`Unknown storage type: ${clientStorageType}`)\n}\n","import { RedirectOption } from './types'\n\nexport const encodeQueryParameters = (baseUrl: string, parameters?: Record<string, unknown>) => {\n  const encodedParameters =\n    parameters &&\n    Object.entries(parameters)\n      .map(([key, value]) => {\n        const stringValue = Array.isArray(value)\n          ? value.join(',')\n          : typeof value === 'object'\n          ? JSON.stringify(value)\n          : (value as string)\n        return `${key}=${encodeURIComponent(stringValue)}`\n      })\n      .join('&')\n  if (encodedParameters) return `${baseUrl}?${encodedParameters}`\n  else return baseUrl\n}\n\n/**\n * Transform options that include a redirectTo property so the\n * redirect url is absolute, given a base clientUrl.\n * If no client url is given, any relative redirectUrl is removed while\n * the other options are sent as-is.\n * @param clientUrl base client url\n * @param options\n * @returns\n */\nexport const rewriteRedirectTo = <T extends RedirectOption>(\n  clientUrl?: string,\n  options?: T\n): (Omit<T, 'redirectTo'> & { redirectTo?: string }) | undefined => {\n  if (!options?.redirectTo) {\n    return options\n  }\n  const { redirectTo, ...otherOptions } = options\n  // * If the clientUrl is not defined, we can't rewrite the redirectTo\n  if (!clientUrl) {\n    // * If redirectTo is a relative path, we therefore pull it out of the options\n    if (redirectTo.startsWith('/')) {\n      return otherOptions\n    } else {\n      return options\n    }\n  }\n  const baseClientUrl = new URL(clientUrl)\n  const clientParams = Object.fromEntries(new URLSearchParams(baseClientUrl.search))\n  const url = new URL(redirectTo.startsWith('/') ? baseClientUrl.origin + redirectTo : redirectTo)\n  const additionalParams = new URLSearchParams(url.search)\n  let combinedParams = Object.fromEntries(additionalParams)\n\n  if (redirectTo.startsWith('/')) {\n    combinedParams = { ...clientParams, ...combinedParams }\n  }\n  let pathName = baseClientUrl.pathname\n  if (url.pathname.length > 1) {\n    pathName += url.pathname.slice(1)\n  }\n  return {\n    ...otherOptions,\n    redirectTo: encodeQueryParameters(url.origin + pathName, combinedParams)\n  }\n}\n\nexport function getParameterByName(name: string, url?: string) {\n  if (!url) {\n    if (typeof window === 'undefined') {\n      return\n    }\n    url = window.location?.href || ''\n  }\n  // eslint-disable-next-line no-useless-escape\n  name = name.replace(/[\\[\\]]/g, '\\\\$&')\n  const regex = new RegExp('[?&#]' + name + '(=([^&#]*)|&|#|$)'),\n    results = regex.exec(url)\n  if (!results) return null\n  if (!results[2]) return ''\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '))\n}\n\nexport function removeParameterFromWindow(name: string) {\n  if (typeof window === 'undefined') {\n    return\n  }\n  const location = window?.location\n  if (!location) {\n    return\n  }\n  if (location) {\n    const search = new URLSearchParams(location.search)\n    const hash = new URLSearchParams(location.hash?.slice(1))\n    search.delete(name)\n    hash.delete(name)\n    let url = window.location.pathname\n    if (Array.from(search).length) url += `?${search.toString()}`\n    if (Array.from(hash).length) url += `#${hash.toString()}`\n    window.history.pushState({}, '', url)\n  }\n}\n","import { MIN_PASSWORD_LENGTH } from './constants'\n\nexport const isValidEmail = (email?: string | null) =>\n  !!email &&\n  typeof email === 'string' &&\n  !!String(email)\n    .toLowerCase()\n    .match(\n      /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\n    )\n\nexport const isValidPassword = (password?: string | null) =>\n  !!password && typeof password === 'string' && password.length >= MIN_PASSWORD_LENGTH\n\n// TODO improve validation\nexport const isValidPhoneNumber = (phoneNumber?: string | null) =>\n  !!phoneNumber && typeof phoneNumber === 'string'\n\nexport const isValidTicket = (ticket?: string | null) =>\n  ticket &&\n  typeof ticket === 'string' &&\n  ticket.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)\n","import type { ErrorPayload } from '../errors'\nimport { User } from '../types'\n\nexport type StateErrorTypes = 'registration' | 'authentication' | 'signout'\n\nexport type AuthContext = {\n  user: User | null\n  mfa: {\n    ticket: string\n  } | null\n  accessToken: {\n    value: string | null\n    expiresAt: Date | null\n  }\n  refreshTimer: {\n    startedAt: Date | null\n    attempts: number\n    lastAttempt: Date | null\n  }\n  refreshToken: {\n    value: string | null\n  }\n  errors: Partial<Record<StateErrorTypes, ErrorPayload>>\n}\n\nexport const INITIAL_MACHINE_CONTEXT: AuthContext = {\n  user: null,\n  mfa: null,\n  accessToken: {\n    value: null,\n    expiresAt: null\n  },\n  refreshTimer: {\n    startedAt: null,\n    attempts: 0,\n    lastAttempt: null\n  },\n  refreshToken: {\n    value: null\n  },\n  errors: {}\n}\n","import { assign, createMachine, send } from 'xstate'\n\nimport { AuthClient } from '../client'\nimport { ErrorPayload, INVALID_EMAIL_ERROR } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { ChangeEmailOptions, ChangeEmailResponse } from '../types'\nimport { rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../validators'\n\nexport type ChangeEmailContext = {\n  error: ErrorPayload | null\n}\n\nexport type ChangeEmailEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: ChangeEmailOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: ErrorPayload | null }\n\nexport type ChangeEmailServices = {\n  request: { data: ChangeEmailResponse }\n}\n\nexport type ChangeEmailMachine = ReturnType<typeof createChangeEmailMachine>\n\nexport const createChangeEmailMachine = ({ backendUrl, clientUrl, interpreter }: AuthClient) => {\n  const api = nhostApiClient(backendUrl)\n  return createMachine(\n    {\n      schema: {\n        context: {} as ChangeEmailContext,\n        events: {} as ChangeEmailEvents,\n        services: {} as ChangeEmailServices\n      },\n      tsTypes: {} as import('./change-email.typegen').Typegen0,\n      preserveActionOrder: true,\n      id: 'changeEmail',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        // TODO change email in the main machine (context.user.email)\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        requestChange: async (_, { email, options }) => {\n          const res = await api.post(\n            '/user/email/change',\n            {\n              newEmail: email,\n              options: rewriteRedirectTo(clientUrl, options)\n            },\n            {\n              headers: {\n                authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n              }\n            }\n          )\n          return res.data\n        }\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\n\nimport { AuthClient } from '../client'\nimport { ErrorPayload, INVALID_PASSWORD_ERROR } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { ChangePasswordResponse } from '../types'\nimport { isValidPassword } from '../validators'\n\nexport type ChangePasswordContext = {\n  error: ErrorPayload | null\n}\nexport type ChangePasswordEvents =\n  | {\n      type: 'REQUEST'\n      password?: string\n      ticket?: string\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: ErrorPayload | null }\n\nexport type ChangePasswordServices = {\n  requestChange: { data: ChangePasswordResponse }\n}\n\nexport type ChangePasswordMachine = ReturnType<typeof createChangePasswordMachine>\n\nexport const createChangePasswordMachine = ({ backendUrl, interpreter }: AuthClient) => {\n  const api = nhostApiClient(backendUrl)\n  return createMachine(\n    {\n      schema: {\n        context: {} as ChangePasswordContext,\n        events: {} as ChangePasswordEvents,\n        services: {} as ChangePasswordServices\n      },\n      tsTypes: {} as import('./change-password.typegen').Typegen0,\n      preserveActionOrder: true,\n      id: 'changePassword',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidPassword',\n                actions: 'saveInvalidPasswordError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidPasswordError: assign({ error: (_) => INVALID_PASSWORD_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidPassword: (_, { password }) => !isValidPassword(password)\n      },\n      services: {\n        requestChange: (_, { password, ticket }) =>\n          api.post<string, ChangePasswordResponse>(\n            '/user/password',\n            { newPassword: password, ticket: ticket },\n            {\n              headers: {\n                authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n              }\n            }\n          )\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\n\nimport { AuthClient } from '../client'\nimport { ErrorPayload, INVALID_MFA_CODE_ERROR, INVALID_MFA_TYPE_ERROR } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\n\nexport type EnableMfaContext = {\n  error: ErrorPayload | null\n  imageUrl: string | null\n  secret: string | null\n}\n\nexport type EnableMfaEvents =\n  | {\n      type: 'GENERATE'\n    }\n  | {\n      type: 'ACTIVATE'\n      code?: string\n      activeMfaType: 'totp'\n    }\n  | { type: 'GENERATED' }\n  | { type: 'GENERATED_ERROR'; error: ErrorPayload | null }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: ErrorPayload | null }\n\nexport type EnableMfadMachine = ReturnType<typeof createEnableMfaMachine>\n\nexport const createEnableMfaMachine = ({ backendUrl, interpreter }: AuthClient) => {\n  const api = nhostApiClient(backendUrl)\n  return createMachine(\n    {\n      schema: {\n        context: {} as EnableMfaContext,\n        events: {} as EnableMfaEvents\n      },\n      tsTypes: {} as import('./enable-mfa.typegen').Typegen0,\n      preserveActionOrder: true,\n      id: 'enableMfa',\n      initial: 'idle',\n      context: { error: null, imageUrl: null, secret: null },\n      states: {\n        idle: {\n          initial: 'initial',\n          on: {\n            GENERATE: 'generating'\n          },\n          states: {\n            initial: {},\n            error: {}\n          }\n        },\n        generating: {\n          invoke: {\n            src: 'generate',\n            id: 'generate',\n            onDone: { target: 'generated', actions: ['reportGeneratedSuccess', 'saveGeneration'] },\n            onError: { actions: ['saveError', 'reportGeneratedError'], target: 'idle.error' }\n          }\n        },\n        generated: {\n          initial: 'idle',\n          states: {\n            idle: {\n              initial: 'idle',\n              on: {\n                ACTIVATE: [\n                  {\n                    cond: 'invalidMfaType',\n                    actions: 'saveInvalidMfaTypeError',\n                    target: '.error'\n                  },\n                  {\n                    cond: 'invalidMfaCode',\n                    actions: 'saveInvalidMfaCodeError',\n                    target: '.error'\n                  },\n                  {\n                    target: 'activating'\n                  }\n                ]\n              },\n              states: { idle: {}, error: {} }\n            },\n            activating: {\n              invoke: {\n                src: 'activate',\n                id: 'activate',\n                onDone: { target: 'activated', actions: 'reportSuccess' },\n                onError: { actions: ['saveError', 'reportError'], target: 'idle.error' }\n              }\n            },\n            activated: { type: 'final' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidMfaTypeError: assign({ error: (_) => INVALID_MFA_TYPE_ERROR }),\n        saveInvalidMfaCodeError: assign({ error: (_) => INVALID_MFA_CODE_ERROR }),\n        saveError: assign({\n          error: (_, { data: { error } }: any) => error\n        }),\n        saveGeneration: assign({\n          imageUrl: (_, { data: { imageUrl } }: any) => imageUrl,\n          secret: (_, { data: { totpSecret } }: any) => totpSecret\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS'),\n        reportGeneratedSuccess: send('GENERATED'),\n        reportGeneratedError: send((ctx) => ({ type: 'GENERATED_ERROR', error: ctx.error }))\n      },\n      guards: {\n        invalidMfaCode: (_, { code }) => !code,\n        invalidMfaType: (_, { activeMfaType }) => !activeMfaType || activeMfaType !== 'totp'\n      },\n      services: {\n        generate: async (_) => {\n          const { data } = await api.get('/mfa/totp/generate', {\n            headers: {\n              authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n            }\n          })\n          return data\n        },\n        activate: (_, { code, activeMfaType }) =>\n          api.post(\n            '/user/mfa',\n            {\n              code,\n              activeMfaType\n            },\n            {\n              headers: {\n                authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n              }\n            }\n          )\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\n\nimport { AuthClient } from '../client'\nimport { ErrorPayload, INVALID_EMAIL_ERROR } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { ResetPasswordOptions, ResetPasswordResponse } from '../types'\nimport { rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../validators'\n\nexport type ResetPasswordContext = {\n  error: ErrorPayload | null\n}\nexport type ResetPasswordEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: ResetPasswordOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: ErrorPayload | null }\n\nexport type ResetPasswordServices = {\n  requestChange: { data: ResetPasswordResponse }\n}\n\nexport type ResetPasswordMachine = ReturnType<typeof createResetPasswordMachine>\n\nexport const createResetPasswordMachine = ({ backendUrl, clientUrl }: AuthClient) => {\n  const api = nhostApiClient(backendUrl)\n  return createMachine(\n    {\n      schema: {\n        context: {} as ResetPasswordContext,\n        events: {} as ResetPasswordEvents,\n        services: {} as ResetPasswordServices\n      },\n      tsTypes: {} as import('./reset-password.typegen').Typegen0,\n      preserveActionOrder: true,\n      id: 'changePassword',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        requestChange: (_, { email, options }) =>\n          api.post<string, ResetPasswordResponse>('/user/password/reset', {\n            email,\n            options: rewriteRedirectTo(clientUrl, options)\n          })\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\n\nimport { AuthClient } from '../client'\nimport { ErrorPayload, INVALID_EMAIL_ERROR } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { SendVerificationEmailOptions, SendVerificationEmailResponse } from '../types'\nimport { rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../validators'\n\nexport type SendVerificationEmailContext = {\n  error: ErrorPayload | null\n}\n\nexport type SendVerificationEmailEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: SendVerificationEmailOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: ErrorPayload | null }\n\nexport type SendVerificationEmailServices = {\n  request: { data: SendVerificationEmailResponse }\n}\n\nexport type SendVerificationEmailMachine = ReturnType<typeof createSendVerificationEmailMachine>\nexport const createSendVerificationEmailMachine = ({ backendUrl, clientUrl }: AuthClient) => {\n  const api = nhostApiClient(backendUrl)\n  return createMachine(\n    {\n      schema: {\n        context: {} as SendVerificationEmailContext,\n        events: {} as SendVerificationEmailEvents,\n        services: {} as SendVerificationEmailServices\n      },\n      tsTypes: {} as import('./send-verification-email.typegen').Typegen0,\n      preserveActionOrder: true,\n      id: 'sendVerificationEmail',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'request',\n            id: 'request',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        request: async (_, { email, options }) => {\n          const res = await api.post<SendVerificationEmailResponse>(\n            '/user/email/send-verification-email',\n            {\n              email,\n              options: rewriteRedirectTo(clientUrl, options)\n            }\n          )\n          return res.data\n        }\n      }\n    }\n  )\n}\n","import type { AxiosRequestConfig } from 'axios'\nimport { assign, createMachine, send } from 'xstate'\n\nimport { startAuthentication, startRegistration } from '@simplewebauthn/browser'\nimport type {\n  AuthenticationCredentialJSON,\n  PublicKeyCredentialCreationOptionsJSON,\n  PublicKeyCredentialRequestOptionsJSON,\n  RegistrationCredentialJSON\n} from '@simplewebauthn/typescript-types'\n\nimport {\n  NHOST_JWT_EXPIRES_AT_KEY,\n  NHOST_REFRESH_TOKEN_KEY,\n  REFRESH_TOKEN_RETRY_INTERVAL,\n  TOKEN_REFRESH_MARGIN\n} from '../constants'\nimport {\n  CodifiedError,\n  INVALID_EMAIL_ERROR,\n  INVALID_MFA_TICKET_ERROR,\n  INVALID_PASSWORD_ERROR,\n  INVALID_PHONE_NUMBER_ERROR,\n  NO_MFA_TICKET_ERROR,\n  VALIDATION_ERROR_CODE,\n  ValidationErrorPayload\n} from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { localStorageGetter, localStorageSetter } from '../storage'\nimport {\n  AuthOptions,\n  DeanonymizeResponse,\n  NhostSession,\n  NhostSessionResponse,\n  PasswordlessEmailResponse,\n  PasswordlessSmsOtpResponse,\n  PasswordlessSmsResponse,\n  RefreshSessionResponse,\n  SignInAnonymousResponse,\n  SignInMfaTotpResponse,\n  SignInResponse,\n  SignOutResponse,\n  SignUpResponse\n} from '../types'\nimport { getParameterByName, removeParameterFromWindow, rewriteRedirectTo } from '../utils'\nimport { isValidEmail, isValidPassword, isValidPhoneNumber, isValidTicket } from '../validators'\n\nimport { AuthContext, INITIAL_MACHINE_CONTEXT, StateErrorTypes } from './context'\nimport { AuthEvents } from './events'\n\nexport * from './change-email'\nexport * from './change-password'\nexport * from './enable-mfa'\nexport * from './reset-password'\nexport * from './send-verification-email'\n\nexport type { AuthContext, AuthEvents, StateErrorTypes }\n\nexport interface AuthMachineOptions extends AuthOptions {\n  backendUrl: string\n  clientUrl: string\n}\n\nexport type AuthMachine = ReturnType<typeof createAuthMachine>\n\ntype AuthServices = {\n  signInPassword: { data: SignInResponse }\n  passwordlessSms: { data: PasswordlessSmsResponse | DeanonymizeResponse }\n  passwordlessSmsOtp: { data: PasswordlessSmsOtpResponse }\n  passwordlessEmail: { data: PasswordlessEmailResponse | DeanonymizeResponse }\n  signInAnonymous: { data: SignInAnonymousResponse }\n  signInMfaTotp: { data: SignInMfaTotpResponse }\n  signInSecurityKeyEmail: { data: SignInResponse }\n  refreshToken: { data: NhostSessionResponse }\n  signout: { data: SignOutResponse }\n  signUpEmailPassword: { data: SignUpResponse }\n  signUpSecurityKey: { data: SignUpResponse }\n  importRefreshToken: { data: NhostSessionResponse }\n}\n\nexport const createAuthMachine = ({\n  backendUrl,\n  clientUrl,\n  clientStorageGetter,\n  clientStorageSetter,\n  clientStorageType = 'web',\n  clientStorage,\n  refreshIntervalTime,\n  autoRefreshToken = true,\n  autoSignIn = true\n}: AuthMachineOptions) => {\n  const storageGetter = clientStorageGetter || localStorageGetter(clientStorageType, clientStorage)\n  const storageSetter = clientStorageSetter || localStorageSetter(clientStorageType, clientStorage)\n  const api = nhostApiClient(backendUrl)\n  const postRequest = async <T = any, D = any>(\n    url: string,\n    data?: D,\n    config?: AxiosRequestConfig<D>\n  ): Promise<T> => {\n    const result = await api.post(url, data, config)\n\n    return result.data\n  }\n  return createMachine(\n    {\n      schema: {\n        context: {} as AuthContext,\n        events: {} as AuthEvents,\n        services: {} as AuthServices\n      },\n      tsTypes: {} as import('./index.typegen').Typegen0,\n      context: INITIAL_MACHINE_CONTEXT,\n      preserveActionOrder: true,\n      id: 'nhost',\n      type: 'parallel',\n      states: {\n        authentication: {\n          initial: 'starting',\n          on: {\n            SESSION_UPDATE: [\n              {\n                cond: 'hasSession',\n                actions: ['saveSession', 'resetTimer', 'reportTokenChanged'],\n                target: '.signedIn'\n              }\n            ]\n          },\n          states: {\n            starting: {\n              entry: 'resetErrors',\n              tags: ['loading'],\n              always: { cond: 'isSignedIn', target: 'signedIn' },\n              invoke: {\n                id: 'importRefreshToken',\n                src: 'importRefreshToken',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: 'signedIn'\n                },\n                onError: { actions: ['saveAuthenticationError'], target: 'signedOut' }\n              }\n            },\n            signedOut: {\n              initial: 'noErrors',\n              entry: 'reportSignedOut',\n              states: {\n                noErrors: {},\n                success: {},\n                needsSmsOtp: {},\n                needsMfa: {},\n                failed: {},\n                signingOut: {\n                  entry: ['clearContextExceptRefreshToken'],\n                  exit: ['destroyRefreshToken', 'reportTokenChanged'],\n                  invoke: {\n                    src: 'signout',\n                    id: 'signingOut',\n                    onDone: {\n                      target: 'success'\n                    },\n                    onError: {\n                      target: 'failed',\n                      actions: ['saveAuthenticationError']\n                    }\n                  }\n                }\n              },\n              on: {\n                SIGNIN_PASSWORD: 'authenticating.password',\n                SIGNIN_ANONYMOUS: 'authenticating.anonymous',\n                SIGNIN_SECURITY_KEY_EMAIL: 'authenticating.securityKeyEmail',\n                SIGNIN_MFA_TOTP: 'authenticating.mfa.totp'\n              }\n            },\n            authenticating: {\n              entry: 'resetErrors',\n              states: {\n                password: {\n                  invoke: {\n                    src: 'signInPassword',\n                    id: 'authenticateUserWithPassword',\n                    onDone: [\n                      {\n                        cond: 'hasMfaTicket',\n                        actions: ['saveMfaTicket'],\n                        target: '#nhost.authentication.signedOut.needsMfa'\n                      },\n                      {\n                        actions: ['saveSession', 'reportTokenChanged'],\n                        target: '#nhost.authentication.signedIn'\n                      }\n                    ],\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: [\n                          '#nhost.authentication.signedOut',\n                          '#nhost.registration.incomplete.needsEmailVerification'\n                        ]\n                      },\n                      {\n                        actions: 'saveAuthenticationError',\n                        target: '#nhost.authentication.signedOut.failed'\n                      }\n                    ]\n                  }\n                },\n                anonymous: {\n                  invoke: {\n                    src: 'signInAnonymous',\n                    id: 'authenticateAnonymously',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: {\n                      actions: 'saveAuthenticationError',\n                      target: '#nhost.authentication.signedOut.failed'\n                    }\n                  }\n                },\n                mfa: {\n                  states: {\n                    totp: {\n                      invoke: {\n                        src: 'signInMfaTotp',\n                        id: 'signInMfaTotp',\n                        onDone: {\n                          actions: ['saveSession', 'reportTokenChanged'],\n                          target: '#nhost.authentication.signedIn'\n                        },\n                        onError: {\n                          actions: ['saveAuthenticationError'],\n                          target: '#nhost.authentication.signedOut.failed'\n                        }\n                      }\n                    }\n                  }\n                },\n                securityKeyEmail: {\n                  invoke: {\n                    src: 'signInSecurityKeyEmail',\n                    id: 'authenticateUserWithSecurityKey',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: [\n                          '#nhost.authentication.signedOut',\n                          '#nhost.registration.incomplete.needsEmailVerification'\n                        ]\n                      },\n                      {\n                        actions: 'saveAuthenticationError',\n                        target: '#nhost.authentication.signedOut.failed'\n                      }\n                    ]\n                  }\n                }\n              }\n            },\n            signedIn: {\n              type: 'parallel',\n              entry: ['reportSignedIn', 'cleanUrl', 'broadcastToken', 'resetErrors'],\n              on: {\n                SIGNOUT: 'signedOut.signingOut'\n              },\n              states: {\n                refreshTimer: {\n                  id: 'timer',\n                  initial: 'idle',\n                  states: {\n                    disabled: { type: 'final' },\n                    stopped: {\n                      always: {\n                        cond: 'noToken',\n                        target: 'idle'\n                      }\n                    },\n                    idle: {\n                      always: [\n                        { cond: 'isAutoRefreshDisabled', target: 'disabled' },\n                        {\n                          cond: 'hasRefreshToken',\n                          target: 'running'\n                        }\n                      ]\n                    },\n                    running: {\n                      initial: 'pending',\n                      entry: 'resetTimer',\n                      states: {\n                        pending: {\n                          after: {\n                            '1000': {\n                              internal: false,\n                              target: 'pending'\n                            }\n                          },\n                          always: {\n                            cond: 'refreshTimerShouldRefresh',\n                            target: 'refreshing'\n                          }\n                        },\n                        refreshing: {\n                          invoke: {\n                            src: 'refreshToken',\n                            id: 'refreshToken',\n                            onDone: {\n                              actions: ['saveSession', 'resetTimer', 'reportTokenChanged'],\n                              target: 'pending'\n                            },\n                            onError: [\n                              { actions: 'saveRefreshAttempt', target: 'pending' }\n                              // ? stop trying after x attempts?\n                              // {\n                              //   actions: 'retry',\n                              //   cond: 'canRetry',\n                              //   target: 'pending'\n                              // },\n                              // {\n                              //   actions: ['sendError', 'resetToken'],\n                              //   target: '#timer.stopped'\n                              // }\n                            ]\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        },\n        token: {\n          initial: 'idle',\n          states: {\n            idle: {\n              on: {\n                TRY_TOKEN: 'running'\n              },\n              initial: 'noErrors',\n              states: { noErrors: {}, error: {} }\n            },\n            running: {\n              invoke: {\n                src: 'refreshToken',\n                id: 'authenticateWithToken',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: ['#nhost.authentication.signedIn', 'idle.noErrors']\n                },\n                onError: [\n                  { cond: 'isSignedIn', target: 'idle.error' },\n                  {\n                    actions: 'saveAuthenticationError',\n                    target: ['#nhost.authentication.signedOut.failed', 'idle.error']\n                  }\n                ]\n              }\n            }\n          }\n        },\n        registration: {\n          initial: 'incomplete',\n          on: {\n            SIGNED_IN: [{ cond: 'isAnonymous', target: '.incomplete' }, '.complete']\n          },\n          states: {\n            incomplete: {\n              on: {\n                SIGNUP_EMAIL_PASSWORD: 'emailPassword',\n                SIGNUP_SECURITY_KEY: 'securityKey',\n                PASSWORDLESS_EMAIL: 'passwordlessEmail',\n                PASSWORDLESS_SMS: 'passwordlessSms',\n                PASSWORDLESS_SMS_OTP: 'passwordlessSmsOtp'\n              },\n              initial: 'noErrors',\n              states: {\n                noErrors: {},\n                needsEmailVerification: {},\n                needsOtp: {},\n                failed: {}\n              }\n            },\n            emailPassword: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'signUpEmailPassword',\n                id: 'signUpEmailPassword',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: '#nhost.authentication.signedIn'\n                  },\n                  {\n                    actions: 'clearContext',\n                    target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'unverified',\n                    target: 'incomplete.needsEmailVerification'\n                  },\n                  {\n                    actions: 'saveRegistrationError',\n                    target: 'incomplete.failed'\n                  }\n                ]\n              }\n            },\n            securityKey: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'signUpSecurityKey',\n                id: 'signUpSecurityKey',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: '#nhost.authentication.signedIn'\n                  },\n                  {\n                    actions: 'clearContext',\n                    target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'unverified',\n                    target: 'incomplete.needsEmailVerification'\n                  },\n                  {\n                    actions: 'saveRegistrationError',\n                    target: 'incomplete.failed'\n                  }\n                ]\n              }\n            },\n            passwordlessEmail: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessEmail',\n                id: 'passwordlessEmail',\n                onDone: {\n                  actions: 'clearContext',\n                  target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            passwordlessSms: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessSms',\n                id: 'passwordlessSms',\n                onDone: {\n                  actions: 'clearContext',\n                  target: ['#nhost.authentication.signedOut', 'incomplete.needsOtp']\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            passwordlessSmsOtp: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessSmsOtp',\n                id: 'passwordlessSmsOtp',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: '#nhost.authentication.signedIn'\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n\n            complete: {\n              on: {\n                SIGNED_OUT: 'incomplete'\n              }\n            }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        reportSignedIn: send('SIGNED_IN'),\n        reportSignedOut: send('SIGNED_OUT'),\n        reportTokenChanged: send('TOKEN_CHANGED'),\n        clearContext: assign(() => {\n          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n          storageSetter(NHOST_REFRESH_TOKEN_KEY, null)\n          return {\n            ...INITIAL_MACHINE_CONTEXT\n          }\n        }),\n        clearContextExceptRefreshToken: assign(({ refreshToken: { value } }) => {\n          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n          return {\n            ...INITIAL_MACHINE_CONTEXT,\n            refreshToken: { value }\n          }\n        }),\n\n        // * Save session in the context, and persist the refresh token and the jwt expiration outside of the machine\n        saveSession: assign({\n          user: (_, { data }) => data?.session?.user || null,\n          accessToken: (_, { data }) => {\n            if (data.session) {\n              const { accessTokenExpiresIn, accessToken } = data.session\n              const nextRefresh = new Date(Date.now() + accessTokenExpiresIn * 1_000)\n              storageSetter(NHOST_JWT_EXPIRES_AT_KEY, nextRefresh.toISOString())\n              return {\n                value: accessToken,\n                expiresAt: nextRefresh\n              }\n            }\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n            return {\n              value: null,\n              expiresAt: null\n            }\n          },\n          refreshToken: (_, { data }) => {\n            const refreshToken = data.session?.refreshToken || null\n            if (refreshToken) {\n              storageSetter(NHOST_REFRESH_TOKEN_KEY, refreshToken)\n            }\n            return { value: refreshToken }\n          }\n        }),\n        saveMfaTicket: assign({\n          mfa: (_, e) => e.data?.mfa\n        }),\n\n        resetTimer: assign({\n          refreshTimer: (_) => ({\n            startedAt: new Date(),\n            attempts: 0,\n            lastAttempt: null\n          })\n        }),\n\n        saveRefreshAttempt: assign({\n          refreshTimer: (ctx, e) => ({\n            startedAt: ctx.refreshTimer.startedAt,\n            attempts: ctx.refreshTimer.attempts + 1,\n            lastAttempt: new Date()\n          })\n        }),\n\n        // * Authentication errors\n        saveAuthenticationError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          errors: ({ errors }, { data: { error } }: any) => ({\n            ...errors,\n            authentication: error\n          })\n        }),\n        resetErrors: assign({\n          errors: (_) => ({})\n        }),\n        saveRegistrationError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          errors: ({ errors }, { data: { error } }: any) => ({ ...errors, registration: error })\n        }),\n        destroyRefreshToken: assign({\n          refreshToken: (_) => {\n            storageSetter(NHOST_REFRESH_TOKEN_KEY, null)\n            return { value: null }\n          }\n        }),\n\n        // * Clean the browser url when `autoSignIn` is activated\n        cleanUrl: () => {\n          if (autoSignIn && getParameterByName('refreshToken')) {\n            // * Remove the refresh token from the URL\n            removeParameterFromWindow('refreshToken')\n            removeParameterFromWindow('type')\n          }\n        },\n\n        // * Broadcast the token to other tabs when `autoSignIn` is activated\n        broadcastToken: (context) => {\n          if (autoSignIn) {\n            try {\n              const channel = new BroadcastChannel('nhost')\n              // ? broadcat session instead of token ?\n              channel.postMessage(context.refreshToken.value)\n            } catch (error) {\n              // * BroadcastChannel is not available e.g. react-native\n            }\n          }\n        }\n      },\n\n      guards: {\n        isAnonymous: (ctx, e) => !!ctx.user?.isAnonymous,\n        isSignedIn: (ctx) => !!ctx.user && !!ctx.refreshToken.value && !!ctx.accessToken.value,\n        noToken: (ctx) => !ctx.refreshToken.value,\n        hasRefreshToken: (ctx) => !!ctx.refreshToken.value,\n        isAutoRefreshDisabled: () => !autoRefreshToken,\n        refreshTimerShouldRefresh: (ctx) => {\n          const { expiresAt } = ctx.accessToken\n          if (!expiresAt) {\n            return false\n          }\n          if (ctx.refreshTimer.lastAttempt) {\n            // * If a refesh previously failed, only try to refresh every `REFRESH_TOKEN_RETRY_INTERVAL` seconds\n            const elapsed = Date.now() - ctx.refreshTimer.lastAttempt.getTime()\n            return elapsed > REFRESH_TOKEN_RETRY_INTERVAL * 1_000\n          }\n          if (refreshIntervalTime) {\n            // * If a refreshIntervalTime has been passed on as an option, it will notify\n            // * the token should be refershed when this interval is overdue\n            const elapsed = Date.now() - ctx.refreshTimer.startedAt!.getTime()\n            if (elapsed > refreshIntervalTime * 1_000) {\n              return true\n            }\n          }\n          // * In any case, it's time to refresh when there's less than\n          // * TOKEN_REFRESH_MARGIN seconds before the JWT exprires\n          const expiresIn = expiresAt.getTime() - Date.now()\n          const remaining = expiresIn - 1_000 * TOKEN_REFRESH_MARGIN\n          return remaining <= 0\n        },\n        // * Authentication errors\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        unverified: (_, { data: { error } }: any) =>\n          error.status === 401 &&\n          // * legacy: don't use the message contents to determine if the email is unverified, but the error type (error.error)\n          (error.message === 'Email is not verified' || error.error === 'unverified-user'),\n\n        // * Event guards\n        hasSession: (_, e) => !!e.data?.session,\n        hasMfaTicket: (_, e) => !!e.data?.mfa\n      },\n\n      services: {\n        signInPassword: (_, { email, password }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n          if (!isValidPassword(password)) {\n            return Promise.reject({ error: INVALID_PASSWORD_ERROR })\n          }\n          return postRequest<SignInResponse>('/signin/email-password', {\n            email,\n            password\n          })\n        },\n        passwordlessSms: (context, { phoneNumber, options }) => {\n          if (!isValidPhoneNumber(phoneNumber)) {\n            return Promise.reject({ error: INVALID_PHONE_NUMBER_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            // TODO implement in hasura-auth\n            // * See https://github.com/nhost/hasura-auth/blob/9c6d0f4ded4fc8fd1b8031926c02796c74a7eada/src/routes/user/deanonymize.ts\n            console.warn(\n              'Deanonymisation from a phone number is not yet implemented in hasura-auth'\n            )\n            return postRequest(\n              '/user/deanonymize',\n              {\n                signInMethod: 'passwordless',\n                connection: 'sms',\n                phoneNumber,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              {\n                headers: {\n                  authorization: `Bearer ${context.accessToken.value}`\n                }\n              }\n            )\n          } else {\n            return postRequest('/signin/passwordless/sms', {\n              phoneNumber,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        passwordlessSmsOtp: (_, { phoneNumber, otp }) => {\n          if (!isValidPhoneNumber(phoneNumber)) {\n            return Promise.reject({ error: INVALID_PHONE_NUMBER_ERROR })\n          }\n          return postRequest('/signin/passwordless/sms/otp', {\n            phoneNumber,\n            otp\n          })\n        },\n        passwordlessEmail: (context, { email, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            return postRequest(\n              '/user/deanonymize',\n              {\n                signInMethod: 'passwordless',\n                connection: 'email',\n                email,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              {\n                headers: {\n                  authorization: `Bearer ${context.accessToken.value}`\n                }\n              }\n            )\n          } else {\n            return postRequest('/signin/passwordless/email', {\n              email,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        signInAnonymous: (_) => postRequest('/signin/anonymous'),\n        signInMfaTotp: (context, data) => {\n          const ticket: string | undefined = data.ticket || context.mfa?.ticket\n          if (!ticket) {\n            return Promise.reject({ error: NO_MFA_TICKET_ERROR })\n          }\n          if (!isValidTicket(ticket)) {\n            return Promise.reject({ error: INVALID_MFA_TICKET_ERROR })\n          }\n\n          return postRequest('/signin/mfa/totp', {\n            ticket,\n            otp: data.otp\n          })\n        },\n        signInSecurityKeyEmail: async (_, { email }) => {\n          if (!isValidEmail(email)) {\n            throw new CodifiedError(INVALID_EMAIL_ERROR)\n          }\n          const options = await postRequest<PublicKeyCredentialRequestOptionsJSON>(\n            '/signin/webauthn',\n            { email }\n          )\n          let credential: AuthenticationCredentialJSON\n          try {\n            credential = await startAuthentication(options)\n          } catch (e) {\n            throw new CodifiedError(e as Error)\n          }\n          return postRequest<SignInResponse>('/signin/webauthn/verify', { email, credential })\n        },\n        refreshToken: async (ctx, event) => {\n          const refreshToken = event.type === 'TRY_TOKEN' ? event.token : ctx.refreshToken.value\n          const session = await postRequest<RefreshSessionResponse>('/token', {\n            refreshToken\n          })\n          return { session, error: null }\n        },\n        signout: (ctx, e) =>\n          postRequest('/signout', {\n            refreshToken: ctx.refreshToken.value,\n            all: !!e.all\n          }),\n        signUpEmailPassword: async (context, { email, password, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_EMAIL_ERROR })\n          }\n          if (!isValidPassword(password)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_PASSWORD_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            return postRequest<SignUpResponse>(\n              '/user/deanonymize',\n              {\n                signInMethod: 'email-password',\n                email,\n                password,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              {\n                headers: {\n                  authorization: `Bearer ${context.accessToken.value}`\n                }\n              }\n            )\n          } else {\n            return postRequest<SignUpResponse>('/signup/email-password', {\n              email,\n              password,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        signUpSecurityKey: async (_, { email, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_EMAIL_ERROR })\n          }\n          // TODO anonymous users\n          const nickname = options?.nickname\n          /*\n           * The `/signup/webauthn` endpoint accepts any option from SignUpOptions,\n           * We therefore remove the nickname from the options object before sending it to the server,\n           * as options if of type `SignUpSecurityKeyOptions`, which extends `SignUpOptions` with the optional `nickname` property.\n           */\n          if (nickname) delete options.nickname\n          const webAuthnOptions = await postRequest<PublicKeyCredentialCreationOptionsJSON>(\n            '/signup/webauthn',\n            { email, options }\n          )\n          let credential: RegistrationCredentialJSON\n          try {\n            credential = await startRegistration(webAuthnOptions)\n          } catch (e) {\n            throw new CodifiedError(e as Error)\n          }\n          return postRequest<SignUpResponse>('/signup/webauthn/verify', {\n            credential,\n            options: {\n              redirectTo: options?.redirectTo,\n              nickname\n            }\n          })\n        },\n        importRefreshToken: async () => {\n          let error: ValidationErrorPayload | null = null\n          if (autoSignIn) {\n            const urlToken = getParameterByName('refreshToken') || null\n            if (urlToken) {\n              try {\n                const session = await postRequest<NhostSession>('/token', {\n                  refreshToken: urlToken\n                })\n                return { session, error: null }\n              } catch (exception) {\n                error = (exception as { error: ValidationErrorPayload }).error\n              }\n            } else {\n              const error = getParameterByName('error')\n              if (error) {\n                return Promise.reject<NhostSessionResponse>({\n                  session: null,\n                  error: {\n                    status: VALIDATION_ERROR_CODE,\n                    error,\n                    message: getParameterByName('errorDescription') || error\n                  }\n                })\n              }\n            }\n          }\n          const storageToken = await storageGetter(NHOST_REFRESH_TOKEN_KEY)\n          if (storageToken) {\n            try {\n              const session = await postRequest<NhostSession>('/token', {\n                refreshToken: storageToken\n              })\n              return { session, error: null }\n            } catch (exception) {\n              error = (exception as { error: ValidationErrorPayload }).error\n            }\n          }\n          return Promise.reject<NhostSessionResponse>({ error })\n        }\n      }\n    }\n  )\n}\n","import { interpret } from 'xstate'\n\nimport { AuthMachine, AuthMachineOptions, createAuthMachine } from './machines'\nimport type { AuthInterpreter } from './types'\n\nexport type NhostClientOptions = AuthMachineOptions & {\n  /** @internal create and start xstate interpreter on creation. With React, it is started inside the Nhost provider */\n  start?: boolean\n}\n\n/**\n * @internal\n * This is a private API.\n */\nexport class AuthClient {\n  readonly backendUrl: string\n  readonly clientUrl: string\n  readonly machine: AuthMachine\n  private _interpreter?: AuthInterpreter\n  private _channel?: BroadcastChannel\n  private _subscriptions: Set<(client: AuthClient) => void> = new Set()\n\n  constructor({\n    clientStorageType = 'web',\n    autoSignIn = true,\n    autoRefreshToken = true,\n    start = true,\n    backendUrl,\n    clientUrl,\n    devTools,\n    ...defaultOptions\n  }: NhostClientOptions) {\n    this.backendUrl = backendUrl\n    this.clientUrl = clientUrl\n\n    this.machine = createAuthMachine({\n      ...defaultOptions,\n      backendUrl,\n      clientUrl,\n      clientStorageType,\n      autoSignIn,\n      autoRefreshToken\n    })\n\n    if (start) {\n      this.interpreter = interpret(this.machine, { devTools })\n      this.interpreter.start()\n    }\n\n    if (typeof window !== 'undefined' && autoSignIn) {\n      try {\n        // TODO listen to sign out\n        // TODO the same refresh token is used and refreshed by all tabs\n        // * Ideally, a single tab should autorefresh and share the new jwt\n        this._channel = new BroadcastChannel('nhost')\n        this._channel.addEventListener('message', (token) => {\n          const existingToken = this.interpreter?.state.context.refreshToken.value\n          if (this.interpreter && token.data !== existingToken) {\n            this.interpreter.send('TRY_TOKEN', { token: token.data })\n          }\n        })\n      } catch (error) {\n        // * BroadcastChannel is not available e.g. react-native\n      }\n    }\n  }\n\n  get interpreter(): AuthInterpreter | undefined {\n    return this._interpreter\n  }\n  set interpreter(interpreter: AuthInterpreter | undefined) {\n    this._interpreter = interpreter\n    if (interpreter) {\n      this._subscriptions.forEach((fn) => fn(this))\n    }\n  }\n\n  onStart(fn: (client: AuthClient) => void) {\n    if (this.interpreter) {\n      // * The interpreter is already available: we can add the listener straight ahead\n      fn(this)\n    } else {\n      // * The interpreter is not yet available: we add the listener to a queue that will be started when setting the interpreter\n      // * Note: in React, the Xstate interpreter does not start from the global state, but from the root component\n      this._subscriptions.add(fn)\n    }\n  }\n}\n","import { AuthClient, NhostClientOptions } from './client'\nconst isBrowser = typeof window !== 'undefined'\n\n/** @deprecated Not in use anymore. Use `clientStorageType: 'cookie'` instead */\nexport class AuthCookieClient extends AuthClient {\n  constructor({\n    ...options\n  }: Omit<\n    NhostClientOptions,\n    'clientStorageGetter' | 'clientStorageSetter' | 'clientStorage' | 'clientStorageType'\n  >) {\n    super({\n      ...options,\n      autoSignIn: isBrowser && options.autoSignIn,\n      autoRefreshToken: isBrowser && options.autoRefreshToken,\n      clientStorageType: 'cookie'\n    })\n  }\n}\n\n/** @deprecated Alias for {@link AuthCookieClient} */\nexport const AuthClientSSR = AuthCookieClient\n","import { startRegistration } from '@simplewebauthn/browser'\nimport {\n  PublicKeyCredentialCreationOptionsJSON,\n  RegistrationCredentialJSON\n} from '@simplewebauthn/typescript-types'\n\nimport { AuthClient } from '../client'\nimport { CodifiedError, ErrorPayload } from '../errors'\nimport { nhostApiClient } from '../hasura-auth'\nimport { SecurityKey } from '../types'\n\nimport { ActionErrorState, ActionLoadingState, ActionSuccessState } from './types'\nexport interface AddSecurityKeyHandlerResult extends ActionErrorState, ActionSuccessState {\n  key?: SecurityKey\n}\n\nexport interface AddSecurityKeyState extends AddSecurityKeyHandlerResult, ActionLoadingState {}\n\nexport const addSecurityKeyPromise = async (\n  { backendUrl, interpreter }: AuthClient,\n  nickname?: string\n): Promise<AddSecurityKeyHandlerResult> => {\n  const api = nhostApiClient(backendUrl)\n  try {\n    const { data: options } = await api.post<PublicKeyCredentialCreationOptionsJSON>(\n      '/user/webauthn/add',\n      {},\n      {\n        headers: {\n          authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n        }\n      }\n    )\n    let credential: RegistrationCredentialJSON\n    try {\n      credential = await startRegistration(options)\n    } catch (e) {\n      throw new CodifiedError(e as Error)\n    }\n    const { data: key } = await api.post<SecurityKey>(\n      '/user/webauthn/verify',\n      { credential, nickname },\n      {\n        headers: {\n          authorization: `Bearer ${interpreter?.state.context.accessToken.value}`\n        }\n      }\n    )\n    return { key, isError: false, error: null, isSuccess: true }\n  } catch (e) {\n    const { error } = e as { error: ErrorPayload }\n    return { isError: true, error, isSuccess: false }\n  }\n}\n","import { InterpreterFrom } from 'xstate'\n\nimport { ChangeEmailMachine } from '../machines'\nimport { ChangeEmailOptions } from '../types'\n\nimport { ActionErrorState, ActionLoadingState, NeedsEmailVerificationState } from './types'\nexport interface ChangeEmailHandlerResult extends ActionErrorState, NeedsEmailVerificationState {}\n\nexport interface ChangeEmailState extends ChangeEmailHandlerResult, ActionLoadingState {}\n\nexport const changeEmailPromise = async (\n  interpreter: InterpreterFrom<ChangeEmailMachine>,\n  email: string,\n  options?: ChangeEmailOptions\n): Promise<ChangeEmailHandlerResult> =>\n  new Promise<ChangeEmailHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((s) => {\n      if (s.matches({ idle: 'error' })) {\n        resolve({ error: s.context.error, isError: true, needsEmailVerification: false })\n      } else if (s.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, needsEmailVerification: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { ChangePasswordMachine } from '../machines'\n\nimport { ActionErrorState, ActionLoadingState, ActionSuccessState } from './types'\n\nexport interface ChangePasswordState extends ChangePasswordHandlerResult, ActionLoadingState {}\n\nexport interface ChangePasswordHandlerResult extends ActionErrorState, ActionSuccessState {}\n\nexport const changePasswordPromise = async (\n  interpreter: InterpreterFrom<ChangePasswordMachine>,\n  password: string,\n  ticket?: string\n): Promise<ChangePasswordHandlerResult> =>\n  new Promise<ChangePasswordHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      password, ticket\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSuccess: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSuccess: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { EnableMfadMachine } from '../machines'\n\nimport { ActionErrorState } from './types'\n\nexport interface GenerateQrCodeHandlerResult extends ActionErrorState {\n  qrCodeDataUrl: string\n  isGenerated: boolean\n}\n\nexport interface GenerateQrCodeState extends GenerateQrCodeHandlerResult {\n  isGenerating: boolean\n}\nexport interface ActivateMfaHandlerResult extends ActionErrorState {\n  isActivated: boolean\n}\n\nexport interface ActivateMfaState extends ActivateMfaHandlerResult {\n  isActivating: boolean\n}\n\nexport const generateQrCodePromise = (service: InterpreterFrom<EnableMfadMachine>) =>\n  new Promise<GenerateQrCodeHandlerResult>((resolve) => {\n    service.send('GENERATE')\n    service.onTransition((state) => {\n      if (state.matches('generated')) {\n        resolve({\n          error: null,\n          isError: false,\n          isGenerated: true,\n          qrCodeDataUrl: state.context.imageUrl || ''\n        })\n      } else if (state.matches({ idle: 'error' })) {\n        resolve({\n          error: state.context.error || null,\n          isError: true,\n          isGenerated: false,\n          qrCodeDataUrl: ''\n        })\n      }\n    })\n  })\nexport const activateMfaPromise = (service: InterpreterFrom<EnableMfadMachine>, code: string) =>\n  new Promise<ActivateMfaHandlerResult>((resolve) => {\n    service.send('ACTIVATE', {\n      activeMfaType: 'totp',\n      code\n    })\n    service.onTransition((state) => {\n      if (state.matches({ generated: 'activated' })) {\n        resolve({ error: null, isActivated: true, isError: false })\n      } else if (state.matches({ generated: { idle: 'error' } })) {\n        resolve({ error: state.context.error, isActivated: false, isError: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { ResetPasswordMachine } from '../machines'\nimport { ResetPasswordOptions } from '../types'\n\nimport { ActionErrorState, ActionLoadingState } from './types'\n\nexport interface ResetPasswordHandlerResult extends ActionErrorState {\n  /** Returns `true` when an email to reset the password has been sent */\n  isSent: boolean\n}\n\nexport interface ResetPasswordState extends ResetPasswordHandlerResult, ActionLoadingState {}\n\nexport const resetPasswordPromise = async (\n  interpreter: InterpreterFrom<ResetPasswordMachine>,\n  email: string,\n  options?: ResetPasswordOptions\n): Promise<ResetPasswordHandlerResult> =>\n  new Promise((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSent: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSent: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { SendVerificationEmailMachine } from '../machines'\nimport { SendVerificationEmailOptions } from '../types'\n\nimport { ActionErrorState, ActionLoadingState } from './types'\n\nexport interface SendVerificationEmailHandlerResult extends ActionErrorState {\n  /** Returns `true` when a new verification email has been sent */\n  isSent: boolean\n}\n\nexport interface SendVerificationEmailState\n  extends ActionLoadingState,\n    SendVerificationEmailHandlerResult {}\n\nexport const sendVerificationEmailPromise = (\n  interpreter: InterpreterFrom<SendVerificationEmailMachine>,\n  email: string,\n  options?: SendVerificationEmailOptions\n): Promise<SendVerificationEmailHandlerResult> =>\n  new Promise<SendVerificationEmailHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSent: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSent: true })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../types'\n\nimport { ActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInAnonymousHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInAnonymousState extends SignInAnonymousHandlerResult, ActionLoadingState {}\n\nexport const signInAnonymousPromise = (\n  interpreter: AuthInterpreter\n): Promise<SignInAnonymousHandlerResult> =>\n  new Promise((resolve) => {\n    const { changed } = interpreter.send('SIGNIN_ANONYMOUS')\n    if (!changed) {\n      resolve({\n        isSuccess: false,\n        isError: true,\n        error: USER_ALREADY_SIGNED_IN,\n        user: null,\n        accessToken: null\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          isSuccess: true,\n          isError: false,\n          error: null,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value\n        })\n      }\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          isSuccess: false,\n          isError: true,\n          error: state.context.errors.authentication || null,\n          user: null,\n          accessToken: null\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../types'\n\nimport {\n  ActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInEmailPasswordHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {\n  needsMfaOtp: boolean\n  mfa: {\n    ticket: string\n  } | null\n}\n\nexport interface SignInEmailPasswordState\n  extends SignInEmailPasswordHandlerResult,\n    ActionLoadingState {}\n\nexport const signInEmailPasswordPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  password: string\n) =>\n  new Promise<SignInEmailPasswordHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNIN_PASSWORD', {\n      email,\n      password\n    })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        needsMfaOtp: false,\n        mfa: null,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'needsMfa' } })) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: true,\n          mfa: state.context.mfa,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter, PasswordlessOptions } from '../types'\n\nimport { ActionErrorState, ActionLoadingState, ActionSuccessState } from './types'\nexport interface SignInEmailPasswordlessHandlerResult\n  extends ActionErrorState,\n    ActionSuccessState {}\nexport interface SignInEmailPasswordlessState\n  extends SignInEmailPasswordlessHandlerResult,\n    ActionLoadingState {}\n\nexport const signInEmailPasswordlessPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  options?: PasswordlessOptions\n) =>\n  new Promise<SignInEmailPasswordlessHandlerResult>((resolve) => {\n    const { changed } = interpreter.send('PASSWORDLESS_EMAIL', {\n      email,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({ error: null, isError: false, isSuccess: true })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../types'\n\nimport {\n  ActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInSecurityKeyPasswordlessHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignInSecurityKeyPasswordlessState\n  extends SignInSecurityKeyPasswordlessHandlerResult,\n    ActionLoadingState {}\n\nexport const signInEmailSecurityKeyPromise = (interpreter: AuthInterpreter, email: string) =>\n  new Promise<SignInSecurityKeyPasswordlessHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send({ type: 'SIGNIN_SECURITY_KEY_EMAIL', email })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../types'\n\nimport { ActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInMfaTotpHandlerResult extends SessionActionHandlerResult {}\n\nexport interface SignInMfaTotpState extends SignInMfaTotpHandlerResult, ActionLoadingState {}\n\nexport const signInMfaTotpPromise = (interpreter: AuthInterpreter, otp: string, ticket?: string) =>\n  new Promise<SignInMfaTotpHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNIN_MFA_TOTP', {\n      otp,\n      ticket\n    })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter, PasswordlessOptions } from '../types'\n\nimport { ActionErrorState, ActionLoadingState, ActionSuccessState } from './types'\n\nexport interface SignInSmsPasswordlessState\n  extends SignInSmsPasswordlessHandlerResult,\n    ActionLoadingState {}\n\nexport interface SignInSmsPasswordlessHandlerResult extends ActionErrorState, ActionSuccessState {\n  /**\n   * Returns true when the one-time password has been sent over by SMS, and the user needs to send it back to complete sign-in.\n   */\n  needsOtp: boolean\n}\n\nexport const signInSmsPasswordlessPromise = (\n  interpreter: AuthInterpreter,\n  phoneNumber: string,\n  options?: PasswordlessOptions\n) =>\n  new Promise<SignInSmsPasswordlessHandlerResult>((resolve) => {\n    const { changed } = interpreter.send('PASSWORDLESS_SMS', { phoneNumber, options })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsOtp: false\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.needsOtp')) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsOtp: true\n        })\n      } else if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsOtp: false\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../types'\n\nimport { ActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInSmsPasswordlessOtpHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInSmsPasswordlessOtpState\n  extends SignInSmsPasswordlessOtpHandlerResult,\n    ActionLoadingState {}\n\nexport const signInSmsPasswordlessOtpPromise = (\n  interpreter: AuthInterpreter,\n  phoneNumber: string,\n  otp: string\n) =>\n  new Promise<SignInSmsPasswordlessOtpHandlerResult>((resolve) => {\n    const { changed } = interpreter.send({ type: 'PASSWORDLESS_SMS_OTP', phoneNumber, otp })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: null,\n        accessToken: null\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value\n        })\n      } else if (state.matches({ registration: { incomplete: 'failed' } })) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null,\n          accessToken: null\n        })\n      }\n    })\n  })\n","import { USER_UNAUTHENTICATED } from '../errors'\nimport { AuthInterpreter } from '../types'\n\nimport { ActionErrorState, ActionLoadingState, ActionSuccessState } from './types'\n\nexport interface SignOutlessHandlerResult extends ActionErrorState, ActionSuccessState {}\nexport interface SignOutlessState extends SignOutlessHandlerResult, ActionLoadingState {}\n\nexport const signOutPromise = async (\n  interpreter: AuthInterpreter,\n  all?: boolean\n): Promise<SignOutlessHandlerResult> =>\n  new Promise<SignOutlessHandlerResult>((resolve) => {\n    const { event } = interpreter.send('SIGNOUT', { all })\n    if (event.type !== 'SIGNED_OUT') {\n      return resolve({ isSuccess: false, isError: true, error: USER_UNAUTHENTICATED })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'success' } })) {\n        resolve({ isSuccess: true, isError: false, error: null })\n      } else if (state.matches('authentication.signedOut.failed')) {\n        resolve({ isSuccess: false, isError: true, error: state.context.errors.signout || null })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter, SignUpOptions } from '../types'\n\nimport {\n  ActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignUpEmailPasswordHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignUpEmailPasswordState\n  extends SignUpEmailPasswordHandlerResult,\n    ActionLoadingState {}\n\nexport const signUpEmailPasswordPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  password: string,\n  options?: SignUpOptions\n): Promise<SignUpEmailPasswordHandlerResult> =>\n  new Promise<SignUpEmailPasswordHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNUP_EMAIL_PASSWORD', {\n      email,\n      password,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn', registration: 'complete' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter, SignUpSecurityKeyOptions } from '../types'\n\nimport {\n  ActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignUpSecurityKeyHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignUpSecurityKeyState\n  extends SignUpSecurityKeyHandlerResult,\n    ActionLoadingState {}\n\nexport const signUpEmailSecurityKeyPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  options?: SignUpSecurityKeyOptions\n): Promise<SignUpSecurityKeyHandlerResult> =>\n  new Promise<SignUpSecurityKeyHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNUP_SECURITY_KEY', {\n      email,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          accessToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn', registration: 'complete' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n"]},"metadata":{},"sourceType":"module"}