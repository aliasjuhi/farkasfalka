{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  if (__getOwnPropSymbols) {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols(b)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return a;\n};\nvar __spreadProps = function __spreadProps(a, b) {\n  return __defProps(a, __getOwnPropDescs(b));\n};\nimport jwt_decode from \"jwt-decode\";\nimport { interpret } from \"xstate\";\nimport { AuthClient, signUpEmailSecurityKeyPromise, signUpEmailPasswordPromise, encodeQueryParameters, rewriteRedirectTo, signInEmailPasswordPromise, EMAIL_NEEDS_VERIFICATION, signInEmailSecurityKeyPromise, signInEmailPasswordlessPromise, signInSmsPasswordlessOtpPromise, signInSmsPasswordlessPromise, signInMfaTotpPromise, signInAnonymousPromise, signOutPromise, createResetPasswordMachine, resetPasswordPromise, createChangePasswordMachine, changePasswordPromise, createSendVerificationEmailMachine, sendVerificationEmailPromise, createChangeEmailMachine, changeEmailPromise, addSecurityKeyPromise, NO_REFRESH_TOKEN, TOKEN_REFRESHER_RUNNING_ERROR, INVALID_REFRESH_TOKEN } from \"@nhost/core\";\nvar isBrowser = function isBrowser() {\n  return typeof window !== \"undefined\";\n};\nvar _getSession = function getSession(context) {\n  if (!context || !context.accessToken.value || !context.refreshToken.value || !context.accessToken.expiresAt || !context.user) {\n    return null;\n  }\n  return {\n    accessToken: context.accessToken.value,\n    accessTokenExpiresIn: (context.accessToken.expiresAt.getTime() - Date.now()) / 1e3,\n    refreshToken: context.refreshToken.value,\n    user: context.user\n  };\n};\nvar getAuthenticationResult = function getAuthenticationResult(_ref) {\n  var accessToken = _ref.accessToken,\n    isError = _ref.isError,\n    user = _ref.user,\n    error = _ref.error;\n  if (isError) {\n    return {\n      session: null,\n      error: error\n    };\n  }\n  if (user && accessToken) {\n    return {\n      session: {\n        accessToken: accessToken,\n        accessTokenExpiresIn: 0,\n        refreshToken: \"\",\n        user: user\n      },\n      error: null\n    };\n  }\n  return {\n    session: null,\n    error: null\n  };\n};\nvar HasuraAuthClient = /*#__PURE__*/function () {\n  function HasuraAuthClient(_ref2) {\n    var url = _ref2.url,\n      _ref2$autoRefreshToke = _ref2.autoRefreshToken,\n      autoRefreshToken = _ref2$autoRefreshToke === void 0 ? true : _ref2$autoRefreshToke,\n      _ref2$autoSignIn = _ref2.autoSignIn,\n      autoSignIn = _ref2$autoSignIn === void 0 ? true : _ref2$autoSignIn,\n      autoLogin = _ref2.autoLogin,\n      clientStorage = _ref2.clientStorage,\n      clientStorageType = _ref2.clientStorageType,\n      clientStorageGetter = _ref2.clientStorageGetter,\n      clientStorageSetter = _ref2.clientStorageSetter,\n      refreshIntervalTime = _ref2.refreshIntervalTime,\n      _ref2$start = _ref2.start,\n      start = _ref2$start === void 0 ? true : _ref2$start;\n    _classCallCheck(this, HasuraAuthClient);\n    var _a;\n    this.url = url;\n    this._client = new AuthClient({\n      backendUrl: url,\n      clientUrl: typeof window !== \"undefined\" && ((_a = window.location) == null ? void 0 : _a.origin) || \"\",\n      autoRefreshToken: autoRefreshToken,\n      autoSignIn: typeof autoLogin === \"boolean\" ? autoLogin : autoSignIn,\n      start: start,\n      clientStorage: clientStorage,\n      clientStorageType: clientStorageType,\n      clientStorageGetter: clientStorageGetter,\n      clientStorageSetter: clientStorageSetter,\n      refreshIntervalTime: refreshIntervalTime\n    });\n  }\n  _createClass(HasuraAuthClient, [{\n    key: \"signUp\",\n    value: function () {\n      var _signUp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {\n        var interpreter, email, options;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.waitUntilReady();\n              case 2:\n                interpreter = _context.sent;\n                email = params.email, options = params.options;\n                if (!(\"securityKey\" in params)) {\n                  _context.next = 10;\n                  break;\n                }\n                _context.t0 = getAuthenticationResult;\n                _context.next = 8;\n                return signUpEmailSecurityKeyPromise(interpreter, email, options);\n              case 8:\n                _context.t1 = _context.sent;\n                return _context.abrupt(\"return\", (0, _context.t0)(_context.t1));\n              case 10:\n                _context.t2 = getAuthenticationResult;\n                _context.next = 13;\n                return signUpEmailPasswordPromise(interpreter, email, params.password, options);\n              case 13:\n                _context.t3 = _context.sent;\n                return _context.abrupt(\"return\", (0, _context.t2)(_context.t3));\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function signUp(_x) {\n        return _signUp.apply(this, arguments);\n      }\n      return signUp;\n    }()\n  }, {\n    key: \"signIn\",\n    value: function () {\n      var _signIn = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {\n        var interpreter, provider, options, providerUrl, res, _res, email, _options, _yield$signInEmailPas, error, _res2, _yield$signInSmsPassw, _error, _res3, anonymousResult;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.waitUntilReady();\n              case 2:\n                interpreter = _context2.sent;\n                if (!(\"provider\" in params)) {\n                  _context2.next = 8;\n                  break;\n                }\n                provider = params.provider, options = params.options;\n                providerUrl = encodeQueryParameters(\"\".concat(this._client.backendUrl, \"/signin/provider/\").concat(provider), rewriteRedirectTo(this._client.clientUrl, options));\n                if (isBrowser()) {\n                  window.location.href = providerUrl;\n                }\n                return _context2.abrupt(\"return\", {\n                  providerUrl: providerUrl,\n                  provider: provider,\n                  session: null,\n                  mfa: null,\n                  error: null\n                });\n              case 8:\n                if (!(\"email\" in params && \"password\" in params)) {\n                  _context2.next = 17;\n                  break;\n                }\n                _context2.next = 11;\n                return signInEmailPasswordPromise(interpreter, params.email, params.password);\n              case 11:\n                res = _context2.sent;\n                if (!res.needsEmailVerification) {\n                  _context2.next = 14;\n                  break;\n                }\n                return _context2.abrupt(\"return\", {\n                  session: null,\n                  mfa: null,\n                  error: EMAIL_NEEDS_VERIFICATION\n                });\n              case 14:\n                if (!res.needsMfaOtp) {\n                  _context2.next = 16;\n                  break;\n                }\n                return _context2.abrupt(\"return\", {\n                  session: null,\n                  mfa: res.mfa,\n                  error: null\n                });\n              case 16:\n                return _context2.abrupt(\"return\", __spreadProps(__spreadValues({}, getAuthenticationResult(res)), {\n                  mfa: null\n                }));\n              case 17:\n                if (!(\"email\" in params && \"securityKey\" in params)) {\n                  _context2.next = 24;\n                  break;\n                }\n                if (!(params.securityKey !== true)) {\n                  _context2.next = 20;\n                  break;\n                }\n                throw Error(\"securityKey must be true\");\n              case 20:\n                _context2.next = 22;\n                return signInEmailSecurityKeyPromise(interpreter, params.email);\n              case 22:\n                _res = _context2.sent;\n                return _context2.abrupt(\"return\", __spreadProps(__spreadValues({}, getAuthenticationResult(_res)), {\n                  mfa: null\n                }));\n              case 24:\n                if (!(\"email\" in params)) {\n                  _context2.next = 31;\n                  break;\n                }\n                email = params.email, _options = params.options;\n                _context2.next = 28;\n                return signInEmailPasswordlessPromise(interpreter, email, _options);\n              case 28:\n                _yield$signInEmailPas = _context2.sent;\n                error = _yield$signInEmailPas.error;\n                return _context2.abrupt(\"return\", {\n                  session: null,\n                  mfa: null,\n                  error: error\n                });\n              case 31:\n                if (!(\"phoneNumber\" in params && \"otp\" in params)) {\n                  _context2.next = 36;\n                  break;\n                }\n                _context2.next = 34;\n                return signInSmsPasswordlessOtpPromise(interpreter, params.phoneNumber, params.otp);\n              case 34:\n                _res2 = _context2.sent;\n                return _context2.abrupt(\"return\", __spreadProps(__spreadValues({}, getAuthenticationResult(_res2)), {\n                  mfa: null\n                }));\n              case 36:\n                if (!(\"phoneNumber\" in params)) {\n                  _context2.next = 42;\n                  break;\n                }\n                _context2.next = 39;\n                return signInSmsPasswordlessPromise(interpreter, params.phoneNumber, params.options);\n              case 39:\n                _yield$signInSmsPassw = _context2.sent;\n                _error = _yield$signInSmsPassw.error;\n                return _context2.abrupt(\"return\", {\n                  error: _error,\n                  mfa: null,\n                  session: null\n                });\n              case 42:\n                if (!(\"otp\" in params)) {\n                  _context2.next = 47;\n                  break;\n                }\n                _context2.next = 45;\n                return signInMfaTotpPromise(interpreter, params.otp, params.ticket);\n              case 45:\n                _res3 = _context2.sent;\n                return _context2.abrupt(\"return\", __spreadProps(__spreadValues({}, getAuthenticationResult(_res3)), {\n                  mfa: null\n                }));\n              case 47:\n                _context2.next = 49;\n                return signInAnonymousPromise(interpreter);\n              case 49:\n                anonymousResult = _context2.sent;\n                return _context2.abrupt(\"return\", __spreadProps(__spreadValues({}, getAuthenticationResult(anonymousResult)), {\n                  mfa: null\n                }));\n              case 51:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function signIn(_x2) {\n        return _signIn.apply(this, arguments);\n      }\n      return signIn;\n    }()\n  }, {\n    key: \"signOut\",\n    value: function () {\n      var _signOut = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(params) {\n        var interpreter, _yield$signOutPromise, error;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.waitUntilReady();\n              case 2:\n                interpreter = _context3.sent;\n                _context3.next = 5;\n                return signOutPromise(interpreter, params == null ? void 0 : params.all);\n              case 5:\n                _yield$signOutPromise = _context3.sent;\n                error = _yield$signOutPromise.error;\n                return _context3.abrupt(\"return\", {\n                  error: error\n                });\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function signOut(_x3) {\n        return _signOut.apply(this, arguments);\n      }\n      return signOut;\n    }()\n  }, {\n    key: \"resetPassword\",\n    value: function () {\n      var _resetPassword = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref3) {\n        var email, options, service, _yield$resetPasswordP, error;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                email = _ref3.email, options = _ref3.options;\n                service = interpret(createResetPasswordMachine(this._client)).start();\n                _context4.next = 4;\n                return resetPasswordPromise(service, email, options);\n              case 4:\n                _yield$resetPasswordP = _context4.sent;\n                error = _yield$resetPasswordP.error;\n                return _context4.abrupt(\"return\", {\n                  error: error\n                });\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function resetPassword(_x4) {\n        return _resetPassword.apply(this, arguments);\n      }\n      return resetPassword;\n    }()\n  }, {\n    key: \"changePassword\",\n    value: function () {\n      var _changePassword = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_ref4) {\n        var newPassword, ticket, service, _yield$changePassword, error;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                newPassword = _ref4.newPassword, ticket = _ref4.ticket;\n                service = interpret(createChangePasswordMachine(this._client)).start();\n                _context5.next = 4;\n                return changePasswordPromise(service, newPassword, ticket);\n              case 4:\n                _yield$changePassword = _context5.sent;\n                error = _yield$changePassword.error;\n                return _context5.abrupt(\"return\", {\n                  error: error\n                });\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function changePassword(_x5) {\n        return _changePassword.apply(this, arguments);\n      }\n      return changePassword;\n    }()\n  }, {\n    key: \"sendVerificationEmail\",\n    value: function () {\n      var _sendVerificationEmail = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref5) {\n        var email, options, service, _yield$sendVerificati, error;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                email = _ref5.email, options = _ref5.options;\n                service = interpret(createSendVerificationEmailMachine(this._client)).start();\n                _context6.next = 4;\n                return sendVerificationEmailPromise(service, email, options);\n              case 4:\n                _yield$sendVerificati = _context6.sent;\n                error = _yield$sendVerificati.error;\n                return _context6.abrupt(\"return\", {\n                  error: error\n                });\n              case 7:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function sendVerificationEmail(_x6) {\n        return _sendVerificationEmail.apply(this, arguments);\n      }\n      return sendVerificationEmail;\n    }()\n  }, {\n    key: \"changeEmail\",\n    value: function () {\n      var _changeEmail = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(_ref6) {\n        var newEmail, options, service, _yield$changeEmailPro, error;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                newEmail = _ref6.newEmail, options = _ref6.options;\n                service = interpret(createChangeEmailMachine(this._client)).start();\n                _context7.next = 4;\n                return changeEmailPromise(service, newEmail, options);\n              case 4:\n                _yield$changeEmailPro = _context7.sent;\n                error = _yield$changeEmailPro.error;\n                return _context7.abrupt(\"return\", {\n                  error: error\n                });\n              case 7:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n      function changeEmail(_x7) {\n        return _changeEmail.apply(this, arguments);\n      }\n      return changeEmail;\n    }()\n  }, {\n    key: \"deanonymize\",\n    value: function () {\n      var _deanonymize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(params) {\n        var interpreter, _yield$signInEmailPas2, error, _yield$signInSmsPassw2, _error2, _yield$signUpEmailPas, _error3;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.waitUntilReady();\n              case 2:\n                interpreter = _context8.sent;\n                if (!(params.signInMethod === \"passwordless\")) {\n                  _context8.next = 16;\n                  break;\n                }\n                if (!(params.connection === \"email\")) {\n                  _context8.next = 10;\n                  break;\n                }\n                _context8.next = 7;\n                return signInEmailPasswordlessPromise(interpreter, params.email, params.options);\n              case 7:\n                _yield$signInEmailPas2 = _context8.sent;\n                error = _yield$signInEmailPas2.error;\n                return _context8.abrupt(\"return\", {\n                  error: error\n                });\n              case 10:\n                if (!(params.connection === \"sms\")) {\n                  _context8.next = 16;\n                  break;\n                }\n                _context8.next = 13;\n                return signInSmsPasswordlessPromise(interpreter, params.phoneNumber, params.options);\n              case 13:\n                _yield$signInSmsPassw2 = _context8.sent;\n                _error2 = _yield$signInSmsPassw2.error;\n                return _context8.abrupt(\"return\", {\n                  error: _error2\n                });\n              case 16:\n                if (!(params.signInMethod === \"email-password\")) {\n                  _context8.next = 22;\n                  break;\n                }\n                _context8.next = 19;\n                return signUpEmailPasswordPromise(interpreter, params.email, params.password, params.options);\n              case 19:\n                _yield$signUpEmailPas = _context8.sent;\n                _error3 = _yield$signUpEmailPas.error;\n                return _context8.abrupt(\"return\", {\n                  error: _error3\n                });\n              case 22:\n                throw Error(\"Unknown deanonymization method\");\n              case 23:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n      function deanonymize(_x8) {\n        return _deanonymize.apply(this, arguments);\n      }\n      return deanonymize;\n    }()\n  }, {\n    key: \"addSecurityKey\",\n    value: function () {\n      var _addSecurityKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(nickname) {\n        var _yield$addSecurityKey, error, key;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return addSecurityKeyPromise(this._client, nickname);\n              case 2:\n                _yield$addSecurityKey = _context9.sent;\n                error = _yield$addSecurityKey.error;\n                key = _yield$addSecurityKey.key;\n                return _context9.abrupt(\"return\", {\n                  error: error,\n                  key: key\n                });\n              case 6:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n      function addSecurityKey(_x9) {\n        return _addSecurityKey.apply(this, arguments);\n      }\n      return addSecurityKey;\n    }()\n  }, {\n    key: \"onTokenChanged\",\n    value: function onTokenChanged(fn) {\n      var listen = function listen(interpreter) {\n        return interpreter.onTransition(function (_ref7) {\n          var event = _ref7.event,\n            context = _ref7.context;\n          if (event.type === \"TOKEN_CHANGED\") {\n            fn(_getSession(context));\n          }\n        });\n      };\n      if (this._client.interpreter) {\n        var subscription = listen(this._client.interpreter);\n        return function () {\n          return subscription.stop();\n        };\n      } else {\n        this._client.onStart(function (client) {\n          listen(client.interpreter);\n        });\n        return function () {\n          console.log(\"onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.\");\n        };\n      }\n    }\n  }, {\n    key: \"onAuthStateChanged\",\n    value: function onAuthStateChanged(fn) {\n      var listen = function listen(interpreter) {\n        return interpreter.onTransition(function (_ref8) {\n          var event = _ref8.event,\n            context = _ref8.context;\n          if (event.type === \"SIGNED_IN\" || event.type === \"SIGNED_OUT\") {\n            fn(event.type, _getSession(context));\n          }\n        });\n      };\n      if (this._client.interpreter) {\n        var subscription = listen(this._client.interpreter);\n        return function () {\n          return subscription.stop();\n        };\n      } else {\n        this._client.onStart(function (client) {\n          listen(client.interpreter);\n        });\n        return function () {\n          console.log(\"onAuthStateChanged was added before the interpreter started. Cannot unsubscribe listener.\");\n        };\n      }\n    }\n  }, {\n    key: \"isAuthenticated\",\n    value: function isAuthenticated() {\n      var _a;\n      return !!((_a = this._client.interpreter) == null ? void 0 : _a.state.matches({\n        authentication: \"signedIn\"\n      }));\n    }\n  }, {\n    key: \"isAuthenticatedAsync\",\n    value: function () {\n      var _isAuthenticatedAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var interpreter;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.waitUntilReady();\n              case 2:\n                interpreter = _context10.sent;\n                return _context10.abrupt(\"return\", interpreter.state.matches({\n                  authentication: \"signedIn\"\n                }));\n              case 4:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n      function isAuthenticatedAsync() {\n        return _isAuthenticatedAsync.apply(this, arguments);\n      }\n      return isAuthenticatedAsync;\n    }()\n  }, {\n    key: \"getAuthenticationStatus\",\n    value: function getAuthenticationStatus() {\n      if (!this.isReady()) {\n        return {\n          isAuthenticated: false,\n          isLoading: true\n        };\n      }\n      return {\n        isAuthenticated: this.isAuthenticated(),\n        isLoading: false\n      };\n    }\n  }, {\n    key: \"getJWTToken\",\n    value: function getJWTToken() {\n      return this.getAccessToken();\n    }\n  }, {\n    key: \"getAccessToken\",\n    value: function getAccessToken() {\n      var _a, _b;\n      return (_b = (_a = this._client.interpreter) == null ? void 0 : _a.state.context.accessToken.value) != null ? _b : void 0;\n    }\n  }, {\n    key: \"getDecodedAccessToken\",\n    value: function getDecodedAccessToken() {\n      var jwt = this.getAccessToken();\n      if (!jwt) return null;\n      return jwt_decode(jwt);\n    }\n  }, {\n    key: \"getHasuraClaims\",\n    value: function getHasuraClaims() {\n      var _a;\n      return ((_a = this.getDecodedAccessToken()) == null ? void 0 : _a[\"https://hasura.io/jwt/claims\"]) || null;\n    }\n  }, {\n    key: \"getHasuraClaim\",\n    value: function getHasuraClaim(name) {\n      var _a;\n      return ((_a = this.getHasuraClaims()) == null ? void 0 : _a[name.startsWith(\"x-hasura-\") ? name : \"x-hasura-\".concat(name)]) || null;\n    }\n  }, {\n    key: \"refreshSession\",\n    value: function () {\n      var _refreshSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(refreshToken) {\n        var interpreter;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.prev = 0;\n                _context11.next = 3;\n                return this.waitUntilReady();\n              case 3:\n                interpreter = _context11.sent;\n                return _context11.abrupt(\"return\", new Promise(function (resolve) {\n                  var token = refreshToken || interpreter.state.context.refreshToken.value;\n                  if (!token) {\n                    return resolve({\n                      session: null,\n                      error: NO_REFRESH_TOKEN\n                    });\n                  }\n                  var _interpreter$send = interpreter.send(\"TRY_TOKEN\", {\n                      token: token\n                    }),\n                    changed = _interpreter$send.changed;\n                  if (!changed) {\n                    return resolve({\n                      session: null,\n                      error: TOKEN_REFRESHER_RUNNING_ERROR\n                    });\n                  }\n                  interpreter.onTransition(function (state) {\n                    if (state.matches({\n                      token: {\n                        idle: \"error\"\n                      }\n                    })) {\n                      resolve({\n                        session: null,\n                        error: INVALID_REFRESH_TOKEN\n                      });\n                    } else if (state.event.type === \"TOKEN_CHANGED\") {\n                      resolve({\n                        session: _getSession(state.context),\n                        error: null\n                      });\n                    }\n                  });\n                }));\n              case 7:\n                _context11.prev = 7;\n                _context11.t0 = _context11[\"catch\"](0);\n                return _context11.abrupt(\"return\", {\n                  session: null,\n                  error: _context11.t0.message\n                });\n              case 10:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[0, 7]]);\n      }));\n      function refreshSession(_x10) {\n        return _refreshSession.apply(this, arguments);\n      }\n      return refreshSession;\n    }()\n  }, {\n    key: \"getSession\",\n    value: function getSession() {\n      var _a, _b;\n      return _getSession((_b = (_a = this._client.interpreter) == null ? void 0 : _a.state) == null ? void 0 : _b.context);\n    }\n  }, {\n    key: \"getUser\",\n    value: function getUser() {\n      var _a, _b, _c;\n      return ((_c = (_b = (_a = this._client.interpreter) == null ? void 0 : _a.state) == null ? void 0 : _b.context) == null ? void 0 : _c.user) || null;\n    }\n  }, {\n    key: \"waitUntilReady\",\n    value: function waitUntilReady() {\n      var TIMEOUT_IN_SECONS = 15;\n      var interpreter = this._client.interpreter;\n      if (!interpreter) {\n        throw Error(\"Auth interpreter not set\");\n      }\n      if (!interpreter.state.hasTag(\"loading\")) {\n        return Promise.resolve(interpreter);\n      }\n      return new Promise(function (resolve, reject) {\n        var timer = setTimeout(function () {\n          return reject(\"The state machine is not yet ready after \".concat(TIMEOUT_IN_SECONS, \" seconds.\"));\n        }, TIMEOUT_IN_SECONS * 1e3);\n        interpreter.onTransition(function (state) {\n          if (!state.hasTag(\"loading\")) {\n            clearTimeout(timer);\n            return resolve(interpreter);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"isReady\",\n    value: function isReady() {\n      var _a, _b;\n      return !((_b = (_a = this._client.interpreter) == null ? void 0 : _a.state) == null ? void 0 : _b.hasTag(\"loading\"));\n    }\n  }, {\n    key: \"client\",\n    get: function get() {\n      return this._client;\n    }\n  }]);\n  return HasuraAuthClient;\n}();\nexport { HasuraAuthClient };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEa,gBAAY,SAAZA;EAAA,OAAkB,OAAOC,WAAW;AAAA;AAEpC,kBAAa,SAAbC,WAAcC,SAA+C;EACxE,IACE,CAACA,WACD,CAACA,QAAQC,YAAYC,SACrB,CAACF,QAAQG,aAAaD,SACtB,CAACF,QAAQC,YAAYG,aACrB,CAACJ,QAAQK,MACT;IACO;EACT;EACO;IACLJ,aAAaD,QAAQC,YAAYC;IACjCI,+BAA+BL,YAAYG,UAAUG,YAAYC,KAAKC,SAAS;IAC/EN,cAAcH,QAAQG,aAAaD;IACnCG,MAAML,QAAQK;EAAA;AAElB;AAEO,IAAMK,0BAA0B,SAA1BA,8BAKqC;EAAA,IAJhDT;IACAU;IACAN;IACAO;EAEA,IAAID,SAAS;IACJ;MACLE,SAAS;MACTD;IAAA;EAEJ;EACA,IAAIP,QAAQJ,aAAa;IAChB;MAELY,SAAS;QAAEZ;QAAaK,sBAAsB;QAAGH,cAAc;QAAIE;MAAK;MACxEO,OAAO;IAAA;EAEX;EACA,OAAO;IAAEC,SAAS;IAAMD,OAAO;EAAK;AACtC;AAAA,ICqBaE;EAGX,iCAW+B;IAAA,IAV7BC;MAAA,8BACAC;MAAAA,sDAAmB;MAAA,yBACnBC;MAAAA,2CAAa;MACbC;MACAC;MACAC;MACAC;MACAC;MACAC;MAAA,oBACAC;MAAAA,iCAAQ;IAAA;;IAER,KAAKT,MAAMA;IACN,eAAU,IAAIU,WAAW;MAC5BC,YAAYX;MACZY,WAAY,OAAO7B,WAAW,gBAAe,aAAO8B,aAAP,mBAAiBC,WAAW;MACzEb;MACAC,YAAY,OAAOC,cAAc,YAAYA,YAAYD;MACzDO;MACAL;MACAC;MACAC;MACAC;MACAC;IAAA,CACD;EACH;EAAA;IAAA;IAAA;MAAA,0FAeaO;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OACe,KAAKC;cAAA;gBAAzBC;gBACEC,QAAmBH,OAAnBG,OAAOC,UAAYJ,OAAZI;gBAAA,MACX,iBAAiBJ;kBAAA;kBAAA;gBAAA;gBAAA,cACZpB;gBAAA;gBAAA,OACCyB,8BAA8BH,aAAaC,OAAOC,OAAO,CACjE;cAAA;gBAAA;gBAAA;cAAA;gBAAA,cAEKxB;gBAAA;gBAAA,OACC0B,2BAA2BJ,aAAaC,OAAOH,OAAOO,UAAUH,OAAO,CAC/E;cAAA;gBAAA;gBAAA;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACF;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA,2FAuCEJ;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OAE0B,KAAKC;cAAA;gBAAzBC;gBAAA,MAGF,cAAcF;kBAAA;kBAAA;gBAAA;gBACRQ,WAAsBR,OAAtBQ,UAAUJ,UAAYJ,OAAZI;gBACZK,cAAcC,gCACf,KAAKC,QAAQf,wCAA8BY,WAC9CI,kBAAkB,KAAKD,QAAQd,WAAWO,OAAc,CAC1D;gBACA,IAAIrC,aAAa;kBACfC,OAAO8B,SAASe,OAAOJ;gBACzB;gBAAA,kCACO;kBAAEA;kBAAaD;kBAAUzB,SAAS;kBAAM+B,KAAK;kBAAMhC,OAAO;gBAAA;cAAA;gBAAA,MAI/D,WAAWkB,UAAU,cAAcA;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OACnBe,2BAA2Bb,aAAaF,OAAOG,OAAOH,OAAOO,QAAQ;cAAA;gBAAjFS;gBAAA,KACFA,IAAIC;kBAAA;kBAAA;gBAAA;gBAAA,kCACC;kBAAElC,SAAS;kBAAM+B,KAAK;kBAAMhC,OAAOoC;gBAAA;cAAA;gBAAA,KAExCF,IAAIG;kBAAA;kBAAA;gBAAA;gBAAA,kCACC;kBACLpC,SAAS;kBACT+B,KAAKE,IAAIF;kBACThC,OAAO;gBAAA;cAAA;gBAAA,kCAGJsC,iCAAKxC,wBAAwBoC,GAAG,IAAhC;kBAAmCF,KAAK;gBAAK;cAAA;gBAAA,MAGlD,WAAWd,UAAU,iBAAiBA;kBAAA;kBAAA;gBAAA;gBAAA,MACpCA,OAAOqB,gBAAgB;kBAAA;kBAAA;gBAAA;gBAAA,MACnBC,MAAM,0BAA0B;cAAA;gBAAA;gBAAA,OAEtBC,8BAA8BrB,aAAaF,OAAOG,KAAK;cAAA;gBAAnEa;gBAAA,kCACCI,iCAAKxC,wBAAwBoC,IAAG,IAAhC;kBAAmCF,KAAK;gBAAK;cAAA;gBAAA,MAIlD,WAAWd;kBAAA;kBAAA;gBAAA;gBACLG,QAAmBH,OAAnBG,OAAOC,WAAYJ,OAAZI;gBAAA;gBAAA,OACSoB,+BAA+BtB,aAAaC,OAAOC,QAAO;cAAA;gBAAA;gBAA1EtB;gBAAA,kCACD;kBACLC,SAAS;kBACT+B,KAAK;kBACLhC;gBAAA;cAAA;gBAAA,MAKA,iBAAiBkB,UAAU,SAASA;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OACpByB,gCAAgCvB,aAAaF,OAAO0B,aAAa1B,OAAO2B,GAAG;cAAA;gBAAvFX;gBAAA,kCACCI,iCAAKxC,wBAAwBoC,KAAG,IAAhC;kBAAmCF,KAAK;gBAAK;cAAA;gBAAA,MAIlD,iBAAiBd;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OACK4B,6BACtB1B,aACAF,OAAO0B,aACP1B,OAAOI,OACT;cAAA;gBAAA;gBAJQtB;gBAAA,kCAKD;kBAAEA;kBAAOgC,KAAK;kBAAM/B,SAAS;gBAAK;cAAA;gBAAA,MAIvC,SAASiB;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OACO6B,qBAAqB3B,aAAaF,OAAO2B,KAAK3B,OAAO8B,MAAM;cAAA;gBAAvEd;gBAAA,kCACCI,iCAAKxC,wBAAwBoC,KAAG,IAAhC;kBAAmCF,KAAK;gBAAK;cAAA;gBAAA;gBAAA,OAGxBiB,uBAAuB7B,WAAW;cAAA;gBAA1D8B;gBAAA,kCACCZ,iCAAKxC,wBAAwBoD,eAAe,IAA5C;kBAA+ClB,KAAK;gBAAK;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAClE;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA,4FAmBcd;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OACc,KAAKC;cAAA;gBAAzBC;gBAAA;gBAAA,OACkB+B,eAAe/B,aAAaF,iCAAQkC,GAAG;cAAA;gBAAA;gBAAvDpD;gBAAA,kCACD;kBAAEA;gBAAM;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACjB;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBAYsBqB,qBAAOC;gBACrB+B,UAAUC,UAAUC,2BAA2B,KAAK1B,OAAO,CAAC,EAAEjB;gBAAA;gBAAA,OAC5C4C,qBAAqBH,SAAShC,OAAOC,OAAO;cAAA;gBAAA;gBAA5DtB;gBAAA,kCACD;kBAAEA;gBAAM;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACjB;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBAaEyD,iCACAT;gBAEMK,UAAUC,UAAUI,4BAA4B,KAAK7B,OAAO,CAAC,EAAEjB;gBAAA;gBAAA,OAC7C+C,sBAAsBN,SAASI,aAAaT,MAAM;cAAA;gBAAA;gBAAlEhD;gBAAA,kCACD;kBAAEA;gBAAM;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACjB;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBAaEqB,qBACAC;gBAEM+B,UAAUC,UAAUM,mCAAmC,KAAK/B,OAAO,CAAC,EAAEjB;gBAAA;gBAAA,OACpDiD,6BAA6BR,SAAShC,OAAOC,OAAO;cAAA;gBAAA;gBAApEtB;gBAAA,kCACD;kBAAEA;gBAAM;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACjB;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBAYoB8D,2BAAUxC;gBACtB+B,UAAUC,UAAUS,yBAAyB,KAAKlC,OAAO,CAAC,EAAEjB;gBAAA;gBAAA,OAC1CoD,mBAAmBX,SAASS,UAAUxC,OAAO;cAAA;gBAAA;gBAA7DtB;gBAAA,kCACD;kBAAEA;gBAAM;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACjB;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA,gGAYkBkB;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OACU,KAAKC;cAAA;gBAAzBC;gBAAA,MACFF,OAAO+C,iBAAiB;kBAAA;kBAAA;gBAAA;gBAAA,MACtB/C,OAAOgD,eAAe;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OACAxB,+BACtBtB,aACAF,OAAOG,OACPH,OAAOI,OACT;cAAA;gBAAA;gBAJQtB;gBAAA,kCAKD;kBAAEA;gBAAM;cAAA;gBAAA,MAEbkB,OAAOgD,eAAe;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OACApB,6BACtB1B,aACAF,OAAO0B,aACP1B,OAAOI,OACT;cAAA;gBAAA;gBAJQtB;gBAAA,kCAKD;kBAAEA;gBAAM;cAAA;gBAAA,MAGfkB,OAAO+C,iBAAiB;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OACFzC,2BACtBJ,aACAF,OAAOG,OACPH,OAAOO,UACPP,OAAOI,OACT;cAAA;gBAAA;gBALQtB;gBAAA,kCAMD;kBAAEA;gBAAM;cAAA;gBAAA,MAEXwC,uCAAsC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAC9C;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA,mGASE2B;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OAE6BC,sBAAsB,KAAKvC,SAASsC,QAAQ;cAAA;gBAAA;gBAAjEnE;gBAAOqE;gBAAA,kCACR;kBAAErE;kBAAOqE;gBAAA;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAClB;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA,OAaA,wBAAeC,IAAsC;MAC7C,aAAS,SAATC,OAAUnD;QAAA,OACdA,YAAYoD,aAAa,iBAAwB;UAAA,IAArBC;YAAOrF;UAC7B,UAAMsF,SAAS,iBAAiB;YAC/BJ,eAAWlF,OAAO,CAAC;UACxB;QAAA,CACD;MAAA;MAEC,SAAKyC,QAAQT,aAAa;QAC5B,IAAMuD,eAAeJ,OAAO,KAAK1C,QAAQT,WAAW;QAC7C;UAAA,OAAMuD,aAAaC;QAAA;MAAK,OAC1B;QACA,aAAQC,QAAQ,UAACC,QAAW;UAC/BP,OAAOO,OAAO1D,WAA8B;QAAA,CAC7C;QACD,OAAO,YAAM;UACX2D,QAAQC,IACN,uFACF;QAAA;MAEJ;IACF;EAAA;IAAA;IAAA,OAcA,4BAAmBV,IAAmC;MAC9C,aAAS,SAATC,OAAUnD;QAAA,OACdA,YAAYoD,aAAa,iBAAwB;UAAA,IAArBC;YAAOrF;UACjC,IAAIqF,MAAMC,SAAS,eAAeD,MAAMC,SAAS,cAAc;YAC7DJ,GAAGG,MAAMC,MAAMvF,YAAWC,OAAO,CAAC;UACpC;QAAA,CACD;MAAA;MACC,SAAKyC,QAAQT,aAAa;QAC5B,IAAMuD,eAAeJ,OAAO,KAAK1C,QAAQT,WAAW;QAC7C;UAAA,OAAMuD,aAAaC;QAAA;MAAK,OAC1B;QACA,aAAQC,QAAQ,UAACC,QAAW;UAC/BP,OAAOO,OAAO1D,WAA8B;QAAA,CAC7C;QACD,OAAO,YAAM;UACX2D,QAAQC,IACN,2FACF;QAAA;MAEJ;IACF;EAAA;IAAA;IAAA,OAsBA,2BAA2B;;MAClB,QAAC,EAAC,WAAKnD,QAAQT,gBAAb,mBAA0B6D,MAAMC,QAAQ;QAAEC,gBAAgB;MAAA;IACrE;EAAA;IAAA;IAAA;MAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OAiB4B,KAAKhE;cAAA;gBAAzBC;gBAAA,mCACCA,YAAY6D,MAAMC,QAAQ;kBAAEC,gBAAgB;gBAAA,CAAY;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACjE;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA,OAuBA,mCAGE;MACI,KAAC,KAAKC,WAAW;QACnB,OAAO;UAAEC,iBAAiB;UAAOC,WAAW;QAAK;MACnD;MACA,OAAO;QAAED,iBAAiB,KAAKA,iBAAgB;QAAGC,WAAW;MAAA;IAC/D;EAAA;IAAA;IAAA,OAQA,uBAAkC;MAChC,OAAO,KAAKC;IACd;EAAA;IAAA;IAAA,OAYA,0BAAqC;;MACnC,OAAO,iBAAK1D,QAAQT,gBAAb,mBAA0B6D,MAAM7F,QAAQC,YAAYC,UAApD,YAA6D;IACtE;EAAA;IAAA;IAAA,OAaO,iCAA0C;MACzC,UAAM,KAAKiG;MACjB,IAAI,CAACC,KAAY;MACjB,OAAOC,WAAsBD,GAAG;IAClC;EAAA;IAAA;IAAA,OAaO,2BAA0C;;MACxC,mBAAKE,uBAAsB,KAA3B,mBAA+B,oCAAmC;IAC3E;EAAA;IAAA;IAAA,OAgBO,wBAAeC,MAAwC;;MAE1D,mBAAKC,sBAAL,mBAAyBD,KAAKE,WAAW,WAAW,IAAIF,0BAAmBA,WAAW;IAE1F;EAAA;IAAA;IAAA;MAAA,oGAmBqBpG;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA;gBAAA,OAES,KAAK4B;cAAA;gBAAzBC;gBAAA,mCACC,IAAI0E,QAAQ,UAACC,SAAY;kBAC9B,IAAMC,QAAQzG,gBAAgB6B,YAAY6D,MAAM7F,QAAQG,aAAaD;kBACrE,IAAI,CAAC0G,OAAO;oBACV,OAAOD,QAAQ;sBAAE9F,SAAS;sBAAMD,OAAOiG;oBAAA,CAAkB;kBAC3D;kBACA,wBAAoB7E,YAAY8E,KAAK,aAAa;sBAAEF;oBAAA,CAAO;oBAAnDG;kBACR,IAAI,CAACA,SAAS;oBACZ,OAAOJ,QAAQ;sBAAE9F,SAAS;sBAAMD,OAAOoG;oBAAA,CAA+B;kBACxE;kBACYhF,yBAAa,UAAC6D,OAAU;oBAC9B,UAAMC,QAAQ;sBAAEc,OAAO;wBAAEK,MAAM;sBAAU;oBAAA,CAAC,GAAG;sBACvCN;wBACN9F,SAAS;wBAETD,OAAOsG;sBAAA,CACR;oBACQ,iBAAM7B,MAAMC,SAAS,iBAAiB;sBACvCqB;wBAAE9F,SAASd,YAAW8F,MAAM7F,OAAO;wBAAGY,OAAO;sBAAA,CAAM;oBAC7D;kBAAA,CACD;gBAAA,CACF;cAAA;gBAAA;gBAAA;gBAAA,mCAGM;kBAAEC,SAAS;kBAAMD,OAAO,cAAMuG;gBAAQ;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEjD;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA,OAaA,sBAAa;;MACX,OAAOpH,YAAW,iBAAK0C,QAAQT,gBAAb,mBAA0B6D,UAA1B,mBAAiC7F,OAAO;IAC5D;EAAA;IAAA;IAAA,OAaA,mBAAU;;MACR,OAAO,wBAAKyC,QAAQT,gBAAb,mBAA0B6D,UAA1B,mBAAiC7F,YAAjC,mBAA0CK,SAAQ;IAC3D;EAAA;IAAA;IAAA,OAMQ,0BAA2C;MACjD,IAAM+G,oBAAoB;MACpB,kBAAc,KAAK3E,QAAQT;MACjC,IAAI,CAACA,aAAa;QAChB,MAAMoB,MAAM,0BAA0B;MACxC;MACA,IAAI,CAACpB,YAAY6D,MAAMwB,OAAO,SAAS,GAAG;QACjC,eAAQV,QAAQ3E,WAAW;MACpC;MACA,OAAO,IAAI0E,QAAQ,UAACC,SAASW,QAAW;QAClC,YAAuCC,WACzC;UAAA,OAAMD,0DAAmDF,gCAA4B;QAAA,GACrFA,oBAAoB,GACtB;QACYpF,yBAAa,UAAC6D,OAAU;UAClC,IAAI,CAACA,MAAMwB,OAAO,SAAS,GAAG;YAC5BG,aAAaC,KAAK;YAClB,OAAOd,QAAQ3E,WAAW;UAC5B;QAAA,CACD;MAAA,CACF;IACH;EAAA;IAAA;IAAA,OAEQ,mBAAU;;MAChB,OAAO,EAAC,iBAAKS,QAAQT,gBAAb,mBAA0B6D,UAA1B,mBAAiCwB,OAAO;IAClD;EAAA;IAAA;IAAA,oBAEa;MACX,OAAO,KAAK5E;IACd;EAAA;EAAA;AAAA","names":["isBrowser","window","getSession","context","accessToken","value","refreshToken","expiresAt","user","accessTokenExpiresIn","getTime","Date","now","getAuthenticationResult","isError","error","session","HasuraAuthClient","url","autoRefreshToken","autoSignIn","autoLogin","clientStorage","clientStorageType","clientStorageGetter","clientStorageSetter","refreshIntervalTime","start","AuthClient","backendUrl","clientUrl","location","origin","params","waitUntilReady","interpreter","email","options","signUpEmailSecurityKeyPromise","signUpEmailPasswordPromise","password","provider","providerUrl","encodeQueryParameters","_client","rewriteRedirectTo","href","mfa","signInEmailPasswordPromise","res","needsEmailVerification","EMAIL_NEEDS_VERIFICATION","needsMfaOtp","__spreadProps","securityKey","Error","signInEmailSecurityKeyPromise","signInEmailPasswordlessPromise","signInSmsPasswordlessOtpPromise","phoneNumber","otp","signInSmsPasswordlessPromise","signInMfaTotpPromise","ticket","signInAnonymousPromise","anonymousResult","signOutPromise","all","service","interpret","createResetPasswordMachine","resetPasswordPromise","newPassword","createChangePasswordMachine","changePasswordPromise","createSendVerificationEmailMachine","sendVerificationEmailPromise","newEmail","createChangeEmailMachine","changeEmailPromise","signInMethod","connection","nickname","addSecurityKeyPromise","key","fn","listen","onTransition","event","type","subscription","stop","onStart","client","console","log","state","matches","authentication","isReady","isAuthenticated","isLoading","getAccessToken","jwt","jwt_decode","getDecodedAccessToken","name","getHasuraClaims","startsWith","Promise","resolve","token","NO_REFRESH_TOKEN","send","changed","TOKEN_REFRESHER_RUNNING_ERROR","idle","INVALID_REFRESH_TOKEN","message","TIMEOUT_IN_SECONS","hasTag","reject","setTimeout","clearTimeout","timer"],"sources":["C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\hasura-auth-js\\src\\utils\\helpers.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\hasura-auth-js\\src\\hasura-auth-client.ts"],"sourcesContent":["import { AuthContext, NhostSession, SessionActionHandlerResult, SignUpResponse } from '@nhost/core'\n\nexport const isBrowser = () => typeof window !== 'undefined'\n\nexport const getSession = (context?: AuthContext): NhostSession | null => {\n  if (\n    !context ||\n    !context.accessToken.value ||\n    !context.refreshToken.value ||\n    !context.accessToken.expiresAt ||\n    !context.user\n  ) {\n    return null\n  }\n  return {\n    accessToken: context.accessToken.value,\n    accessTokenExpiresIn: (context.accessToken.expiresAt.getTime() - Date.now()) / 1000,\n    refreshToken: context.refreshToken.value,\n    user: context.user\n  }\n}\n\nexport const getAuthenticationResult = ({\n  accessToken,\n  isError,\n  user,\n  error\n}: SessionActionHandlerResult): SignUpResponse => {\n  if (isError) {\n    return {\n      session: null,\n      error\n    }\n  }\n  if (user && accessToken) {\n    return {\n      // TODO either return the refresh token or remove it from the session type\n      session: { accessToken, accessTokenExpiresIn: 0, refreshToken: '', user },\n      error: null\n    }\n  }\n  return { session: null, error: null }\n}\n","import jwt_decode from 'jwt-decode'\nimport { interpret } from 'xstate'\n\nimport {\n  addSecurityKeyPromise,\n  AuthClient,\n  AuthInterpreter,\n  changeEmailPromise,\n  ChangeEmailResponse,\n  changePasswordPromise,\n  ChangePasswordResponse,\n  createChangeEmailMachine,\n  createChangePasswordMachine,\n  createResetPasswordMachine,\n  createSendVerificationEmailMachine,\n  DeanonymizeResponse,\n  EMAIL_NEEDS_VERIFICATION,\n  encodeQueryParameters,\n  ErrorPayload,\n  INVALID_REFRESH_TOKEN,\n  JWTClaims,\n  JWTHasuraClaims,\n  NhostSessionResponse,\n  NO_REFRESH_TOKEN,\n  resetPasswordPromise,\n  ResetPasswordResponse,\n  rewriteRedirectTo,\n  SecurityKey,\n  sendVerificationEmailPromise,\n  SendVerificationEmailResponse,\n  signInAnonymousPromise,\n  signInEmailPasswordlessPromise,\n  signInEmailPasswordPromise,\n  signInEmailSecurityKeyPromise,\n  signInMfaTotpPromise,\n  SignInResponse,\n  signInSmsPasswordlessOtpPromise,\n  signInSmsPasswordlessPromise,\n  signOutPromise,\n  SignOutResponse,\n  signUpEmailPasswordPromise,\n  signUpEmailSecurityKeyPromise,\n  SignUpResponse,\n  TOKEN_REFRESHER_RUNNING_ERROR\n} from '@nhost/core'\n\nimport { getAuthenticationResult, getSession, isBrowser } from './utils/helpers'\nimport {\n  AuthChangedFunction,\n  ChangeEmailParams,\n  ChangePasswordParams,\n  DeanonymizeParams,\n  NhostAuthConstructorParams,\n  OnTokenChangedFunction,\n  ResetPasswordParams,\n  SendVerificationEmailParams,\n  SignInParams,\n  SignUpParams\n} from './utils/types'\n\n/**\n * @alias Auth\n */\nexport class HasuraAuthClient {\n  private _client: AuthClient\n  readonly url: string\n  constructor({\n    url,\n    autoRefreshToken = true,\n    autoSignIn = true,\n    autoLogin,\n    clientStorage,\n    clientStorageType,\n    clientStorageGetter,\n    clientStorageSetter,\n    refreshIntervalTime,\n    start = true\n  }: NhostAuthConstructorParams) {\n    this.url = url\n    this._client = new AuthClient({\n      backendUrl: url,\n      clientUrl: (typeof window !== 'undefined' && window.location?.origin) || '',\n      autoRefreshToken,\n      autoSignIn: typeof autoLogin === 'boolean' ? autoLogin : autoSignIn,\n      start,\n      clientStorage,\n      clientStorageType,\n      clientStorageGetter,\n      clientStorageSetter,\n      refreshIntervalTime\n    })\n  }\n\n  /**\n   * Use `nhost.auth.signUp` to sign up a user using email and password. If you want to sign up a user using passwordless email (Magic Link), SMS, or an OAuth provider, use the `signIn` function instead.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-up\n   */\n  async signUp(params: SignUpParams): Promise<SignUpResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { email, options } = params\n    if ('securityKey' in params) {\n      return getAuthenticationResult(\n        await signUpEmailSecurityKeyPromise(interpreter, email, options)\n      )\n    }\n    return getAuthenticationResult(\n      await signUpEmailPasswordPromise(interpreter, email, params.password, options)\n    )\n  }\n\n  /**\n   * Use `nhost.auth.signIn` to sign in a user using email and password, passwordless (email or sms) or an external provider. `signIn` can be used to sign in a user in various ways depending on the parameters.\n   *\n   * @example\n   * ### Sign in a user using email and password\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using an OAuth provider (e.g: Google or Facebook)\n   * ```ts\n   * nhost.auth.signIn({ provider: 'google' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless email (Magic Link)\n   * ```ts\n   * nhost.auth.signIn({ email: 'joe@example.com' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless SMS\n   * ```ts\n   * // [step 1/2] Passwordless sign in using SMS\n   * nhost.auth.signIn({ phoneNumber: '+11233213123' })\n   *\n   * // [step 2/2] Finish passwordless sign in using SMS (OTP)\n   * nhost.auth.signIn({ phoneNumber: '+11233213123', otp: '123456' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in\n   */\n  async signIn(\n    params: SignInParams\n  ): Promise<SignInResponse & { providerUrl?: string; provider?: string }> {\n    const interpreter = await this.waitUntilReady()\n\n    // * Sign in with a social provider (OAuth)\n    if ('provider' in params) {\n      const { provider, options } = params\n      const providerUrl = encodeQueryParameters(\n        `${this._client.backendUrl}/signin/provider/${provider}`,\n        rewriteRedirectTo(this._client.clientUrl, options as any)\n      )\n      if (isBrowser()) {\n        window.location.href = providerUrl\n      }\n      return { providerUrl, provider, session: null, mfa: null, error: null }\n    }\n\n    // * Email + password\n    if ('email' in params && 'password' in params) {\n      const res = await signInEmailPasswordPromise(interpreter, params.email, params.password)\n      if (res.needsEmailVerification) {\n        return { session: null, mfa: null, error: EMAIL_NEEDS_VERIFICATION }\n      }\n      if (res.needsMfaOtp) {\n        return {\n          session: null,\n          mfa: res.mfa,\n          error: null\n        }\n      }\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    if ('email' in params && 'securityKey' in params) {\n      if (params.securityKey !== true) {\n        throw Error('securityKey must be true')\n      }\n      const res = await signInEmailSecurityKeyPromise(interpreter, params.email)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless Email (magic link)\n    if ('email' in params) {\n      const { email, options } = params\n      const { error } = await signInEmailPasswordlessPromise(interpreter, email, options)\n      return {\n        session: null,\n        mfa: null,\n        error\n      }\n    }\n\n    // * Passwordless SMS: [step 2/2] sign in using SMS OTP\n    if ('phoneNumber' in params && 'otp' in params) {\n      const res = await signInSmsPasswordlessOtpPromise(interpreter, params.phoneNumber, params.otp)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless SMS: [step 1/2] sign in using SMS\n    if ('phoneNumber' in params) {\n      const { error } = await signInSmsPasswordlessPromise(\n        interpreter,\n        params.phoneNumber,\n        params.options\n      )\n      return { error, mfa: null, session: null }\n    }\n\n    // * Email + password MFA TOTP\n    if ('otp' in params) {\n      const res = await signInMfaTotpPromise(interpreter, params.otp, params.ticket)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n    // * Anonymous sign-in\n    const anonymousResult = await signInAnonymousPromise(interpreter)\n    return { ...getAuthenticationResult(anonymousResult), mfa: null }\n  }\n\n  /**\n   * Use `nhost.auth.signOut` to sign out the user.\n   *\n   * @example\n   * ### Sign out the user from current device\n   * ```ts\n   * nhost.auth.signOut()\n   * ```\n   *\n   * @example\n   * ### Sign out the user from all devices\n   * ```ts\n   * nhost.auth.signOut({all: true})\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-out\n   */\n  async signOut(params?: { all?: boolean }): Promise<SignOutResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { error } = await signOutPromise(interpreter, params?.all)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.resetPassword` to reset the password for a user. This will send a reset-password link in an email to the user. When the user clicks the reset-password link the user is automatically signed-in. Once signed-in, the user can change their password using `nhost.auth.changePassword()`.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.resetPassword({email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/reset-password\n   */\n  async resetPassword({ email, options }: ResetPasswordParams): Promise<ResetPasswordResponse> {\n    const service = interpret(createResetPasswordMachine(this._client)).start()\n    const { error } = await resetPasswordPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changePassword` to change the password for the signed-in user. The old password is not needed. In case the user is not signed-in, a password reset ticket needs to be provided.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changePassword({ newPassword: 'new-secret-password' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-password\n   */\n  async changePassword({\n    newPassword,\n    ticket\n  }: ChangePasswordParams): Promise<ChangePasswordResponse> {\n    const service = interpret(createChangePasswordMachine(this._client)).start()\n    const { error } = await changePasswordPromise(service, newPassword, ticket)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.sendVerificationEmail` to send a verification email to the specified email. The email contains a verification-email link. When the user clicks the verification-email link their email is verified.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.sendVerificationEmail({ email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/send-verification-email\n   */\n  async sendVerificationEmail({\n    email,\n    options\n  }: SendVerificationEmailParams): Promise<SendVerificationEmailResponse> {\n    const service = interpret(createSendVerificationEmailMachine(this._client)).start()\n    const { error } = await sendVerificationEmailPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changeEmail` to change a user's email. This will send a confirm-email-change link in an email to the new email. Once the user clicks on the confirm-email-change link the email will be change to the new email.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changeEmail({ newEmail: 'doe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-email\n   */\n  async changeEmail({ newEmail, options }: ChangeEmailParams): Promise<ChangeEmailResponse> {\n    const service = interpret(createChangeEmailMachine(this._client)).start()\n    const { error } = await changeEmailPromise(service, newEmail, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.deanonymize` to deanonymize a user.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.deanonymize({signInMethod: 'email-password', email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/deanonymize\n   */\n  async deanonymize(params: DeanonymizeParams): Promise<DeanonymizeResponse> {\n    const interpreter = await this.waitUntilReady()\n    if (params.signInMethod === 'passwordless') {\n      if (params.connection === 'email') {\n        const { error } = await signInEmailPasswordlessPromise(\n          interpreter,\n          params.email,\n          params.options\n        )\n        return { error }\n      }\n      if (params.connection === 'sms') {\n        const { error } = await signInSmsPasswordlessPromise(\n          interpreter,\n          params.phoneNumber,\n          params.options\n        )\n        return { error }\n      }\n    }\n    if (params.signInMethod === 'email-password') {\n      const { error } = await signUpEmailPasswordPromise(\n        interpreter,\n        params.email,\n        params.password,\n        params.options\n      )\n      return { error }\n    }\n    throw Error(`Unknown deanonymization method`)\n  }\n\n  /**\n   * Use `nhost.auth.addSecurityKey to add a security key to the user, using the WebAuthn API.\n   * @param nickname optional human-readable nickname for the security key\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/add-security-key\n   */\n  async addSecurityKey(\n    nickname?: string\n  ): Promise<{ error: ErrorPayload | null; key?: SecurityKey }> {\n    const { error, key } = await addSecurityKeyPromise(this._client, nickname)\n    return { error, key }\n  }\n\n  /**\n   * Use `nhost.auth.onTokenChanged` to add a custom function that runs every time the access or refresh token is changed.\n   *\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onTokenChanged(() => console.log('The access and refresh token has changed'));\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-token-changed\n   */\n  onTokenChanged(fn: OnTokenChangedFunction): Function {\n    const listen = (interpreter: AuthInterpreter) =>\n      interpreter.onTransition(({ event, context }) => {\n        if (event.type === 'TOKEN_CHANGED') {\n          fn(getSession(context))\n        }\n      })\n\n    if (this._client.interpreter) {\n      const subscription = listen(this._client.interpreter)\n      return () => subscription.stop()\n    } else {\n      this._client.onStart((client) => {\n        listen(client.interpreter as AuthInterpreter)\n      })\n      return () => {\n        console.log(\n          'onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.'\n        )\n      }\n    }\n  }\n\n  /**\n   * Use `nhost.auth.onAuthStateChanged` to add a custom function that runs every time the authentication status of the user changes. E.g. add a custom function that runs every time the authentication status changes from signed-in to signed-out.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onAuthStateChanged((event, session) => {\n   *   console.log(`The auth state has changed. State is now ${event} with session: ${session}`)\n   * });\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-auth-state-changed\n   */\n  onAuthStateChanged(fn: AuthChangedFunction): Function {\n    const listen = (interpreter: AuthInterpreter) =>\n      interpreter.onTransition(({ event, context }) => {\n        if (event.type === 'SIGNED_IN' || event.type === 'SIGNED_OUT') {\n          fn(event.type, getSession(context))\n        }\n      })\n    if (this._client.interpreter) {\n      const subscription = listen(this._client.interpreter)\n      return () => subscription.stop()\n    } else {\n      this._client.onStart((client) => {\n        listen(client.interpreter as AuthInterpreter)\n      })\n      return () => {\n        console.log(\n          'onAuthStateChanged was added before the interpreter started. Cannot unsubscribe listener.'\n        )\n      }\n    }\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticated` to check if the user is authenticated or not.\n   *\n   * Note: `nhost.auth.isAuthenticated()` can return `false` for two reasons:\n   * 1. The user is not authenticated\n   * 2. The user is not authenticated but _might_ be authenticated soon (loading) because there is a network request in transit.\n   *\n   * Use `nhost.auth.getAuthenticationStatus` to get both authentication and loading status.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated = nhost.auth.isAuthenticated();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated\n   */\n  isAuthenticated(): boolean {\n    return !!this._client.interpreter?.state.matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticatedAsync` to wait (await) for any internal authentication network requests to finish and then return the authentication status.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated  = await nhost.auth.isAuthenticatedAsync();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated-async\n   */\n  async isAuthenticatedAsync(): Promise<boolean> {\n    const interpreter = await this.waitUntilReady()\n    return interpreter.state.matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.getAuthenticationStatus` to get the authentication status of the user.\n   *\n   * If `isLoading` is `true`, the client doesn't know whether the user is authenticated yet or not\n   * because some internal authentication network requests have not been resolved yet.\n   *\n   * @example\n   * ```ts\n   * const { isAuthenticated, isLoading } = nhost.auth.getAuthenticationStatus();\n   *\n   * if (isLoading) {\n   *   console.log('Loading...')\n   * }\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-authentication-status\n   */\n  getAuthenticationStatus(): {\n    isAuthenticated: boolean\n    isLoading: boolean\n  } {\n    if (!this.isReady()) {\n      return { isAuthenticated: false, isLoading: true }\n    }\n    return { isAuthenticated: this.isAuthenticated(), isLoading: false }\n  }\n\n  /**\n   * @internal\n   * @deprecated Use `nhost.auth.getAccessToken()` instead.\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token\n   */\n\n  getJWTToken(): string | undefined {\n    return this.getAccessToken()\n  }\n\n  /**\n   * Use `nhost.auth.getAccessToken` to get the access token of the user.\n   *\n   * @example\n   * ```ts\n   * const accessToken = nhost.auth.getAccessToken();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token\n   */\n  getAccessToken(): string | undefined {\n    return this._client.interpreter?.state.context.accessToken.value ?? undefined\n  }\n\n  /**\n   * Use `nhost.auth.getDecodedAccessToken` to get the decoded access token of the user.\n   *\n   * @example\n   * ```ts\n   * const decodedAccessToken = nhost.auth.getDecodedAccessToken();\n   * ```\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-decoded-access-token\n   */\n  public getDecodedAccessToken(): JWTClaims | null {\n    const jwt = this.getAccessToken()\n    if (!jwt) return null\n    return jwt_decode<JWTClaims>(jwt)\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaims` to get the Hasura claims of the user.\n   *\n   * @example\n   * ```ts\n   * const hasuraClaims = nhost.auth.getHasuraClaims();\n   * ```\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claims\n   */\n  public getHasuraClaims(): JWTHasuraClaims | null {\n    return this.getDecodedAccessToken()?.['https://hasura.io/jwt/claims'] || null\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaim` to get the value of a specific Hasura claim of the user.\n   *\n   * @example\n   * ```ts\n   * // if `x-hasura-company-id` exists as a custom claim\n   * const companyId = nhost.auth.getHsauraClaim('company-id')\n   * ```\n   *\n   * @param name Name of the variable. You don't have to specify `x-hasura-`.\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claim\n   */\n  public getHasuraClaim(name: string): string | string[] | null {\n    return (\n      this.getHasuraClaims()?.[name.startsWith('x-hasura-') ? name : `x-hasura-${name}`] || null\n    )\n  }\n\n  /**\n   *\n   * Use `nhost.auth.refreshSession` to refresh the session with either the current internal refresh token or an external refresh token.\n   *\n   * Note: The Nhost client automatically refreshes the session when the user is authenticated but `nhost.auth.refreshSession` can be useful in some special cases.\n   *\n   * @example\n   * ```ts\n   * // Refresh the session with the the current internal refresh token.\n   * nhost.auth.refreshToken();\n   *\n   * // Refresh the session with an external refresh token.\n   * nhost.auth.refreshToken(refreshToken);\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/refresh-session\n   */\n  async refreshSession(refreshToken?: string): Promise<NhostSessionResponse> {\n    try {\n      const interpreter = await this.waitUntilReady()\n      return new Promise((resolve) => {\n        const token = refreshToken || interpreter.state.context.refreshToken.value\n        if (!token) {\n          return resolve({ session: null, error: NO_REFRESH_TOKEN })\n        }\n        const { changed } = interpreter.send('TRY_TOKEN', { token })\n        if (!changed) {\n          return resolve({ session: null, error: TOKEN_REFRESHER_RUNNING_ERROR })\n        }\n        interpreter.onTransition((state) => {\n          if (state.matches({ token: { idle: 'error' } })) {\n            resolve({\n              session: null,\n              // * TODO get the error from xstate once it is implemented\n              error: INVALID_REFRESH_TOKEN\n            })\n          } else if (state.event.type === 'TOKEN_CHANGED') {\n            resolve({ session: getSession(state.context), error: null })\n          }\n        })\n      })\n    } catch (error: any) {\n      // TODO return error in the correct format\n      return { session: null, error: error.message }\n    }\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getSession()` to get the session of the user.\n   *\n   * @example\n   * ```ts\n   * const session = nhost.auth.getSession();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-session\n   */\n  getSession() {\n    return getSession(this._client.interpreter?.state?.context)\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getUser()` to get the signed-in user.\n   *\n   * @example\n   * ```ts\n   * const user = nhost.auth.getUser();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-user\n   */\n  getUser() {\n    return this._client.interpreter?.state?.context?.user || null\n  }\n\n  /**\n   * Make sure the state machine is set, and wait for it to be ready\n   * @returns\n   */\n  private waitUntilReady(): Promise<AuthInterpreter> {\n    const TIMEOUT_IN_SECONS = 15\n    const interpreter = this._client.interpreter\n    if (!interpreter) {\n      throw Error('Auth interpreter not set')\n    }\n    if (!interpreter.state.hasTag('loading')) {\n      return Promise.resolve(interpreter)\n    }\n    return new Promise((resolve, reject) => {\n      let timer: ReturnType<typeof setTimeout> = setTimeout(\n        () => reject(`The state machine is not yet ready after ${TIMEOUT_IN_SECONS} seconds.`),\n        TIMEOUT_IN_SECONS * 1_000\n      )\n      interpreter.onTransition((state) => {\n        if (!state.hasTag('loading')) {\n          clearTimeout(timer)\n          return resolve(interpreter)\n        }\n      })\n    })\n  }\n\n  private isReady() {\n    return !this._client.interpreter?.state?.hasTag('loading')\n  }\n\n  get client() {\n    return this._client\n  }\n}\n"]},"metadata":{},"sourceType":"module"}