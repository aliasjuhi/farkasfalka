{"ast":null,"code":"import _toConsumableArray from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Alias/weboldal/web-login/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  if (__getOwnPropSymbols) {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols(b)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return a;\n};\nvar __spreadProps = function __spreadProps(a, b) {\n  return __defProps(a, __getOwnPropDescs(b));\n};\nimport axios from \"axios\";\nimport FormData$1 from \"form-data\";\nimport { createMachine, assign, spawn, send, actions } from \"xstate\";\nvar HasuraStorageApi = /*#__PURE__*/function () {\n  function HasuraStorageApi(_ref) {\n    var url = _ref.url;\n    _classCallCheck(this, HasuraStorageApi);\n    this.url = url;\n    this.httpClient = axios.create({\n      baseURL: this.url\n    });\n  }\n  _createClass(HasuraStorageApi, [{\n    key: \"upload\",\n    value: function () {\n      var _upload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {\n        var formData, res;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                formData = params.formData;\n                _context.prev = 1;\n                _context.next = 4;\n                return this.httpClient.post(\"/files\", formData, {\n                  headers: __spreadProps(__spreadValues(__spreadValues({}, this.generateUploadHeaders(params)), this.generateAuthHeaders()), {\n                    \"Content-Type\": \"multipart/form-data\"\n                  })\n                });\n              case 4:\n                res = _context.sent;\n                return _context.abrupt(\"return\", {\n                  fileMetadata: res.data,\n                  error: null\n                });\n              case 8:\n                _context.prev = 8;\n                _context.t0 = _context[\"catch\"](1);\n                return _context.abrupt(\"return\", {\n                  fileMetadata: null,\n                  error: _context.t0\n                });\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 8]]);\n      }));\n      function upload(_x) {\n        return _upload.apply(this, arguments);\n      }\n      return upload;\n    }()\n  }, {\n    key: \"getPresignedUrl\",\n    value: function () {\n      var _getPresignedUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {\n        var fileId, res;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                fileId = params.fileId;\n                _context2.next = 4;\n                return this.httpClient.get(\"/files/\".concat(fileId, \"/presignedurl\"), {\n                  headers: __spreadValues({}, this.generateAuthHeaders())\n                });\n              case 4:\n                res = _context2.sent;\n                return _context2.abrupt(\"return\", {\n                  presignedUrl: res.data,\n                  error: null\n                });\n              case 8:\n                _context2.prev = 8;\n                _context2.t0 = _context2[\"catch\"](0);\n                return _context2.abrupt(\"return\", {\n                  presignedUrl: null,\n                  error: _context2.t0\n                });\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 8]]);\n      }));\n      function getPresignedUrl(_x2) {\n        return _getPresignedUrl.apply(this, arguments);\n      }\n      return getPresignedUrl;\n    }()\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(params) {\n        var fileId;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                fileId = params.fileId;\n                _context3.next = 4;\n                return this.httpClient.delete(\"/files/\".concat(fileId), {\n                  headers: __spreadValues({}, this.generateAuthHeaders())\n                });\n              case 4:\n                return _context3.abrupt(\"return\", {\n                  error: null\n                });\n              case 7:\n                _context3.prev = 7;\n                _context3.t0 = _context3[\"catch\"](0);\n                return _context3.abrupt(\"return\", {\n                  error: _context3.t0\n                });\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 7]]);\n      }));\n      function _delete(_x3) {\n        return _delete2.apply(this, arguments);\n      }\n      return _delete;\n    }()\n  }, {\n    key: \"setAccessToken\",\n    value: function setAccessToken(accessToken) {\n      this.accessToken = accessToken;\n      return this;\n    }\n  }, {\n    key: \"setAdminSecret\",\n    value: function setAdminSecret(adminSecret) {\n      this.adminSecret = adminSecret;\n      return this;\n    }\n  }, {\n    key: \"generateUploadHeaders\",\n    value: function generateUploadHeaders(params) {\n      var bucketId = params.bucketId,\n        name = params.name,\n        id = params.id;\n      var uploadheaders = {};\n      if (bucketId) {\n        uploadheaders[\"x-nhost-bucket-id\"] = bucketId;\n      }\n      if (id) {\n        uploadheaders[\"x-nhost-file-id\"] = id;\n      }\n      if (name) {\n        uploadheaders[\"x-nhost-file-name\"] = name;\n      }\n      return uploadheaders;\n    }\n  }, {\n    key: \"generateAuthHeaders\",\n    value: function generateAuthHeaders() {\n      if (!this.adminSecret && !this.accessToken) {\n        return null;\n      }\n      if (this.adminSecret) {\n        return {\n          \"x-hasura-admin-secret\": this.adminSecret\n        };\n      }\n      return {\n        Authorization: \"Bearer \".concat(this.accessToken)\n      };\n    }\n  }]);\n  return HasuraStorageApi;\n}();\nvar HasuraStorageClient = /*#__PURE__*/function () {\n  function HasuraStorageClient(_ref2) {\n    var url = _ref2.url,\n      adminSecret = _ref2.adminSecret;\n    _classCallCheck(this, HasuraStorageClient);\n    this.url = url;\n    this.api = new HasuraStorageApi({\n      url: url\n    });\n    this.setAdminSecret(adminSecret);\n  }\n  _createClass(HasuraStorageClient, [{\n    key: \"upload\",\n    value: function () {\n      var _upload2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(params) {\n        var formData, _yield$this$api$uploa, fileMetadata, error;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (\"file\" in params) {\n                  formData = new FormData$1();\n                  formData.append(\"file\", params.file);\n                } else {\n                  formData = params.formData;\n                }\n                _context4.next = 3;\n                return this.api.upload(__spreadProps(__spreadValues({}, params), {\n                  formData: formData\n                }));\n              case 3:\n                _yield$this$api$uploa = _context4.sent;\n                fileMetadata = _yield$this$api$uploa.fileMetadata;\n                error = _yield$this$api$uploa.error;\n                if (!error) {\n                  _context4.next = 8;\n                  break;\n                }\n                return _context4.abrupt(\"return\", {\n                  fileMetadata: null,\n                  error: error\n                });\n              case 8:\n                if (fileMetadata) {\n                  _context4.next = 10;\n                  break;\n                }\n                return _context4.abrupt(\"return\", {\n                  fileMetadata: null,\n                  error: new Error(\"Invalid file returned\")\n                });\n              case 10:\n                return _context4.abrupt(\"return\", {\n                  fileMetadata: fileMetadata,\n                  error: null\n                });\n              case 11:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function upload(_x4) {\n        return _upload2.apply(this, arguments);\n      }\n      return upload;\n    }()\n  }, {\n    key: \"getUrl\",\n    value: function getUrl(params) {\n      return this.getPublicUrl(params);\n    }\n  }, {\n    key: \"getPublicUrl\",\n    value: function getPublicUrl(params) {\n      var fileId = params.fileId;\n      return \"\".concat(this.url, \"/files/\").concat(fileId);\n    }\n  }, {\n    key: \"getPresignedUrl\",\n    value: function () {\n      var _getPresignedUrl2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(params) {\n        var _yield$this$api$getPr, presignedUrl, error;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.api.getPresignedUrl(params);\n              case 2:\n                _yield$this$api$getPr = _context5.sent;\n                presignedUrl = _yield$this$api$getPr.presignedUrl;\n                error = _yield$this$api$getPr.error;\n                if (!error) {\n                  _context5.next = 7;\n                  break;\n                }\n                return _context5.abrupt(\"return\", {\n                  presignedUrl: null,\n                  error: error\n                });\n              case 7:\n                if (presignedUrl) {\n                  _context5.next = 9;\n                  break;\n                }\n                return _context5.abrupt(\"return\", {\n                  presignedUrl: null,\n                  error: new Error(\"Invalid file id\")\n                });\n              case 9:\n                return _context5.abrupt(\"return\", {\n                  presignedUrl: presignedUrl,\n                  error: null\n                });\n              case 10:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function getPresignedUrl(_x5) {\n        return _getPresignedUrl2.apply(this, arguments);\n      }\n      return getPresignedUrl;\n    }()\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(params) {\n        var _yield$this$api$delet, error;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.api.delete(params);\n              case 2:\n                _yield$this$api$delet = _context6.sent;\n                error = _yield$this$api$delet.error;\n                if (!error) {\n                  _context6.next = 6;\n                  break;\n                }\n                return _context6.abrupt(\"return\", {\n                  error: error\n                });\n              case 6:\n                return _context6.abrupt(\"return\", {\n                  error: null\n                });\n              case 7:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function _delete(_x6) {\n        return _delete3.apply(this, arguments);\n      }\n      return _delete;\n    }()\n  }, {\n    key: \"setAccessToken\",\n    value: function setAccessToken(accessToken) {\n      this.api.setAccessToken(accessToken);\n      return this;\n    }\n  }, {\n    key: \"setAdminSecret\",\n    value: function setAdminSecret(adminSecret) {\n      this.api.setAdminSecret(adminSecret);\n      return this;\n    }\n  }]);\n  return HasuraStorageClient;\n}();\nvar INITIAL_FILE_CONTEXT = {\n  progress: null,\n  loaded: 0,\n  error: null\n};\nvar createFileUploadMachine = function createFileUploadMachine() {\n  return createMachine({\n    preserveActionOrder: true,\n    schema: {\n      context: {},\n      events: {}\n    },\n    tsTypes: {},\n    context: __spreadValues({}, INITIAL_FILE_CONTEXT),\n    initial: \"idle\",\n    on: {\n      DESTROY: {\n        actions: \"sendDestroy\",\n        target: \"stopped\"\n      }\n    },\n    states: {\n      idle: {\n        on: {\n          ADD: {\n            actions: \"addFile\"\n          },\n          UPLOAD: {\n            cond: \"hasFile\",\n            target: \"uploading\"\n          }\n        }\n      },\n      uploading: {\n        entry: \"resetProgress\",\n        on: {\n          UPLOAD_PROGRESS: {\n            actions: [\"incrementProgress\", \"sendProgress\"]\n          },\n          UPLOAD_DONE: \"uploaded\",\n          UPLOAD_ERROR: \"error\",\n          CANCEL: \"idle\"\n        },\n        invoke: {\n          src: \"uploadFile\"\n        }\n      },\n      uploaded: {\n        entry: [\"setFileMetadata\", \"sendDone\"]\n      },\n      error: {\n        entry: [\"setError\", \"sendError\"]\n      },\n      stopped: {\n        type: \"final\"\n      }\n    }\n  }, {\n    guards: {\n      hasFile: function hasFile(context, event) {\n        return !!context.file || !!event.file;\n      }\n    },\n    actions: {\n      incrementProgress: assign({\n        loaded: function loaded(_, _ref3) {\n          var _loaded = _ref3.loaded;\n          return _loaded;\n        },\n        progress: function progress(_, _ref4) {\n          var _progress = _ref4.progress;\n          return _progress;\n        }\n      }),\n      setFileMetadata: assign({\n        id: function id(_, _ref5) {\n          var _id = _ref5.id;\n          return _id;\n        },\n        bucketId: function bucketId(_, _ref6) {\n          var _bucketId = _ref6.bucketId;\n          return _bucketId;\n        },\n        progress: function progress(_) {\n          return 100;\n        }\n      }),\n      setError: assign({\n        error: function error(_, _ref7) {\n          var _error = _ref7.error;\n          return _error;\n        }\n      }),\n      sendProgress: function sendProgress() {},\n      sendError: function sendError() {},\n      sendDestroy: function sendDestroy() {},\n      sendDone: function sendDone() {},\n      resetProgress: assign({\n        progress: function progress(_) {\n          return null;\n        },\n        loaded: function loaded(_) {\n          return 0;\n        }\n      }),\n      addFile: assign({\n        file: function file(_, _ref8) {\n          var _file = _ref8.file;\n          return _file;\n        },\n        bucketId: function bucketId(_, _ref9) {\n          var _bucketId2 = _ref9.bucketId;\n          return _bucketId2;\n        },\n        id: function id(_, _ref10) {\n          var _id2 = _ref10.id;\n          return _id2;\n        }\n      })\n    },\n    services: {\n      uploadFile: function uploadFile(context, event) {\n        return function (callback) {\n          var headers = {\n            \"Content-Type\": \"multipart/form-data\"\n          };\n          var fileId = event.id || context.id;\n          if (fileId) {\n            headers[\"x-nhost-file-id\"] = fileId;\n          }\n          var bucketId = event.bucketId || context.bucketId;\n          if (bucketId) {\n            headers[\"x-nhost-bucket-id\"] = bucketId;\n          }\n          var file = event.file || context.file;\n          headers[\"x-nhost-file-name\"] = event.name || file.name;\n          var data = new FormData();\n          data.append(\"file\", file);\n          if (event.adminSecret) {\n            headers[\"x-hasura-admin-secret\"] = event.adminSecret;\n          }\n          if (event.accessToken) {\n            headers[\"Authorization\"] = \"Bearer \".concat(event.accessToken);\n          }\n          var currentLoaded = 0;\n          var controller = new AbortController();\n          axios.post(event.url + \"/files\", data, {\n            headers: headers,\n            signal: controller.signal,\n            onUploadProgress: function onUploadProgress(event2) {\n              var loaded = Math.round(event2.loaded * file.size / event2.total);\n              var additions = loaded - currentLoaded;\n              currentLoaded = loaded;\n              callback({\n                type: \"UPLOAD_PROGRESS\",\n                progress: Math.round(loaded * 100 / event2.total),\n                loaded: loaded,\n                additions: additions\n              });\n            }\n          }).then(function (_ref11) {\n            var _ref11$data = _ref11.data,\n              id = _ref11$data.id,\n              bucketId2 = _ref11$data.bucketId;\n            callback({\n              type: \"UPLOAD_DONE\",\n              id: id,\n              bucketId: bucketId2\n            });\n          }).catch(function (_ref12) {\n            var response = _ref12.response,\n              message = _ref12.message;\n            var _a, _b, _c, _d, _e;\n            callback({\n              type: \"UPLOAD_ERROR\",\n              error: {\n                status: (_a = response == null ? void 0 : response.status) != null ? _a : 0,\n                message: ((_c = (_b = response == null ? void 0 : response.data) == null ? void 0 : _b.error) == null ? void 0 : _c.message) || message,\n                error: ((_e = (_d = response == null ? void 0 : response.data) == null ? void 0 : _d.error) == null ? void 0 : _e.message) || message\n              }\n            });\n          });\n          return function () {\n            controller.abort();\n          };\n        };\n      }\n    }\n  });\n};\nvar pure = actions.pure,\n  sendParent = actions.sendParent;\nvar createMultipleFilesUploadMachine = function createMultipleFilesUploadMachine() {\n  return createMachine({\n    id: \"files-list\",\n    schema: {\n      context: {},\n      events: {}\n    },\n    tsTypes: {},\n    context: {\n      progress: null,\n      files: [],\n      loaded: 0,\n      total: 0\n    },\n    initial: \"idle\",\n    on: {\n      UPLOAD: {\n        cond: \"hasFileToDownload\",\n        actions: \"addItem\",\n        target: \"uploading\"\n      },\n      ADD: {\n        actions: \"addItem\"\n      },\n      REMOVE: {\n        actions: \"removeItem\"\n      }\n    },\n    states: {\n      idle: {\n        entry: [\"resetProgress\", \"resetLoaded\", \"resetTotal\"],\n        on: {\n          CLEAR: {\n            actions: \"clearList\",\n            target: \"idle\"\n          }\n        }\n      },\n      uploading: {\n        entry: [\"upload\", \"startProgress\", \"resetLoaded\", \"resetTotal\"],\n        on: {\n          UPLOAD_PROGRESS: {\n            actions: [\"incrementProgress\"]\n          },\n          UPLOAD_DONE: [{\n            cond: \"isAllUploaded\",\n            target: \"uploaded\"\n          }, {\n            cond: \"isAllUploadedOrError\",\n            target: \"error\"\n          }],\n          UPLOAD_ERROR: [{\n            cond: \"isAllUploaded\",\n            target: \"uploaded\"\n          }, {\n            cond: \"isAllUploadedOrError\",\n            target: \"error\"\n          }],\n          CANCEL: {\n            actions: \"cancel\",\n            target: \"idle\"\n          }\n        }\n      },\n      uploaded: {\n        entry: \"setUploaded\",\n        on: {\n          CLEAR: {\n            actions: \"clearList\",\n            target: \"idle\"\n          }\n        }\n      },\n      error: {\n        on: {\n          CLEAR: {\n            actions: \"clearList\",\n            target: \"idle\"\n          }\n        }\n      }\n    }\n  }, {\n    guards: {\n      hasFileToDownload: function hasFileToDownload(context, event) {\n        return context.files.some(function (ref) {\n          return ref.getSnapshot().matches(\"idle\");\n        }) || !!event.files;\n      },\n      isAllUploaded: function isAllUploaded(context) {\n        return context.files.every(function (item) {\n          var _a;\n          return (_a = item.getSnapshot()) == null ? void 0 : _a.matches(\"uploaded\");\n        });\n      },\n      isAllUploadedOrError: function isAllUploadedOrError(context) {\n        return context.files.every(function (item) {\n          var snap = item.getSnapshot();\n          return (snap == null ? void 0 : snap.matches(\"error\")) || (snap == null ? void 0 : snap.matches(\"uploaded\"));\n        });\n      }\n    },\n    actions: {\n      incrementProgress: assign(function (context, event) {\n        var loaded = context.loaded + event.additions;\n        var progress = Math.round(loaded * 100 / context.total);\n        return __spreadProps(__spreadValues({}, context), {\n          loaded: loaded,\n          progress: progress\n        });\n      }),\n      setUploaded: assign({\n        progress: function progress(_) {\n          return 100;\n        },\n        loaded: function loaded(_ref13) {\n          var files = _ref13.files;\n          return files.map(function (ref) {\n            return ref.getSnapshot();\n          }).filter(function (snap) {\n            return snap.matches(\"uploaded\");\n          }).reduce(function (agg, curr) {\n            var _a;\n            return agg + ((_a = curr.context.file) == null ? void 0 : _a.size);\n          }, 0);\n        }\n      }),\n      resetTotal: assign({\n        total: function total(_ref14) {\n          var files = _ref14.files;\n          return files.map(function (ref) {\n            return ref.getSnapshot();\n          }).filter(function (snap) {\n            return !snap.matches(\"uploaded\");\n          }).reduce(function (agg, curr) {\n            var _a;\n            return agg + ((_a = curr.context.file) == null ? void 0 : _a.size);\n          }, 0);\n        }\n      }),\n      resetLoaded: assign({\n        loaded: function loaded(_) {\n          return 0;\n        }\n      }),\n      startProgress: assign({\n        progress: function progress(_) {\n          return 0;\n        }\n      }),\n      resetProgress: assign({\n        progress: function progress(_) {\n          return null;\n        }\n      }),\n      addItem: assign(function (context, _ref15) {\n        var files = _ref15.files,\n          bucketId = _ref15.bucketId;\n        var additions = files ? Array.isArray(files) ? files : \"length\" in files ? Array.from(files) : [files] : [];\n        var total = context.total + additions.reduce(function (agg, curr) {\n          return agg + curr.size;\n        }, 0);\n        var progress = Math.round(context.loaded * 100 / total);\n        return {\n          files: [].concat(_toConsumableArray(context.files), _toConsumableArray(additions.map(function (file) {\n            return spawn(createFileUploadMachine().withConfig({\n              actions: {\n                sendProgress: sendParent(function (_, _ref16) {\n                  var additions2 = _ref16.additions;\n                  return {\n                    type: \"UPLOAD_PROGRESS\",\n                    additions: additions2\n                  };\n                }),\n                sendDone: sendParent(\"UPLOAD_DONE\"),\n                sendError: sendParent(\"UPLOAD_ERROR\"),\n                sendDestroy: sendParent(\"REMOVE\")\n              }\n            }).withContext(__spreadProps(__spreadValues({}, INITIAL_FILE_CONTEXT), {\n              file: file,\n              bucketId: bucketId\n            })), {\n              sync: true\n            });\n          }))),\n          total: total,\n          loaded: context.loaded,\n          progress: progress\n        };\n      }),\n      removeItem: assign({\n        files: function files(context) {\n          return context.files.filter(function (ref) {\n            var _a, _b;\n            var stopped = (_a = ref.getSnapshot()) == null ? void 0 : _a.matches(\"stopped\");\n            if (stopped) {\n              (_b = ref.stop) == null ? void 0 : _b.call(ref);\n            }\n            return !stopped;\n          });\n        }\n      }),\n      clearList: pure(function (context) {\n        return context.files.map(function (ref) {\n          return send({\n            type: \"DESTROY\"\n          }, {\n            to: ref.id\n          });\n        });\n      }),\n      upload: pure(function (context, event) {\n        return context.files.map(function (ref) {\n          return send(event, {\n            to: ref.id\n          });\n        });\n      }),\n      cancel: pure(function (context) {\n        return context.files.map(function (ref) {\n          return send({\n            type: \"CANCEL\"\n          }, {\n            to: ref.id\n          });\n        });\n      })\n    }\n  });\n};\nvar uploadFilePromise = /*#__PURE__*/function () {\n  var _ref17 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(nhost, interpreter, params) {\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            return _context7.abrupt(\"return\", new Promise(function (resolve) {\n              interpreter.send(__spreadValues({\n                type: \"UPLOAD\",\n                url: nhost.storage.url,\n                accessToken: nhost.auth.getAccessToken(),\n                adminSecret: nhost.adminSecret\n              }, params));\n              interpreter.subscribe(function (s) {\n                var _a;\n                if (s.matches(\"error\")) {\n                  resolve({\n                    error: s.context.error,\n                    isError: true,\n                    isUploaded: false\n                  });\n                } else if (s.matches(\"uploaded\")) {\n                  resolve({\n                    error: null,\n                    isError: false,\n                    isUploaded: true,\n                    id: s.context.id,\n                    bucketId: s.context.id,\n                    name: (_a = s.context.file) == null ? void 0 : _a.name\n                  });\n                }\n              });\n            }));\n          case 1:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return function uploadFilePromise(_x7, _x8, _x9) {\n    return _ref17.apply(this, arguments);\n  };\n}();\nvar uploadMultipleFilesPromise = /*#__PURE__*/function () {\n  var _ref18 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(nhost, service, params) {\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            return _context8.abrupt(\"return\", new Promise(function (resolve) {\n              service.send({\n                type: \"UPLOAD\",\n                url: nhost.storage.url,\n                accessToken: nhost.auth.getAccessToken(),\n                adminSecret: nhost.adminSecret,\n                bucketId: params == null ? void 0 : params.bucketId,\n                files: params == null ? void 0 : params.files\n              });\n              service.onTransition(function (s) {\n                if (s.matches(\"error\")) {\n                  resolve({\n                    errors: s.context.files.filter(function (ref) {\n                      var _a;\n                      return (_a = ref.getSnapshot()) == null ? void 0 : _a.context.error;\n                    }),\n                    isError: true,\n                    files: []\n                  });\n                } else if (s.matches(\"uploaded\")) {\n                  resolve({\n                    errors: [],\n                    isError: false,\n                    files: s.context.files\n                  });\n                }\n              });\n            }));\n          case 1:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return function uploadMultipleFilesPromise(_x10, _x11, _x12) {\n    return _ref18.apply(this, arguments);\n  };\n}();\nexport { HasuraStorageApi, HasuraStorageClient, INITIAL_FILE_CONTEXT, createFileUploadMachine, createMultipleFilesUploadMachine, uploadFilePromise, uploadMultipleFilesPromise };","map":{"version":3,"mappings":"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","names":["HasuraStorageApi","url","axios","create","baseURL","params","formData","httpClient","post","headers","__spreadProps","generateUploadHeaders","generateAuthHeaders","res","fileMetadata","data","error","fileId","get","__spreadValues","presignedUrl","delete","accessToken","adminSecret","bucketId","name","id","uploadheaders","Authorization","HasuraStorageClient","api","setAdminSecret","FormData","file","upload","Error","getPublicUrl","getPresignedUrl","setAccessToken","INITIAL_FILE_CONTEXT","progress","loaded","createFileUploadMachine","createMachine","preserveActionOrder","schema","context","events","tsTypes","initial","on","DESTROY","actions","target","states","idle","ADD","UPLOAD","cond","uploading","entry","UPLOAD_PROGRESS","UPLOAD_DONE","UPLOAD_ERROR","CANCEL","invoke","src","uploaded","stopped","type","guards","hasFile","event","incrementProgress","assign","_","setFileMetadata","setError","sendProgress","sendError","sendDestroy","sendDone","resetProgress","addFile","services","uploadFile","callback","currentLoaded","AbortController","signal","controller","onUploadProgress","event2","Math","round","size","total","additions","then","bucketId2","catch","response","message","status","abort","pure","sendParent","createMultipleFilesUploadMachine","files","REMOVE","CLEAR","hasFileToDownload","some","ref","getSnapshot","matches","isAllUploaded","every","item","isAllUploadedOrError","snap","setUploaded","map","filter","reduce","agg","curr","resetTotal","resetLoaded","startProgress","addItem","Array","isArray","from","spawn","withConfig","additions2","withContext","sync","removeItem","stop","clearList","send","to","cancel","nhost","interpreter","Promise","resolve","storage","auth","getAccessToken","s","isError","isUploaded","uploadFilePromise","service","errors","uploadMultipleFilesPromise"],"sources":["C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\hasura-storage-js\\src\\hasura-storage-api.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\hasura-storage-js\\src\\hasura-storage-client.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\hasura-storage-js\\src\\machines\\file-upload.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\hasura-storage-js\\src\\machines\\multiple-files-upload.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\hasura-storage-js\\src\\promises\\file-upload.ts","C:\\Users\\Alias\\weboldal\\web-login\\node_modules\\@nhost\\hasura-storage-js\\src\\promises\\multiple-files-upload.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-assignment */\nimport axios, { AxiosInstance } from 'axios'\n\nimport {\n  ApiDeleteParams,\n  ApiDeleteResponse,\n  ApiGetPresignedUrlParams,\n  ApiGetPresignedUrlResponse,\n  ApiUploadParams,\n  ApiUploadResponse,\n  UploadHeaders\n} from './utils/types'\n\n/**\n * @internal\n * This is an internal class.\n */\nexport class HasuraStorageApi {\n  private url: string\n  private httpClient: AxiosInstance\n  private accessToken?: string\n  private adminSecret?: string\n\n  constructor({ url }: { url: string }) {\n    this.url = url\n\n    this.httpClient = axios.create({\n      baseURL: this.url\n    })\n  }\n\n  async upload(params: ApiUploadParams): Promise<ApiUploadResponse> {\n    const { formData } = params\n\n    try {\n      const res = await this.httpClient.post('/files', formData, {\n        headers: {\n          ...this.generateUploadHeaders(params),\n          ...this.generateAuthHeaders(),\n          'Content-Type': 'multipart/form-data'\n        }\n      })\n\n      return { fileMetadata: res.data, error: null }\n    } catch (error) {\n      return { fileMetadata: null, error: error as Error }\n    }\n  }\n\n  async getPresignedUrl(params: ApiGetPresignedUrlParams): Promise<ApiGetPresignedUrlResponse> {\n    try {\n      const { fileId } = params\n      const res = await this.httpClient.get(`/files/${fileId}/presignedurl`, {\n        headers: {\n          ...this.generateAuthHeaders()\n        }\n      })\n      return { presignedUrl: res.data, error: null }\n    } catch (error) {\n      return { presignedUrl: null, error: error as Error }\n    }\n  }\n\n  async delete(params: ApiDeleteParams): Promise<ApiDeleteResponse> {\n    try {\n      const { fileId } = params\n      await this.httpClient.delete(`/files/${fileId}`, {\n        headers: {\n          ...this.generateAuthHeaders()\n        }\n      })\n      return { error: null }\n    } catch (error) {\n      return { error: error as Error }\n    }\n  }\n\n  /**\n   * Set the access token to use for authentication.\n   *\n   * @param accessToken Access token\n   * @returns Hasura Storage API instance\n   */\n  setAccessToken(accessToken?: string): HasuraStorageApi {\n    this.accessToken = accessToken\n\n    return this\n  }\n\n  /**\n   * Set the admin secret to use for authentication.\n   *\n   * @param adminSecret Hasura admin secret\n   * @returns Hasura Storage API instance\n   */\n  setAdminSecret(adminSecret?: string): HasuraStorageApi {\n    this.adminSecret = adminSecret\n\n    return this\n  }\n\n  private generateUploadHeaders(params: ApiUploadParams): UploadHeaders {\n    const { bucketId, name, id } = params\n    const uploadheaders: UploadHeaders = {}\n\n    if (bucketId) {\n      uploadheaders['x-nhost-bucket-id'] = bucketId\n    }\n    if (id) {\n      uploadheaders['x-nhost-file-id'] = id\n    }\n    if (name) {\n      uploadheaders['x-nhost-file-name'] = name\n    }\n\n    return uploadheaders\n  }\n\n  private generateAuthHeaders():\n    | { Authorization: string }\n    | { 'x-hasura-admin-secret': string }\n    | null {\n    if (!this.adminSecret && !this.accessToken) {\n      return null\n    }\n\n    if (this.adminSecret) {\n      return {\n        'x-hasura-admin-secret': this.adminSecret\n      }\n    }\n\n    return {\n      Authorization: `Bearer ${this.accessToken}`\n    }\n  }\n}\n","import FormData from 'form-data'\n\nimport {\n  StorageDeleteParams,\n  StorageDeleteResponse,\n  StorageGetPresignedUrlParams,\n  StorageGetPresignedUrlResponse,\n  StorageGetUrlParams,\n  StorageUploadFileParams,\n  StorageUploadFormDataParams,\n  StorageUploadParams,\n  StorageUploadResponse\n} from './utils/types'\nimport { HasuraStorageApi } from './hasura-storage-api'\n\ninterface NhostStorageConstructorParams {\n  /**\n   * Storage endpoint.\n   */\n  url: string\n  /**\n   * Admin secret. When set, it is sent as an `x-hasura-admin-secret` header for all requests.\n   */\n  adminSecret?: string\n}\n/**\n * @alias Storage\n */\nexport class HasuraStorageClient {\n  readonly url: string\n  private api: HasuraStorageApi\n\n  constructor({ url, adminSecret }: NhostStorageConstructorParams) {\n    this.url = url\n    this.api = new HasuraStorageApi({ url })\n    this.setAdminSecret(adminSecret)\n  }\n\n  /**\n   * Use `nhost.storage.upload` to upload a file. \n   * \n   * It's possible to use [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) or [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) to upload a file. The `File` instance is only available in the browser while `FormData` with [`form-data`](https://www.npmjs.com/package/form-data) works both in the browser and in NodeJS (server).\n   * \n   * If no `bucketId` is specified the bucket `default` is used.\n   *\n   * @example\n   * \n   * Upload a file from a browser using `File`.\n   * \n   * ```ts\n   * await nhost.storage.upload({ file })\n   * ```\n   * \n   * Upload a file from a browser using `File` to a specific Bucket.\n   * \n    @example\n   * ```ts\n   * await nhost.storage.upload({ file, bucketId: '<Bucket-ID>' })\n   * ```\n   * \n   * Upload a file from a server using `FormData` with [`form-data`](https://www.npmjs.com/package/form-data).\n   *\n   * @example\n   * ```ts\n   * const fd = new FormData() \n   * fd.append('file', fs.createReadStream('./tests/assets/sample.pdf'))\n   * \n   * await storage.upload({\n   *   formData: fd\n   * })\n   * ```\n   * \n   * @docs https://docs.nhost.io/reference/javascript/storage/upload\n   */\n\n  async upload(params: StorageUploadFileParams): Promise<StorageUploadResponse>\n  async upload(params: StorageUploadFormDataParams): Promise<StorageUploadResponse>\n  async upload(params: StorageUploadParams): Promise<StorageUploadResponse> {\n    let formData: FormData\n\n    if ('file' in params) {\n      formData = new FormData()\n      formData.append('file', params.file)\n    } else {\n      formData = params.formData\n    }\n\n    const { fileMetadata, error } = await this.api.upload({\n      ...params,\n      formData: formData\n    })\n    if (error) {\n      return { fileMetadata: null, error }\n    }\n\n    if (!fileMetadata) {\n      return { fileMetadata: null, error: new Error('Invalid file returned') }\n    }\n\n    return { fileMetadata, error: null }\n  }\n\n  /**\n   * @deprecated Use `nhost.storage.getPublicUrl()` instead.\n   */\n  getUrl(params: StorageGetUrlParams): string {\n    return this.getPublicUrl(params)\n  }\n\n  /**\n   * Use `nhost.storage.getPublicUrl` to get the public URL of a file. The public URL can be used for un-authenticated users to access files. To access public files the `public` role must have permissions to select the file in the `storage.files` table.\n   *\n   * @example\n   * ```ts\n   * const publicUrl = nhost.storage.getPublicUrl({ fileId: '<File-ID>' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/get-public-url\n   */\n  getPublicUrl(params: StorageGetUrlParams): string {\n    const { fileId } = params\n    return `${this.url}/files/${fileId}`\n  }\n\n  /**\n   * Use `nhost.storage.getPresignedUrl` to get a presigned URL of a file. To get a presigned URL the user must have permission to select the file in the `storage.files` table.\n   *\n   * @example\n   * ```ts\n   * const { presignedUrl, error} = await nhost.storage.getPresignedUrl({ fileId: '<File-ID>' })\n   *\n   * if (error) {\n   *   throw error;\n   * }\n   *\n   * console.log('url: ', presignedUrl.url)\n   * console.log('expiration: ', presignedUrl.expiration)\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/get-presigned-url\n   */\n  async getPresignedUrl(\n    params: StorageGetPresignedUrlParams\n  ): Promise<StorageGetPresignedUrlResponse> {\n    const { presignedUrl, error } = await this.api.getPresignedUrl(params)\n    if (error) {\n      return { presignedUrl: null, error }\n    }\n\n    if (!presignedUrl) {\n      return { presignedUrl: null, error: new Error('Invalid file id') }\n    }\n\n    return { presignedUrl, error: null }\n  }\n\n  /**\n   * Use `nhost.storage.delete` to delete a file. To delete a file the user must have permissions to delete the file in the `storage.files` table. Deleting the file using `nhost.storage.delete()` will delete both the file and its metadata.\n   *\n   * @example\n   * ```ts\n   * const { error } = await nhost.storage.delete({ fileId: 'uuid' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/delete\n   */\n  async delete(params: StorageDeleteParams): Promise<StorageDeleteResponse> {\n    const { error } = await this.api.delete(params)\n    if (error) {\n      return { error }\n    }\n\n    return { error: null }\n  }\n\n  /**\n   * Use `nhost.storage.setAccessToken` to a set an access token to be used in subsequent storage requests. Note that if you're signin in users with `nhost.auth.signIn()` the access token will be set automatically.\n   *\n   * @example\n   * ```ts\n   * nhost.storage.setAccessToken('some-access-token')\n   * ```\n   *\n   * @param accessToken Access token\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/set-access-token\n   */\n  setAccessToken(accessToken?: string): HasuraStorageClient {\n    this.api.setAccessToken(accessToken)\n\n    return this\n  }\n\n  /**\n   * Use `nhost.storage.adminSecret` to set the admin secret to be used for subsequent storage requests. This is useful if you want to run storage in \"admin mode\".\n   *\n   * @example\n   * ```ts\n   * nhost.storage.setAdminSecret('some-admin-secret')\n   * ```\n   *\n   * @param adminSecret Hasura admin secret\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/set-admin-secret\n   */\n  setAdminSecret(adminSecret?: string): HasuraStorageClient {\n    this.api.setAdminSecret(adminSecret)\n\n    return this\n  }\n}\n","import axios, { AxiosError, AxiosRequestHeaders } from 'axios'\nimport { assign, createMachine } from 'xstate'\n\nimport { ErrorPayload } from '@nhost/core'\n\nexport type FileUploadContext = {\n  progress: number | null\n  loaded: number\n  error: ErrorPayload | null\n  id?: string\n  bucketId?: string\n  file?: File\n}\n\nexport type FileUploadEvents =\n  | { type: 'ADD'; file: File; id?: string; bucketId?: string; name?: string }\n  | {\n      type: 'UPLOAD'\n      url: string\n      file?: File\n      id?: string\n      bucketId?: string\n      name?: string\n      accessToken?: string\n      adminSecret?: string\n    }\n  | { type: 'UPLOAD_PROGRESS'; progress: number; loaded: number; additions: number }\n  | { type: 'UPLOAD_DONE'; id: string; bucketId: string }\n  | { type: 'UPLOAD_ERROR'; error: ErrorPayload }\n  | { type: 'CANCEL' }\n  | { type: 'DESTROY' }\n\nexport const INITIAL_FILE_CONTEXT: FileUploadContext = { progress: null, loaded: 0, error: null }\n\nexport type FileUploadMachine = ReturnType<typeof createFileUploadMachine>\nexport const createFileUploadMachine = () =>\n  createMachine(\n    {\n      preserveActionOrder: true,\n      schema: {\n        context: {} as FileUploadContext,\n        events: {} as FileUploadEvents\n      },\n      tsTypes: {} as import('./file-upload.typegen').Typegen0,\n      context: { ...INITIAL_FILE_CONTEXT },\n      initial: 'idle',\n      on: {\n        DESTROY: { actions: 'sendDestroy', target: 'stopped' }\n      },\n      states: {\n        idle: {\n          on: {\n            ADD: { actions: 'addFile' },\n            UPLOAD: { cond: 'hasFile', target: 'uploading' }\n          }\n        },\n        uploading: {\n          entry: 'resetProgress',\n          on: {\n            UPLOAD_PROGRESS: { actions: ['incrementProgress', 'sendProgress'] },\n            UPLOAD_DONE: 'uploaded',\n            UPLOAD_ERROR: 'error',\n            CANCEL: 'idle'\n          },\n          invoke: { src: 'uploadFile' }\n        },\n        uploaded: { entry: ['setFileMetadata', 'sendDone'] },\n        error: { entry: ['setError', 'sendError'] },\n        stopped: { type: 'final' }\n      }\n    },\n    {\n      guards: {\n        hasFile: (context, event) => !!context.file || !!event.file\n      },\n\n      actions: {\n        incrementProgress: assign({\n          loaded: (_, { loaded }) => loaded,\n          progress: (_, { progress }) => progress\n        }),\n        setFileMetadata: assign({\n          id: (_, { id }) => id,\n          bucketId: (_, { bucketId }) => bucketId,\n          progress: (_) => 100\n        }),\n        setError: assign({ error: (_, { error }) => error }),\n        sendProgress: () => {},\n        sendError: () => {},\n        sendDestroy: () => {},\n        sendDone: () => {},\n        resetProgress: assign({ progress: (_) => null, loaded: (_) => 0 }),\n        addFile: assign({\n          file: (_, { file }) => file,\n          bucketId: (_, { bucketId }) => bucketId,\n          id: (_, { id }) => id\n        })\n      },\n      services: {\n        uploadFile: (context, event) => (callback) => {\n          const headers: AxiosRequestHeaders = {\n            'Content-Type': 'multipart/form-data'\n          }\n          const fileId = event.id || context.id\n          if (fileId) {\n            headers['x-nhost-file-id'] = fileId\n          }\n          const bucketId = event.bucketId || context.bucketId\n          if (bucketId) {\n            headers['x-nhost-bucket-id'] = bucketId\n          }\n          const file = (event.file || context.file)!\n          headers['x-nhost-file-name'] = event.name || file.name\n          const data = new FormData()\n          data.append('file', file)\n          if (event.adminSecret) {\n            headers['x-hasura-admin-secret'] = event.adminSecret\n          }\n          if (event.accessToken) {\n            headers['Authorization'] = `Bearer ${event.accessToken}`\n          }\n          let currentLoaded = 0\n          const controller = new AbortController()\n          axios\n            .post<{\n              bucketId: string\n              createdAt: string\n              etag: string\n              id: string\n              isUploaded: true\n              mimeType: string\n              name: string\n              size: number\n              updatedAt: string\n              uploadedByUserId: string\n            }>(event.url + '/files', data, {\n              headers,\n              signal: controller.signal,\n              onUploadProgress: (event: ProgressEvent) => {\n                const loaded = Math.round((event.loaded * file.size!) / event.total)\n                const additions = loaded - currentLoaded\n                currentLoaded = loaded\n                callback({\n                  type: 'UPLOAD_PROGRESS',\n                  progress: Math.round((loaded * 100) / event.total),\n                  loaded,\n                  additions\n                })\n              }\n            })\n            .then(({ data: { id, bucketId } }) => {\n              callback({ type: 'UPLOAD_DONE', id, bucketId })\n            })\n            .catch(({ response, message }: AxiosError<{ error?: { message: string } }>) => {\n              callback({\n                type: 'UPLOAD_ERROR',\n                error: {\n                  status: response?.status ?? 0,\n                  message: response?.data?.error?.message || message,\n                  // TODO errors from hasura-storage are not codified\n                  error: response?.data?.error?.message || message\n                }\n              })\n            })\n\n          return () => {\n            controller.abort()\n          }\n        }\n      }\n    }\n  )\n","import { actions, ActorRefFrom, assign, createMachine, send, spawn } from 'xstate'\n\nimport { createFileUploadMachine, FileUploadMachine, INITIAL_FILE_CONTEXT } from './file-upload'\n\nconst { pure, sendParent } = actions\n\nexport type FileItemRef = ActorRefFrom<FileUploadMachine>\n\nexport type AnyFileList = File | File[] | FileList\n\nexport type MultipleFilesUploadContext = {\n  progress: number | null\n  files: FileItemRef[]\n  loaded: number\n  total: number\n}\n\nexport type MultipleFilesUploadEvents =\n  | { type: 'ADD'; files: AnyFileList; bucketId?: string }\n  | {\n      type: 'UPLOAD'\n      url: string\n      files?: AnyFileList\n      bucketId?: string\n      accessToken?: string\n      adminSecret?: string\n    }\n  | { type: 'UPLOAD_PROGRESS'; additions: number }\n  | { type: 'UPLOAD_DONE' }\n  | { type: 'UPLOAD_ERROR' }\n  | { type: 'CANCEL' }\n  | { type: 'REMOVE' }\n  | { type: 'CLEAR' }\n\nexport type MultipleFilesUploadMachine = ReturnType<typeof createMultipleFilesUploadMachine>\n\nexport const createMultipleFilesUploadMachine = () => {\n  return createMachine(\n    {\n      id: 'files-list',\n      schema: {\n        context: {} as MultipleFilesUploadContext,\n        events: {} as MultipleFilesUploadEvents\n      },\n      tsTypes: {} as import('./multiple-files-upload.typegen').Typegen0,\n      context: {\n        progress: null,\n        files: [],\n        loaded: 0,\n        total: 0\n      },\n      initial: 'idle',\n      on: {\n        UPLOAD: { cond: 'hasFileToDownload', actions: 'addItem', target: 'uploading' },\n        ADD: { actions: 'addItem' },\n        REMOVE: { actions: 'removeItem' }\n      },\n      states: {\n        idle: {\n          entry: ['resetProgress', 'resetLoaded', 'resetTotal'],\n          on: {\n            CLEAR: { actions: 'clearList', target: 'idle' }\n          }\n        },\n        uploading: {\n          entry: ['upload', 'startProgress', 'resetLoaded', 'resetTotal'],\n          on: {\n            UPLOAD_PROGRESS: { actions: ['incrementProgress'] },\n            UPLOAD_DONE: [\n              { cond: 'isAllUploaded', target: 'uploaded' },\n              { cond: 'isAllUploadedOrError', target: 'error' }\n            ],\n            UPLOAD_ERROR: [\n              { cond: 'isAllUploaded', target: 'uploaded' },\n              { cond: 'isAllUploadedOrError', target: 'error' }\n            ],\n            CANCEL: { actions: 'cancel', target: 'idle' }\n          }\n        },\n        uploaded: {\n          entry: 'setUploaded',\n          on: {\n            CLEAR: { actions: 'clearList', target: 'idle' }\n          }\n        },\n        error: {\n          on: {\n            CLEAR: { actions: 'clearList', target: 'idle' }\n          }\n        }\n      }\n    },\n    {\n      guards: {\n        hasFileToDownload: (context, event) =>\n          context.files.some((ref) => ref.getSnapshot()!.matches('idle')) || !!event.files,\n        isAllUploaded: (context) =>\n          context.files.every((item) => item.getSnapshot()?.matches('uploaded')),\n        isAllUploadedOrError: (context) =>\n          context.files.every((item) => {\n            const snap = item.getSnapshot()\n            return snap?.matches('error') || snap?.matches('uploaded')\n          })\n      },\n\n      actions: {\n        incrementProgress: assign((context, event) => {\n          const loaded: number = context.loaded + event.additions\n          const progress = Math.round((loaded * 100) / context.total)\n          return { ...context, loaded, progress }\n        }),\n        setUploaded: assign({\n          progress: (_) => 100,\n          loaded: ({ files }) =>\n            files\n              .map((ref) => ref.getSnapshot()!)\n              .filter((snap) => snap.matches('uploaded'))\n              .reduce((agg, curr) => agg + curr.context.file?.size!, 0)\n        }),\n        resetTotal: assign({\n          total: ({ files }) =>\n            files\n              .map((ref) => ref.getSnapshot()!)\n              .filter((snap) => !snap.matches('uploaded'))\n              .reduce((agg, curr) => agg + curr.context.file?.size!, 0)\n        }),\n        resetLoaded: assign({ loaded: (_) => 0 }),\n        startProgress: assign({ progress: (_) => 0 }),\n        resetProgress: assign({ progress: (_) => null }),\n        addItem: assign((context, { files, bucketId }) => {\n          const additions = files\n            ? Array.isArray(files)\n              ? files // File[]\n              : 'length' in files // FileList\n              ? Array.from(files)\n              : [files] // File\n            : [] // No file\n          const total = context.total + additions.reduce((agg, curr) => agg + curr.size, 0)\n          const progress = Math.round((context.loaded * 100) / total)\n          return {\n            files: [\n              ...context.files,\n              ...additions.map((file) =>\n                spawn(\n                  createFileUploadMachine()\n                    .withConfig({\n                      actions: {\n                        sendProgress: sendParent((_, { additions }) => ({\n                          type: 'UPLOAD_PROGRESS',\n                          additions\n                        })),\n                        sendDone: sendParent('UPLOAD_DONE'),\n                        sendError: sendParent('UPLOAD_ERROR'),\n                        sendDestroy: sendParent('REMOVE')\n                      }\n                    })\n                    .withContext({ ...INITIAL_FILE_CONTEXT, file, bucketId }),\n                  { sync: true }\n                )\n              )\n            ],\n            total,\n            loaded: context.loaded,\n            progress\n          }\n        }),\n        removeItem: assign({\n          files: (context) =>\n            context.files.filter((ref) => {\n              const stopped = ref.getSnapshot()?.matches('stopped')\n              if (stopped) {\n                ref.stop?.()\n              }\n              return !stopped\n            })\n        }),\n        clearList: pure((context) =>\n          context.files.map((ref) => send({ type: 'DESTROY' }, { to: ref.id }))\n        ),\n        upload: pure((context, event) => context.files.map((ref) => send(event, { to: ref.id }))),\n        cancel: pure((context) =>\n          context.files.map((ref) => send({ type: 'CANCEL' }, { to: ref.id }))\n        )\n      }\n    }\n  )\n}\n","import { InterpreterFrom } from 'xstate'\n\nimport { ActionErrorState } from '@nhost/core'\n\nimport { FileItemRef, FileUploadMachine } from '../machines'\nimport { NhostClientReturnType, StorageUploadFileParams } from '../utils/types'\n\nexport interface UploadProgressState {\n  /**\n   * Returns `true` when the file is being uploaded.\n   */\n  isUploading: boolean\n  /**\n   * Returns the progress of the upload, from 0 to 100. Returns null if the upload has not started yet.\n   */\n  progress: number | null\n}\n\nexport interface UploadFileHandlerResult extends ActionErrorState {\n  /**\n   * Returns `true` when the file has been successfully uploaded.\n   */\n  isUploaded: boolean\n  /**\n   * Returns the id of the file.\n   */\n  id?: string\n  /**\n   * Returns the bucket id.\n   */\n  bucketId?: string\n  /**\n   * Returns the name of the file.\n   */\n  name?: string\n}\n\nexport interface FileUploadState extends UploadFileHandlerResult, UploadProgressState {}\n\nexport const uploadFilePromise = async (\n  nhost: NhostClientReturnType,\n  interpreter: FileItemRef | InterpreterFrom<FileUploadMachine>,\n  params: Partial<StorageUploadFileParams>\n): Promise<UploadFileHandlerResult> =>\n  new Promise<UploadFileHandlerResult>((resolve) => {\n    interpreter.send({\n      type: 'UPLOAD',\n      url: nhost.storage.url,\n      accessToken: nhost.auth.getAccessToken(),\n      adminSecret: nhost.adminSecret,\n      ...params\n    })\n    interpreter.subscribe((s) => {\n      if (s.matches('error')) {\n        resolve({\n          error: s.context.error,\n          isError: true,\n          isUploaded: false\n        })\n      } else if (s.matches('uploaded')) {\n        resolve({\n          error: null,\n          isError: false,\n          isUploaded: true,\n          id: s.context.id,\n          bucketId: s.context.id,\n          name: s.context.file?.name\n        })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { AnyFileList, FileItemRef, MultipleFilesUploadMachine } from '../machines'\nimport { NhostClientReturnType } from '../utils/types'\n\nexport interface MultipleUploadProgressState {\n  /**\n   * Returns `true` when the files are being uploaded.\n   */\n  isUploading: boolean\n  /**\n   * Returns the overall progress of the upload, from 0 to 100. Returns null if the upload has not started yet.\n   */\n  progress: number | null\n}\n\nexport interface MultipleFilesHandlerResult {\n  /**\n   * The list of file uploads. The properties can be accessed through `item.getSnapshot()` of with the `useFileUploadItem` hook.\n   */\n  files: FileItemRef[]\n  /**\n   * Returns `true` when all upload request are processed, but at least one of them has failed.\n   */\n  isError: boolean\n  /**\n   * Returns the list of file uploads that have failed\n   */\n  errors: FileItemRef[]\n}\n\nexport interface MultipleFilesUploadState\n  extends MultipleFilesHandlerResult,\n    MultipleUploadProgressState {\n  /**\n   * Returns `true` when all the files have been successfully uploaded.\n   */\n  isUploaded: boolean\n}\n\nexport type UploadMultipleFilesActionParams = {\n  files?: AnyFileList\n  bucketId?: string\n}\n\nexport const uploadMultipleFilesPromise = async (\n  nhost: NhostClientReturnType,\n  service: InterpreterFrom<MultipleFilesUploadMachine>,\n  params?: UploadMultipleFilesActionParams\n): Promise<MultipleFilesHandlerResult> =>\n  new Promise((resolve) => {\n    service.send({\n      type: 'UPLOAD',\n      url: nhost.storage.url,\n      accessToken: nhost.auth.getAccessToken(),\n      adminSecret: nhost.adminSecret,\n      bucketId: params?.bucketId,\n      files: params?.files\n    })\n    service.onTransition((s) => {\n      if (s.matches('error')) {\n        resolve({\n          errors: s.context.files.filter((ref) => ref.getSnapshot()?.context.error),\n          isError: true,\n          files: []\n        })\n      } else if (s.matches('uploaded')) {\n        resolve({ errors: [], isError: false, files: s.context.files })\n      }\n    })\n  })\n"]},"metadata":{},"sourceType":"module"}